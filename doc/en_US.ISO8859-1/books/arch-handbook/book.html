<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>FreeBSD Architecture Handbook</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><meta name="description" content="Welcome to the FreeBSD Architecture Handbook. This manual is a work in progress and is the work of many individuals. Many sections do not yet exist and some of those that do exist need to be updated. If you are interested in helping with this project, send email to the FreeBSD documentation project mailing list. The latest version of this document is always available from the FreeBSD World Wide Web server. It may also be downloaded in a variety of formats and compression options from the FreeBSD FTP server or one of the numerous mirror sites." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="en" class="book" lang="en"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp43962616"></a>FreeBSD Architecture Handbook</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="orgname">The FreeBSD Documentation
      Project</span></h3></div></div><div>Revision: <a href="https://svnweb.freebsd.org/changeset/doc/bc0c6af5f7"><span class="svnref">bc0c6af5f7</span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2000-2006, 2012-2013 The FreeBSD Documentation Project</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD is a registered trademark of
  the FreeBSD Foundation.</p><p>UNIX is a registered trademark of The
  Open Group in the United States and other countries.</p><p>Apple, AirPort, FireWire,
  iMac, iPhone, iPad,
  Mac, Macintosh, Mac OS,
  Quicktime, and TrueType are trademarks of Apple Inc.,
  registered in the U.S. and other countries.</p><p>Microsoft, IntelliMouse, MS-DOS,
  Outlook, Windows, Windows Media and Windows NT are either
  registered trademarks or trademarks of Microsoft Corporation in the
  United States and/or other countries.</p><p>Many of the designations used by
  manufacturers and sellers to distinguish their products are claimed
  as trademarks.  Where those designations appear in this document,
  and the FreeBSD Project was aware of the trademark claim, the
  designations have been followed by the <span class="quote">&#8220;<span class="quote">&#8482;</span>&#8221;</span> or the
  <span class="quote">&#8220;<span class="quote">®</span>&#8221;</span> symbol.</p></div></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="legalnotice"></a><p class="legalnotice-title"><strong>Copyright</strong></p><p>Redistribution and use in source (XML DocBook) and 'compiled'
    forms (XML, HTML, PDF, PostScript, RTF and so forth) with or without
    modification, are permitted provided that the following conditions are
    met:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Redistributions of source code (XML DocBook) must retain the
        above copyright notice, this list of conditions and the following
        disclaimer as the first lines of this file unmodified.</p></li><li class="listitem"><p>Redistributions in compiled form (transformed to other DTDs,
        converted to PDF, PostScript, RTF and other formats) must
        reproduce the above copyright notice, this list of conditions and
        the following disclaimer in the documentation and/or other
        materials provided with the distribution.</p></li></ol></div><div xmlns="" class="important"><h3 class="admontitle">Important: </h3><p xmlns="http://www.w3.org/1999/xhtml">THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION
      PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
      BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
      THE FREEBSD DOCUMENTATION PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
      OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
      TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
      USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
      DAMAGE.</p></div></div></div><div>Last modified on 2019-09-05 20:22:58 +0000 by bcr.</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Abstract</div><p>Welcome to the FreeBSD Architecture Handbook.  This manual is
	a
	<span class="emphasis"><em>work in progress</em></span> and is the work of many
	individuals.  Many sections do not yet exist and some of those
	that do exist need to be updated.  If you are interested in
	helping with this project, send email to the <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc" target="_top">FreeBSD documentation project mailing list</a>.</p><p>The latest version of this document is always available
	from the <a class="link" href="../../../../index.html" target="_top">FreeBSD
	  World Wide Web server</a>.  It may also be downloaded in
	a variety of formats and compression options from the <a class="link" href="https://download.freebsd.org/ftp/doc/" target="_top">FreeBSD
	  FTP server</a> or one of the numerous <a class="link" href="../../../../doc/en_US.ISO8859-1/books/handbook/mirrors-ftp.html" target="_top">mirror
	  sites</a>.</p></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">Split HTML</a>
      /
      
	  Single HTML
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="part"><a href="#kernel">I. Kernel</a></span></dt><dd><dl><dt><span class="chapter"><a href="#boot">1. Bootstrapping and Kernel Initialization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#boot-synopsis">1.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#boot-overview">1.2. Overview</a></span></dt><dt><span class="sect1"><a href="#boot-bios">1.3. The <acronym class="acronym">BIOS</acronym></a></span></dt><dt><span class="sect1"><a href="#boot-boot0">1.4. The Master Boot Record (<code class="literal">boot0</code>)</a></span></dt><dt><span class="sect1"><a href="#boot-boot1">1.5. <code class="literal">boot1</code> Stage</a></span></dt><dt><span class="sect1"><a href="#btx-server">1.6. The <acronym class="acronym">BTX</acronym> Server</a></span></dt><dt><span class="sect1"><a href="#boot2">1.7. <span class="application">boot2</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-loader">1.8. <span class="application">loader</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-kernel">1.9. Kernel Initialization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#locking">2. Locking Notes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#locking-mutexes">2.1. Mutexes</a></span></dt><dt><span class="sect1"><a href="#locking-sx">2.2. Shared Exclusive Locks</a></span></dt><dt><span class="sect1"><a href="#locking-atomic">2.3. Atomically Protected Variables</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kernel-objects">3. Kernel Objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#kernel-objects-term">3.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-operation">3.2. Kobj Operation</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-using">3.3. Using Kobj</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jail">4. The Jail Subsystem</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jail-arch">4.1. Architecture</a></span></dt><dt><span class="sect1"><a href="#jail-restrictions">4.2. Restrictions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sysinit">5. The SYSINIT Framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sysinit-term">5.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#sysinit-operation">5.2. SYSINIT Operation</a></span></dt><dt><span class="sect1"><a href="#sysinit-using">5.3. Using SYSINIT</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mac">6. The TrustedBSD MAC Framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mac-copyright">6.1. MAC Documentation Copyright</a></span></dt><dt><span class="sect1"><a href="#mac-synopsis">6.2. Synopsis</a></span></dt><dt><span class="sect1"><a href="#mac-introduction">6.3. Introduction</a></span></dt><dt><span class="sect1"><a href="#mac-background">6.4. Policy Background</a></span></dt><dt><span class="sect1"><a href="#mac-framework-kernel-arch">6.5. MAC Framework Kernel Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-policy-architecture">6.6. MAC Policy Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-entry-point-reference">6.7. MAC Policy Entry Point Reference</a></span></dt><dt><span class="sect1"><a href="#mac-userland-arch">6.8. Userland Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-conclusion">6.9. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vm">7. Virtual Memory System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#vm-physmem">7.1. Management of Physical
      Memory&#8212;<code class="literal">vm_page_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-cache">7.2. The Unified Buffer
      Cache&#8212;<code class="literal">vm_object_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-fileio">7.3. Filesystem I/O&#8212;<code class="literal">struct buf</code></a></span></dt><dt><span class="sect1"><a href="#vm-pagetables">7.4. Mapping Page Tables&#8212;<code class="literal">vm_map_t,
	vm_entry_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-kvm">7.5. KVM Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#vm-tuning">7.6. Tuning the FreeBSD VM System</a></span></dt></dl></dd><dt><span class="chapter"><a href="#smp">8. SMPng Design Document</a></span></dt><dd><dl><dt><span class="sect1"><a href="#smp-intro">8.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#smp-lock-fundamentals">8.2. Basic Tools and Locking Fundamentals</a></span></dt><dt><span class="sect1"><a href="#smp-design">8.3. General Architecture and Design</a></span></dt><dt><span class="sect1"><a href="#smp-lock-strategies">8.4. Specific Locking Strategies</a></span></dt><dt><span class="sect1"><a href="#smp-implementation-notes">8.5. Implementation Notes</a></span></dt><dt><span class="sect1"><a href="#smp-misc">8.6. Miscellaneous Topics</a></span></dt><dt><span class="glossary"><a href="#smp-glossary">Glossary</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#devicedrivers">II. Device Drivers</a></span></dt><dd><dl><dt><span class="chapter"><a href="#driverbasics">9. Writing FreeBSD Device Drivers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#driverbasics-intro">9.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#driverbasics-kld">9.2. Dynamic Kernel Linker Facility - KLD</a></span></dt><dt><span class="sect1"><a href="#driverbasics-char">9.3. Character Devices</a></span></dt><dt><span class="sect1"><a href="#driverbasics-block">9.4. Block Devices (Are Gone)</a></span></dt><dt><span class="sect1"><a href="#driverbasics-net">9.5. Network Drivers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#isa-driver">10. ISA Device Drivers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#isa-driver-synopsis">10.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#isa-driver-basics">10.2. Basic Information</a></span></dt><dt><span class="sect1"><a href="#isa-driver-device-t">10.3. <code class="varname">device_t</code> Pointer</a></span></dt><dt><span class="sect1"><a href="#isa-driver-config">10.4. Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</a></span></dt><dt><span class="sect1"><a href="#isa-driver-resources">10.5. Resources</a></span></dt><dt><span class="sect1"><a href="#isa-driver-busmem">10.6. Bus Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#isa-driver-dma">10.7. DMA</a></span></dt><dt><span class="sect1"><a href="#isa-driver-probe">10.8. xxx_isa_probe</a></span></dt><dt><span class="sect1"><a href="#isa-driver-attach">10.9. xxx_isa_attach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-detach">10.10. xxx_isa_detach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-shutdown">10.11. xxx_isa_shutdown</a></span></dt><dt><span class="sect1"><a href="#isa-driver-intr">10.12. xxx_intr</a></span></dt></dl></dd><dt><span class="chapter"><a href="#pci">11. PCI Devices</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pci-probe">11.1. Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#pci-bus">11.2. Bus Resources</a></span></dt></dl></dd><dt><span class="chapter"><a href="#scsi">12. Common Access Method SCSI Controllers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#scsi-synopsis">12.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#scsi-general">12.2. General Architecture</a></span></dt><dt><span class="sect1"><a href="#scsi-polling">12.3. Polling</a></span></dt><dt><span class="sect1"><a href="#scsi-async">12.4. Asynchronous Events</a></span></dt><dt><span class="sect1"><a href="#scsi-interrupts">12.5. Interrupts</a></span></dt><dt><span class="sect1"><a href="#scsi-errors">12.6. Errors Summary</a></span></dt><dt><span class="sect1"><a href="#scsi-timeout">12.7. Timeout Handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#usb">13. USB Devices</a></span></dt><dd><dl><dt><span class="sect1"><a href="#usb-intro">13.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#usb-hc">13.2. Host Controllers</a></span></dt><dt><span class="sect1"><a href="#usb-dev">13.3. USB Device Information</a></span></dt><dt><span class="sect1"><a href="#usb-devprobe">13.4. Device Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#usb-protocol">13.5. USB Drivers Protocol Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#newbus">14. Newbus</a></span></dt><dd><dl><dt><span class="sect1"><a href="#newbus-devdrivers">14.1. Device Drivers</a></span></dt><dt><span class="sect1"><a href="#newbus-overview">14.2. Overview of Newbus</a></span></dt><dt><span class="sect1"><a href="#newbus-api">14.3. Newbus API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#oss">15. Sound Subsystem</a></span></dt><dd><dl><dt><span class="sect1"><a href="#oss-intro">15.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#oss-files">15.2. Files</a></span></dt><dt><span class="sect1"><a href="#pcm-probe-and-attach">15.3. Probing, Attaching, etc.</a></span></dt><dt><span class="sect1"><a href="#oss-interfaces">15.4. Interfaces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#pccard">16. PC Card</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pccard-adddev">16.1. Adding a Device</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#appendices">III. Appendices</a></span></dt><dd><dl><dt><span class="bibliography"><a href="#idp55804920">Bibliography</a></span></dt></dl></dd><dt><span class="index"><a href="#idp55829496">Index</a></span></dt></dl></div><div class="list-of-figures"><div class="toc-title">List of Figures</div><dl><dt>1.1. <a href="#boot-boot0-makefile-as-is"><code class="filename">sys/boot/i386/boot0/Makefile</code></a></dt><dt>1.2. <a href="#boot-boot0-entrypoint"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.3. <a href="#boot-boot0-relocation"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.4. <a href="#boot-boot0-drivenumber"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.5. <a href="#boot-boot0-savedrivenumber"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.6. <a href="#boot-boot0-partition-scan"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.7. <a href="#boot-boot0-test-drives"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.8. <a href="#boot-boot0-prompt"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.9. <a href="#boot-boot0-start-input"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.10. <a href="#boot-boot0-check-bootable"><code class="filename">sys/boot/i386/boot0/boot0.S</code></a></dt><dt>1.11. <a href="#boot-boot1-entry"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.12. <a href="#boot-boot1-main"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.13. <a href="#boot-boot1-find-freebsd"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.14. <a href="#boot-boot2-make-fake-partition"><code class="filename">sys/boot/i386/boot2/Makefile</code></a></dt><dt>1.15. <a href="#boot-boot1-nread"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.16. <a href="#boot-boot1-xread1"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.17. <a href="#boot-boot1-find-part"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.18. <a href="#boot-boot1-main5"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.19. <a href="#boot-boot1-seta20"><code class="filename">sys/boot/i386/boot2/boot1.S</code></a></dt><dt>1.20. <a href="#boot-boot1-make-boot"><code class="filename">sys/boot/i386/boot2/Makefile</code></a></dt><dt>1.21. <a href="#boot-boot1-make-boot1"><code class="filename">sys/boot/i386/boot2/Makefile</code></a></dt><dt>1.22. <a href="#boot-boot1-make-boot2"><code class="filename">sys/boot/i386/boot2/Makefile</code></a></dt><dt>1.23. <a href="#boot-boot1-make-boot2-more"><code class="filename">sys/boot/i386/boot2/Makefile</code></a></dt><dt>1.24. <a href="#boot-boot1-make-boot2h"><code class="filename">sys/boot/i386/boot2/boot2.h</code></a></dt><dt>1.25. <a href="#btx-header"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.26. <a href="#btx-init"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.27. <a href="#btx-clear-mem"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.28. <a href="#btx-ivt"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.29. <a href="#btx-idt"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.30. <a href="#btx-tss"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.31. <a href="#btx-prot"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>1.32. <a href="#btx-end"><code class="filename">sys/boot/i386/btx/btx/btx.S</code></a></dt><dt>14.1. <a href="#idp55527544"><span class="emphasis"><em>driver_t</em></span> Implementation</a></dt><dt>14.2. <a href="#idp55530104">Device
	  States <span class="emphasis"><em>device_state_t</em></span></a></dt></dl></div><div class="list-of-tables"><div class="toc-title">List of Tables</div><dl><dt>2.1. <a href="#idp49178616">Mutex List</a></dt><dt>2.2. <a href="#idp49258232">Shared Exclusive Lock List</a></dt></dl></div><div class="list-of-examples"><div class="toc-title">List of Examples</div><dl><dt>5.1. <a href="#idp49689720">Example of a <code class="literal">SYSINIT()</code></a></dt><dt>5.2. <a href="#idp49692920">Example of Adjusting <code class="literal">SYSINIT()</code>
	  Order</a></dt><dt>5.3. <a href="#idp49696376">Example of a <code class="literal">SYSUNINIT()</code></a></dt><dt>9.1. <a href="#idp54197368">Example of a Sample Echo Pseudo-Device Driver for
	FreeBSD 10.X - 12.X</a></dt><dt>14.1. <a href="#idp55477368">Newbus Methods</a></dt></dl></div><div class="part"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="kernel"></a>Part I. Kernel</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="chapter"><a href="#boot">1. Bootstrapping and Kernel Initialization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#boot-synopsis">1.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#boot-overview">1.2. Overview</a></span></dt><dt><span class="sect1"><a href="#boot-bios">1.3. The <acronym class="acronym">BIOS</acronym></a></span></dt><dt><span class="sect1"><a href="#boot-boot0">1.4. The Master Boot Record (<code class="literal">boot0</code>)</a></span></dt><dt><span class="sect1"><a href="#boot-boot1">1.5. <code class="literal">boot1</code> Stage</a></span></dt><dt><span class="sect1"><a href="#btx-server">1.6. The <acronym class="acronym">BTX</acronym> Server</a></span></dt><dt><span class="sect1"><a href="#boot2">1.7. <span class="application">boot2</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-loader">1.8. <span class="application">loader</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-kernel">1.9. Kernel Initialization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#locking">2. Locking Notes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#locking-mutexes">2.1. Mutexes</a></span></dt><dt><span class="sect1"><a href="#locking-sx">2.2. Shared Exclusive Locks</a></span></dt><dt><span class="sect1"><a href="#locking-atomic">2.3. Atomically Protected Variables</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kernel-objects">3. Kernel Objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#kernel-objects-term">3.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-operation">3.2. Kobj Operation</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-using">3.3. Using Kobj</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jail">4. The Jail Subsystem</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jail-arch">4.1. Architecture</a></span></dt><dt><span class="sect1"><a href="#jail-restrictions">4.2. Restrictions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sysinit">5. The SYSINIT Framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sysinit-term">5.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#sysinit-operation">5.2. SYSINIT Operation</a></span></dt><dt><span class="sect1"><a href="#sysinit-using">5.3. Using SYSINIT</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mac">6. The TrustedBSD MAC Framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mac-copyright">6.1. MAC Documentation Copyright</a></span></dt><dt><span class="sect1"><a href="#mac-synopsis">6.2. Synopsis</a></span></dt><dt><span class="sect1"><a href="#mac-introduction">6.3. Introduction</a></span></dt><dt><span class="sect1"><a href="#mac-background">6.4. Policy Background</a></span></dt><dt><span class="sect1"><a href="#mac-framework-kernel-arch">6.5. MAC Framework Kernel Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-policy-architecture">6.6. MAC Policy Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-entry-point-reference">6.7. MAC Policy Entry Point Reference</a></span></dt><dt><span class="sect1"><a href="#mac-userland-arch">6.8. Userland Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-conclusion">6.9. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vm">7. Virtual Memory System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#vm-physmem">7.1. Management of Physical
      Memory&#8212;<code class="literal">vm_page_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-cache">7.2. The Unified Buffer
      Cache&#8212;<code class="literal">vm_object_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-fileio">7.3. Filesystem I/O&#8212;<code class="literal">struct buf</code></a></span></dt><dt><span class="sect1"><a href="#vm-pagetables">7.4. Mapping Page Tables&#8212;<code class="literal">vm_map_t,
	vm_entry_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-kvm">7.5. KVM Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#vm-tuning">7.6. Tuning the FreeBSD VM System</a></span></dt></dl></dd><dt><span class="chapter"><a href="#smp">8. SMPng Design Document</a></span></dt><dd><dl><dt><span class="sect1"><a href="#smp-intro">8.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#smp-lock-fundamentals">8.2. Basic Tools and Locking Fundamentals</a></span></dt><dt><span class="sect1"><a href="#smp-design">8.3. General Architecture and Design</a></span></dt><dt><span class="sect1"><a href="#smp-lock-strategies">8.4. Specific Locking Strategies</a></span></dt><dt><span class="sect1"><a href="#smp-implementation-notes">8.5. Implementation Notes</a></span></dt><dt><span class="sect1"><a href="#smp-misc">8.6. Miscellaneous Topics</a></span></dt><dt><span class="glossary"><a href="#smp-glossary">Glossary</a></span></dt></dl></dd></dl></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="boot"></a>Chapter 1. Bootstrapping and Kernel Initialization</h2></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Sergey</span> <span class="surname">Lyubka</span></span>. </span></div><div><span class="authorgroup">Updated and enhanced by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Sergio Andrés</span> <span class="surname"> Gómez del Real</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#boot-synopsis">1.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#boot-overview">1.2. Overview</a></span></dt><dt><span class="sect1"><a href="#boot-bios">1.3. The <acronym class="acronym">BIOS</acronym></a></span></dt><dt><span class="sect1"><a href="#boot-boot0">1.4. The Master Boot Record (<code class="literal">boot0</code>)</a></span></dt><dt><span class="sect1"><a href="#boot-boot1">1.5. <code class="literal">boot1</code> Stage</a></span></dt><dt><span class="sect1"><a href="#btx-server">1.6. The <acronym class="acronym">BTX</acronym> Server</a></span></dt><dt><span class="sect1"><a href="#boot2">1.7. <span class="application">boot2</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-loader">1.8. <span class="application">loader</span> Stage</a></span></dt><dt><span class="sect1"><a href="#boot-kernel">1.9. Kernel Initialization</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-synopsis"></a>1.1. Synopsis</h2></div></div></div><a id="idp45058424" class="indexterm"></a><a id="idp45059960" class="indexterm"></a><a id="idp45060856" class="indexterm"></a><a id="idp45062264" class="indexterm"></a><a id="idp45063800" class="indexterm"></a><a id="idp45064696" class="indexterm"></a><p>This chapter is an overview of the boot and system
      initialization processes, starting from the
      <acronym class="acronym">BIOS</acronym> (firmware) <acronym class="acronym">POST</acronym>, to
      the first user process creation.  Since the initial
      steps of system startup are very architecture dependent, the
      IA-32 architecture is used as an example.</p><p>The FreeBSD boot process can be surprisingly complex.  After
      control is passed from the <acronym class="acronym">BIOS</acronym>, a
      considerable amount of low-level configuration must be done
      before the kernel can be loaded and executed.  This setup must
      be done in a simple and flexible manner, allowing the user a
      great deal of customization possibilities.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-overview"></a>1.2. Overview</h2></div></div></div><p>The boot process is an extremely machine-dependent
      activity.  Not only must code be written for every computer
      architecture, but there may also be multiple types of booting on
      the same architecture.  For example, a directory listing of
      <code class="filename">/usr/src/sys/boot</code>
      reveals a great amount of architecture-dependent code.  There is
      a directory for each of the various supported architectures.  In
      the x86-specific <code class="filename">i386</code>
      directory, there are subdirectories for different boot standards
      like <code class="filename">mbr</code> (Master Boot Record),
      <code class="filename">gpt</code> (<acronym class="acronym">GUID</acronym> Partition
      Table), and <code class="filename">efi</code> (Extensible Firmware
      Interface).  Each boot standard has its own conventions and data
      structures.  The example that follows shows booting an x86
      computer from an <acronym class="acronym">MBR</acronym> hard drive with the FreeBSD
      <code class="filename">boot0</code> multi-boot loader stored in the very
      first sector.  That boot code starts the FreeBSD three-stage boot
      process.</p><p>The key to understanding this process is that it is a series
      of stages of increasing complexity.  These stages are
      <code class="filename">boot1</code>, <code class="filename">boot2</code>, and
      <code class="filename">loader</code> (see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a> for more detail).
      The boot system executes each stage in sequence.  The last
      stage, <code class="filename">loader</code>, is responsible for loading
      the FreeBSD kernel.  Each stage is examined in the following
      sections.</p><p>Here is an example of the output generated by the
      different boot stages.  Actual output
      may differ from machine to machine:</p><div class="informaltable"><table class="informaltable" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>FreeBSD Component</td><td>Output (may vary)</td></tr><tr><td><code class="literal">boot0</code></td><td><pre class="screen">F1    FreeBSD
F2    BSD
F5    Disk 2</pre></td></tr><tr><td><code class="literal">boot2</code>
	      <a href="#ftn.idp45112312" class="footnote" id="idp45112312"><sup class="footnote">[a]</sup></a></td><td><pre class="screen">&gt;&gt;FreeBSD/i386 BOOT
Default: 1:ad(1,a)/boot/loader
boot:</pre></td></tr><tr><td><code class="filename">loader</code></td><td><pre class="screen">BTX loader 1.00 BTX version is 1.02
Consoles: internal video/keyboard
BIOS drive C: is disk0
BIOS 639kB/2096064kB available memory

FreeBSD/x86 bootstrap loader, Revision 1.1
Console internal video/keyboard
(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)
Loading /boot/defaults/loader.conf
/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms=[0x8+0x137988+0x8+0x1515f8]</pre></td></tr><tr><td>kernel</td><td><pre class="screen">Copyright (c) 1992-2013 The FreeBSD Project.
Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.
FreeBSD is a registered trademark of The FreeBSD Foundation.
FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014
    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64
FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610</pre></td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idp45112312" class="footnote"><p><a href="#idp45112312" class="para"><sup class="para">[a] </sup></a>This prompt will appear if the user
		  presses a key just after selecting an OS to boot at
		  the <code class="literal">boot0</code>
		  stage.</p></div></td></tr></tbody></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-bios"></a>1.3. The <acronym class="acronym">BIOS</acronym></h2></div></div></div><p>When the computer powers on, the processor's registers are
      set to some predefined values.  One of the registers is the
      <span class="emphasis"><em>instruction pointer</em></span> register, and its value
      after a power on is well defined: it is a 32-bit value of
      <code class="literal">0xfffffff0</code>.  The instruction pointer register
      (also known as the Program Counter) points to code to be
      executed by the processor.  Another important register is the
      <code class="literal">cr0</code> 32-bit control register, and its value
      just after a reboot is <code class="literal">0</code>.  One of
      <code class="literal">cr0</code>'s bits, the PE (Protection Enabled) bit,
      indicates whether the processor is running in 32-bit protected
      mode or 16-bit real mode.  Since this bit is cleared at boot
      time, the processor boots in 16-bit real mode.  Real mode means,
      among other things, that linear and physical addresses are
      identical.  The reason for the processor not to start
      immediately in 32-bit protected mode is backwards compatibility.
      In particular, the boot process relies on the services provided
      by the <acronym class="acronym">BIOS</acronym>, and the <acronym class="acronym">BIOS</acronym>
      itself works in legacy, 16-bit code.</p><p>The value of <code class="literal">0xfffffff0</code> is slightly less
      than 4 GB, so unless the machine has 4 GB of physical
      memory, it cannot point to a valid memory address.  The
      computer's hardware translates this address so that it points to
      a <acronym class="acronym">BIOS</acronym> memory block.</p><p>The <acronym class="acronym">BIOS</acronym> (Basic Input Output
      System) is a chip on the motherboard that has a relatively small
      amount of read-only memory (<acronym class="acronym">ROM</acronym>).  This
      memory contains various low-level routines that are specific to
      the hardware supplied with the motherboard.  The processor will
      first jump to the address 0xfffffff0, which really resides in
      the <acronym class="acronym">BIOS</acronym>'s memory.  Usually this address
      contains a jump instruction to the <acronym class="acronym">BIOS</acronym>'s
      POST routines.</p><p>The <acronym class="acronym">POST</acronym> (Power On Self Test)
      is a set of routines including the memory check, system bus
      check, and other low-level initialization so the
      <acronym class="acronym">CPU</acronym> can set up the computer properly.  The
      important step of this stage is determining the boot device.
      Modern <acronym class="acronym">BIOS</acronym> implementations permit the
      selection of a boot device, allowing booting from a floppy,
      <acronym class="acronym">CD-ROM</acronym>, hard disk, or other devices.</p><p>The very last thing in the <acronym class="acronym">POST</acronym> is the
      <code class="literal">INT 0x19</code> instruction.  The
      <code class="literal">INT 0x19</code> handler reads 512 bytes from the
      first sector of boot device into the memory at address
      <code class="literal">0x7c00</code>.  The term
      <span class="emphasis"><em>first sector</em></span> originates from hard drive
      architecture, where the magnetic plate is divided into a number
      of cylindrical tracks.  Tracks are numbered, and every track is
      divided into a number (usually 64) of sectors.  Track numbers
      start at 0, but sector numbers start from 1. Track 0 is the
      outermost on the magnetic plate, and sector 1, the first sector,
      has a special purpose.  It is also called the
      <acronym class="acronym">MBR</acronym>, or Master Boot Record.  The remaining
      sectors on the first track are never used.</p><p>This sector is our boot-sequence starting point.  As we will
      see, this sector contains a copy of our
      <code class="filename">boot0</code> program.  A jump is made by the
      <acronym class="acronym">BIOS</acronym> to address <code class="literal">0x7c00</code> so
      it starts executing.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-boot0"></a>1.4. The Master Boot Record (<code class="literal">boot0</code>)</h2></div></div></div><a id="idp45176184" class="indexterm"></a><p>After control is received from the <acronym class="acronym">BIOS</acronym>
      at memory address <code class="literal">0x7c00</code>,
      <code class="filename">boot0</code> starts executing.  It is the first
      piece of code under FreeBSD control.  The task of
      <code class="filename">boot0</code> is quite simple: scan the partition
      table and let the user choose which partition to boot from.  The
      Partition Table is a special, standard data structure embedded
      in the <acronym class="acronym">MBR</acronym> (hence embedded in
      <code class="filename">boot0</code>) describing the four standard PC
      <span class="quote">&#8220;<span class="quote">partitions</span>&#8221;</span>
      <a href="#ftn.idp45185272" class="footnote" id="idp45185272"><sup class="footnote">[1]</sup></a>.
      <code class="filename">boot0</code> resides in the filesystem as
      <code class="filename">/boot/boot0</code>.  It is a small 512-byte file,
      and it is exactly what FreeBSD's installation procedure wrote to
      the hard disk's <acronym class="acronym">MBR</acronym> if you chose the
      <span class="quote">&#8220;<span class="quote">bootmanager</span>&#8221;</span> option at installation time.  Indeed,
      <code class="filename">boot0</code> <span class="emphasis"><em>is</em></span> the
      <acronym class="acronym">MBR</acronym>.</p><p>As mentioned previously, the <code class="literal">INT 0x19</code>
      instruction causes the <code class="literal">INT 0x19</code> handler to
      load an <acronym class="acronym">MBR</acronym> (<code class="filename">boot0</code>) into
      memory at address <code class="literal">0x7c00</code>.  The source file
      for <code class="filename">boot0</code> can be found in
      <code class="filename">sys/boot/i386/boot0/boot0.S</code> - which is an
      awesome piece of code written by Robert Nordier.</p><p>A special structure starting from offset
      <code class="literal">0x1be</code> in the <acronym class="acronym">MBR</acronym> is called
      the <span class="emphasis"><em>partition table</em></span>.  It has four records
      of 16 bytes each, called <span class="emphasis"><em>partition records</em></span>,
      which represent how the hard disk is partitioned, or, in FreeBSD's
      terminology, sliced.  One byte of those 16 says whether a
      partition (slice) is bootable or not.  Exactly one record must
      have that flag set, otherwise <code class="filename">boot0</code>'s code
      will refuse to proceed.</p><p>A partition record has the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>the 1-byte filesystem type</p></li><li class="listitem"><p>the 1-byte bootable flag</p></li><li class="listitem"><p>the 6 byte descriptor in CHS format</p></li><li class="listitem"><p>the 8 byte descriptor in LBA format</p></li></ul></div><p>A partition record descriptor contains information about
      where exactly the partition resides on the drive.  Both
      descriptors, <acronym class="acronym">LBA</acronym> and <acronym class="acronym">CHS</acronym>,
      describe the same information, but in different ways:
      <acronym class="acronym">LBA</acronym> (Logical Block Addressing) has the
      starting sector for the partition and the partition's length,
      while <acronym class="acronym">CHS</acronym> (Cylinder Head Sector) has
      coordinates for the first and last sectors of the partition.
      The partition table ends with the special signature
      <code class="literal">0xaa55</code>.</p><p>The <acronym class="acronym">MBR</acronym> must fit into 512 bytes, a single
      disk sector.  This program uses low-level <span class="quote">&#8220;<span class="quote">tricks</span>&#8221;</span>
      like taking advantage of the side effects of certain
      instructions and reusing register values from previous
      operations to make the most out of the fewest possible
      instructions.  Care must also be taken when handling the
      partition table, which is embedded in the <acronym class="acronym">MBR</acronym>
      itself.  For these reasons, be very careful when modifying
      <code class="filename">boot0.S</code>.</p><p>Note that the <code class="filename">boot0.S</code> source file
      is assembled <span class="quote">&#8220;<span class="quote">as is</span>&#8221;</span>: instructions are translated
      one by one to binary, with no additional information (no
      <acronym class="acronym">ELF</acronym> file format, for example).  This kind of
      low-level control is achieved at link time through special
      control flags passed to the linker.  For example, the text
      section of the program is set to be located at address
      <code class="literal">0x600</code>.  In practice this means that
      <code class="filename">boot0</code> must be loaded to memory address
      <code class="literal">0x600</code> in order to function properly.</p><p>It is worth looking at the <code class="filename">Makefile</code> for
      <code class="filename">boot0</code>
      (<code class="filename">sys/boot/i386/boot0/Makefile</code>), as it
      defines some of the run-time behavior of
      <code class="filename">boot0</code>.  For instance, if a terminal
      connected to the serial port (COM1) is used for I/O, the macro
      <code class="literal">SIO</code> must be defined
      (<code class="literal">-DSIO</code>).  <code class="literal">-DPXE</code> enables
      boot through <acronym class="acronym">PXE</acronym> by pressing
      <span class="keycap"><strong>F6</strong></span>.  Additionally, the program defines a set of
      <span class="emphasis"><em>flags</em></span> that allow further modification of
      its behavior.  All of this is illustrated in the
      <code class="filename">Makefile</code>.  For example, look at the
      linker directives which command the linker to start the text
      section at address <code class="literal">0x600</code>, and to build the
      output file <span class="quote">&#8220;<span class="quote">as is</span>&#8221;</span> (strip out any file
      formatting):</p><div class="figure"><a id="boot-boot0-makefile-as-is"></a><div class="figure-title">Figure 1.1. <code class="filename">sys/boot/i386/boot0/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      BOOT_BOOT0_ORG?=0x600
      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \
      -Wl,-N,-S,--oformat,binary</pre></div></div><br class="figure-break" /><p>Let us now start our study of the <acronym class="acronym">MBR</acronym>, or
      <code class="filename">boot0</code>, starting where execution
      begins.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Some modifications have been made to some instructions in
	favor of better exposition.  For example, some macros are
	expanded, and some macro tests are omitted when the result of
	the test is known.  This applies to all of the code examples
	shown.</p></div><div class="figure"><a id="boot-boot0-entrypoint"></a><div class="figure-title">Figure 1.2. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">start:
      cld			# String ops inc
      xorw %ax,%ax		# Zero
      movw %ax,%es		# Address
      movw %ax,%ds		#  data
      movw %ax,%ss		# Set up
      movw 0x7c00,%sp		#  stack</pre></div></div><br class="figure-break" /><p>This first block of code is the entry point of the program.
      It is where the <acronym class="acronym">BIOS</acronym> transfers control.
      First, it makes sure that the string operations autoincrement
      its pointer operands (the <code class="literal">cld</code> instruction)
      <a href="#ftn.idp45318520" class="footnote" id="idp45318520"><sup class="footnote">[2]</sup></a>.
      Then, as it makes no assumption about the state of the segment
      registers, it initializes them.  Finally, it sets the stack
      pointer register (<code class="literal">%sp</code>) to address
      <code class="literal">0x7c00</code>, so we have a working stack.</p><p>The next block is responsible for the relocation and
      subsequent jump to the relocated code.</p><div class="figure"><a id="boot-boot0-relocation"></a><div class="figure-title">Figure 1.3. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">      movw $0x7c00,%si	# Source
      movw $0x600,%di		# Destination
      movw $512,%cx		# Word count
      rep			# Relocate
      movsb			#  code
      movw %di,%bp		# Address variables
      movb $16,%cl		# Words to clear
      rep			# Zero
      stosb			#  them
      incb -0xe(%di)		# Set the S field to 1
      jmp main-0x7c00+0x600	# Jump to relocated code</pre></div></div><br class="figure-break" /><p>Because <code class="filename">boot0</code> is loaded by the
      <acronym class="acronym">BIOS</acronym> to address <code class="literal">0x7C00</code>, it
      copies itself to address <code class="literal">0x600</code> and then
      transfers control there (recall that it was linked to execute at
      address <code class="literal">0x600</code>).  The source address,
      <code class="literal">0x7c00</code>, is copied to register
      <code class="literal">%si</code>.  The destination address,
      <code class="literal">0x600</code>, to register <code class="literal">%di</code>.
      The number of bytes to copy, <code class="literal">512</code> (the
      program's size), is copied to register <code class="literal">%cx</code>.
      Next, the <code class="literal">rep</code> instruction repeats the
      instruction that follows, that is, <code class="literal">movsb</code>, the
      number of times dictated by the <code class="literal">%cx</code> register.
      The <code class="literal">movsb</code> instruction copies the byte pointed
      to by <code class="literal">%si</code> to the address pointed to by
      <code class="literal">%di</code>.  This is repeated another 511 times.  On
      each repetition, both the source and destination registers,
      <code class="literal">%si</code> and <code class="literal">%di</code>, are
      incremented by one.  Thus, upon completion of the 512-byte copy,
      <code class="literal">%di</code> has the value
      <code class="literal">0x600</code>+<code class="literal">512</code>=
      <code class="literal">0x800</code>, and <code class="literal">%si</code> has the
      value <code class="literal">0x7c00</code>+<code class="literal">512</code>=
      <code class="literal">0x7e00</code>; we have thus completed the code
      <span class="emphasis"><em>relocation</em></span>.</p><p>Next, the destination register
      <code class="literal">%di</code> is copied to <code class="literal">%bp</code>.
      <code class="literal">%bp</code> gets the value <code class="literal">0x800</code>.
      The value <code class="literal">16</code> is copied to
      <code class="literal">%cl</code> in preparation for a new string operation
      (like our previous <code class="literal">movsb</code>).  Now,
      <code class="literal">stosb</code> is executed 16 times.  This instruction
      copies a <code class="literal">0</code> value to the address pointed to by
      the destination register (<code class="literal">%di</code>, which is
      <code class="literal">0x800</code>), and increments it.  This is repeated
      another 15 times, so <code class="literal">%di</code> ends up with value
      <code class="literal">0x810</code>.  Effectively, this clears the address
      range <code class="literal">0x800</code>-<code class="literal">0x80f</code>.  This
      range is used as a (fake) partition table for writing the
      <acronym class="acronym">MBR</acronym> back to disk.  Finally, the sector field
      for the <acronym class="acronym">CHS</acronym> addressing of this fake partition
      is given the value 1 and a jump is made to the main function
      from the relocated code.  Note that until this jump to the
      relocated code, any reference to an absolute address was
      avoided.</p><p>The following code block tests whether the drive number
      provided by the <acronym class="acronym">BIOS</acronym> should be used, or
      the one stored in <code class="filename">boot0</code>.</p><div class="figure"><a id="boot-boot0-drivenumber"></a><div class="figure-title">Figure 1.4. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">main:
      testb $SETDRV,-69(%bp)	# Set drive number?
      jnz disable_update	# Yes
      testb %dl,%dl		# Drive number valid?
      js save_curdrive		# Possibly (0x80 set)</pre></div></div><br class="figure-break" /><p>This code tests the <code class="literal">SETDRV</code> bit
      (<code class="literal">0x20</code>) in the <span class="emphasis"><em>flags</em></span>
      variable.  Recall that register <code class="literal">%bp</code> points to
      address location <code class="literal">0x800</code>, so the test is done
      to the <span class="emphasis"><em>flags</em></span> variable at address
      <code class="literal">0x800</code>-<code class="literal">69</code>=
      <code class="literal">0x7bb</code>.  This is an example of the type of
      modifications that can be done to <code class="filename">boot0</code>.
      The <code class="literal">SETDRV</code> flag is not set by default, but it
      can be set in the <code class="filename">Makefile</code>.  When set, the
      drive number stored in the <acronym class="acronym">MBR</acronym> is used
      instead of the one provided by the <acronym class="acronym">BIOS</acronym>.  We
      assume the defaults, and that the <acronym class="acronym">BIOS</acronym>
      provided a valid drive number, so we jump to
      <code class="literal">save_curdrive</code>.</p><p>The next block saves the drive number provided by the
      <acronym class="acronym">BIOS</acronym>, and calls <code class="literal">putn</code> to
      print a new line on the screen.</p><div class="figure"><a id="boot-boot0-savedrivenumber"></a><div class="figure-title">Figure 1.5. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">save_curdrive:
      movb %dl, (%bp)		# Save drive number
      pushw %dx			# Also in the stack
#ifdef	TEST	/* test code, print internal bios drive */
      rolb $1, %dl
      movw $drive, %si
      call putkey
#endif
      callw putn		# Print a newline</pre></div></div><br class="figure-break" /><p>Note that we assume <code class="varname">TEST</code> is not defined,
      so the conditional code in it is not assembled and will not
      appear in our executable <code class="filename">boot0</code>.</p><p>Our next block implements the actual scanning of the
      partition table.  It prints to the screen the partition type for
      each of the four entries in the partition table.  It compares
      each type with a list of well-known operating system file
      systems.  Examples of recognized partition types are
      <acronym class="acronym">NTFS</acronym> (<span class="trademark">Windows</span>®, ID 0x7),
      <code class="literal">ext2fs</code> (<span class="trademark">Linux</span>®, ID 0x83), and, of course,
      <code class="literal">ffs</code>/<code class="literal">ufs2</code> (FreeBSD, ID 0xa5).
      The implementation is fairly simple.</p><div class="figure"><a id="boot-boot0-partition-scan"></a><div class="figure-title">Figure 1.6. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">      movw $(partbl+0x4),%bx	# Partition table (+4)
      xorw %dx,%dx		# Item number

read_entry:
      movb %ch,-0x4(%bx)	# Zero active flag (ch == 0)
      btw %dx,_FLAGS(%bp)	# Entry enabled?
      jnc next_entry		# No
      movb (%bx),%al		# Load type
      test %al, %al		# skip empty partition
      jz next_entry
      movw $bootable_ids,%di	# Lookup tables
      movb $(TLEN+1),%cl	# Number of entries
      repne			# Locate
      scasb			#  type
      addw $(TLEN-1), %di	# Adjust
      movb (%di),%cl		# Partition
      addw %cx,%di		#  description
      callw putx		# Display it

next_entry:
      incw %dx			# Next item
      addb $0x10,%bl		# Next entry
      jnc read_entry		# Till done</pre></div></div><br class="figure-break" /><p>It is important to note that the active flag for each entry
      is cleared, so after the scanning, <span class="emphasis"><em>no</em></span>
      partition entry is active in our memory copy of
      <code class="filename">boot0</code>.  Later, the active flag will be set
      for the selected partition.  This ensures that only one active
      partition exists if the user chooses to write the changes back
      to disk.</p><p>The next block tests for other drives.  At startup,
      the <acronym class="acronym">BIOS</acronym> writes the number of drives present
      in the computer to address <code class="literal">0x475</code>.  If there
      are any other drives present, <code class="filename">boot0</code> prints
      the current drive to screen.  The user may command
      <code class="filename">boot0</code> to scan partitions on another drive
      later.</p><div class="figure"><a id="boot-boot0-test-drives"></a><div class="figure-title">Figure 1.7. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">      popw %ax			# Drive number
      subb $0x79,%al		# Does next
      cmpb 0x475,%al		#  drive exist? (from BIOS?)
      jb print_drive		# Yes
      decw %ax			# Already drive 0?
      jz print_prompt		# Yes</pre></div></div><br class="figure-break" /><p>We make the assumption that a single drive is present, so
      the jump to <code class="literal">print_drive</code> is not performed.  We
      also assume nothing strange happened, so we jump to
      <code class="literal">print_prompt</code>.</p><p>This next block just prints out a prompt followed by the
      default option:</p><div class="figure"><a id="boot-boot0-prompt"></a><div class="figure-title">Figure 1.8. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">print_prompt:
      movw $prompt,%si		# Display
      callw putstr		#  prompt
      movb _OPT(%bp),%dl	# Display
      decw %si			#  default
      callw putkey		#  key
      jmp start_input		# Skip beep</pre></div></div><br class="figure-break" /><p>Finally, a jump is performed to
      <code class="literal">start_input</code>, where the
      <acronym class="acronym">BIOS</acronym> services are used to start a timer and
      for reading user input from the keyboard; if the timer expires,
      the default option will be selected:</p><div class="figure"><a id="boot-boot0-start-input"></a><div class="figure-title">Figure 1.9. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">start_input:
      xorb %ah,%ah		# BIOS: Get
      int $0x1a			#  system time
      movw %dx,%di		# Ticks when
      addw _TICKS(%bp),%di	#  timeout
read_key:
      movb $0x1,%ah		# BIOS: Check
      int $0x16			#  for keypress
      jnz got_key		# Have input
      xorb %ah,%ah		# BIOS: int 0x1a, 00
      int $0x1a			#  get system time
      cmpw %di,%dx		# Timeout?
      jb read_key		# No</pre></div></div><br class="figure-break" /><p>An interrupt is requested with number
      <code class="literal">0x1a</code> and argument <code class="literal">0</code> in
      register <code class="literal">%ah</code>.  The <acronym class="acronym">BIOS</acronym>
      has a predefined set of services, requested by applications as
      software-generated interrupts through the <code class="literal">int</code>
      instruction and receiving arguments in registers (in this case,
      <code class="literal">%ah</code>).  Here, particularly, we are requesting
      the number of clock ticks since last midnight; this value is
      computed by the <acronym class="acronym">BIOS</acronym> through the
      <acronym class="acronym">RTC</acronym> (Real Time Clock).  This clock can be
      programmed to work at frequencies ranging from 2 Hz to
      8192 Hz.  The <acronym class="acronym">BIOS</acronym> sets it to
      18.2 Hz at startup.  When the request is satisfied, a
      32-bit result is returned by the <acronym class="acronym">BIOS</acronym> in
      registers <code class="literal">%cx</code> and <code class="literal">%dx</code>
      (lower bytes in <code class="literal">%dx</code>).  This result (the
      <code class="literal">%dx</code> part) is copied to register
      <code class="literal">%di</code>, and the value of the
      <code class="varname">TICKS</code> variable is added to
      <code class="literal">%di</code>.  This variable resides in
      <code class="filename">boot0</code> at offset <code class="literal">_TICKS</code>
      (a negative value) from register <code class="literal">%bp</code> (which,
      recall, points to <code class="literal">0x800</code>).  The default value
      of this variable is <code class="literal">0xb6</code> (182 in decimal).
      Now, the idea is that <code class="filename">boot0</code> constantly
      requests the time from the <acronym class="acronym">BIOS</acronym>, and when the
      value returned in register <code class="literal">%dx</code> is greater
      than the value stored in <code class="literal">%di</code>, the time is up
      and the default selection will be made.  Since the RTC ticks
      18.2 times per second, this condition will be met after 10
      seconds (this default behavior can be changed in the
      <code class="filename">Makefile</code>).  Until this time has passed,
      <code class="filename">boot0</code> continually asks the
      <acronym class="acronym">BIOS</acronym> for any user input; this is done through
      <code class="literal">int 0x16</code>, argument <code class="literal">1</code> in
      <code class="literal">%ah</code>.</p><p>Whether a key was pressed or the time expired, subsequent
      code validates the selection.  Based on the selection, the
      register <code class="literal">%si</code> is set to point to the
      appropriate partition entry in the partition table.  This new
      selection overrides the previous default one.  Indeed, it
      becomes the new default.  Finally, the ACTIVE flag of the
      selected partition is set.  If it was enabled at compile time,
      the in-memory version of <code class="filename">boot0</code> with these
      modified values is written back to the <acronym class="acronym">MBR</acronym> on
      disk.  We leave the details of this implementation to the
      reader.</p><p>We now end our study with the last code block from the
      <code class="filename">boot0</code> program:</p><div class="figure"><a id="boot-boot0-check-bootable"></a><div class="figure-title">Figure 1.10. <code class="filename">sys/boot/i386/boot0/boot0.S</code></div><div class="figure-contents"><pre class="programlisting">      movw $0x7c00,%bx		# Address for read
      movb $0x2,%ah		# Read sector
      callw intx13		#  from disk
      jc beep			# If error
      cmpw $0xaa55,0x1fe(%bx)	# Bootable?
      jne beep			# No
      pushw %si			# Save ptr to selected part.
      callw putn		# Leave some space
      popw %si			# Restore, next stage uses it
      jmp *%bx			# Invoke bootstrap</pre></div></div><br class="figure-break" /><p>Recall that <code class="literal">%si</code> points to the selected
      partition entry.  This entry tells us where the partition begins
      on disk.  We assume, of course, that the partition selected is
      actually a FreeBSD slice.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">From now on, we will favor the use of the technically
	more accurate term <span class="quote">&#8220;<span class="quote">slice</span>&#8221;</span> rather than
	<span class="quote">&#8220;<span class="quote">partition</span>&#8221;</span>.</p></div><p>The transfer buffer is set to <code class="literal">0x7c00</code>
      (register <code class="literal">%bx</code>), and a read for the first
      sector of the FreeBSD slice is requested by calling
      <code class="literal">intx13</code>.  We assume that everything went okay,
      so a jump to <code class="literal">beep</code> is not performed.  In
      particular, the new sector read must end with the magic sequence
      <code class="literal">0xaa55</code>.  Finally, the value at
      <code class="literal">%si</code> (the pointer to the selected partition
      table) is preserved for use by the next stage, and a jump is
      performed to address <code class="literal">0x7c00</code>, where execution
      of our next stage (the just-read block) is started.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-boot1"></a>1.5. <code class="literal">boot1</code> Stage</h2></div></div></div><p>So far we have gone through the following sequence:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The <acronym class="acronym">BIOS</acronym> did some early hardware
	  initialization, including the <acronym class="acronym">POST</acronym>.  The
	  <acronym class="acronym">MBR</acronym> (<code class="filename">boot0</code>) was
	  loaded from absolute disk sector one to address
	  <code class="literal">0x7c00</code>.  Execution control was passed to
	  that location.</p></li><li class="listitem"><p><code class="filename">boot0</code> relocated itself to the
	  location it was linked to execute
	  (<code class="literal">0x600</code>), followed by a jump to continue
	  execution at the appropriate place.  Finally,
	  <code class="filename">boot0</code> loaded the first disk sector from
	  the FreeBSD slice to address <code class="literal">0x7c00</code>.
	  Execution control was passed to that location.</p></li></ul></div><p><code class="filename">boot1</code> is the next step in the
      boot-loading sequence.  It is the first of three boot stages.
      Note that we have been dealing exclusively
      with disk sectors.  Indeed, the <acronym class="acronym">BIOS</acronym> loads
      the absolute first sector, while <code class="filename">boot0</code>
      loads the first sector of the FreeBSD slice.  Both loads are to
      address <code class="literal">0x7c00</code>.  We can conceptually think of
      these disk sectors as containing the files
      <code class="filename">boot0</code> and <code class="filename">boot1</code>,
      respectively, but in reality this is not entirely true for
      <code class="filename">boot1</code>.  Strictly speaking, unlike
      <code class="filename">boot0</code>, <code class="filename">boot1</code> is not
      part of the boot blocks
      <a href="#ftn.idp45579000" class="footnote" id="idp45579000"><sup class="footnote">[3]</sup></a>.
      Instead, a single, full-blown file, <code class="filename">boot</code>
      (<code class="filename">/boot/boot</code>), is what ultimately is
      written to disk.  This file is a combination of
      <code class="filename">boot1</code>, <code class="filename">boot2</code> and the
      <code class="literal">Boot Extender</code> (or <acronym class="acronym">BTX</acronym>).
      This single file is greater in size than a single sector
      (greater than 512 bytes).  Fortunately,
      <code class="filename">boot1</code> occupies <span class="emphasis"><em>exactly</em></span>
      the first 512 bytes of this single file, so when
      <code class="filename">boot0</code> loads the first sector of the FreeBSD
      slice (512 bytes), it is actually loading
      <code class="filename">boot1</code> and transferring control to
      it.</p><p>The main task of <code class="filename">boot1</code> is to load the
      next boot stage.  This next stage is somewhat more complex.  It
      is composed of a server called the <span class="quote">&#8220;<span class="quote">Boot Extender</span>&#8221;</span>,
      or <acronym class="acronym">BTX</acronym>, and a client, called
      <code class="filename">boot2</code>.  As we will see, the last boot
      stage, <code class="filename">loader</code>, is also a client of the
      <acronym class="acronym">BTX</acronym> server.</p><p>Let us now look in detail at what exactly is done by
      <code class="filename">boot1</code>, starting like we did for
      <code class="filename">boot0</code>, at its entry point:</p><div class="figure"><a id="boot-boot1-entry"></a><div class="figure-title">Figure 1.11. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">start:
	jmp main</pre></div></div><br class="figure-break" /><p>The entry point at <code class="literal">start</code> simply jumps
      past a special data area to the label <code class="literal">main</code>,
      which in turn looks like this:</p><div class="figure"><a id="boot-boot1-main"></a><div class="figure-title">Figure 1.12. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">main:
      cld			# String ops inc
      xor %cx,%cx		# Zero
      mov %cx,%es		# Address
      mov %cx,%ds		#  data
      mov %cx,%ss		# Set up
      mov $start,%sp		#  stack
      mov %sp,%si		# Source
      mov $0x700,%di		# Destination
      incb %ch			# Word count
      rep			# Copy
      movsw			#  code</pre></div></div><br class="figure-break" /><p>Just like <code class="filename">boot0</code>, this
      code relocates <code class="filename">boot1</code>,
      this time to memory address <code class="literal">0x700</code>.  However,
      unlike <code class="filename">boot0</code>, it does not jump there.
      <code class="filename">boot1</code> is linked to execute at
      address <code class="literal">0x7c00</code>, effectively where it was
      loaded in the first place.  The reason for this relocation will
      be discussed shortly.</p><p>Next comes a loop that looks for the FreeBSD slice.  Although
      <code class="filename">boot0</code> loaded <code class="filename">boot1</code>
      from the FreeBSD slice, no information was passed to it about this
      <a href="#ftn.idp45644280" class="footnote" id="idp45644280"><sup class="footnote">[4]</sup></a>,
      so <code class="filename">boot1</code> must rescan the
      partition table to find where the FreeBSD slice starts.  Therefore
      it rereads the <acronym class="acronym">MBR</acronym>:</p><div class="figure"><a id="boot-boot1-find-freebsd"></a><div class="figure-title">Figure 1.13. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">      mov $part4,%si		# Partition
      cmpb $0x80,%dl		# Hard drive?
      jb main.4			# No
      movb $0x1,%dh		# Block count
      callw nread		# Read MBR</pre></div></div><br class="figure-break" /><p>In the code above, register <code class="literal">%dl</code>
      maintains information about the boot device.  This is passed on
      by the <acronym class="acronym">BIOS</acronym> and preserved by the
      <acronym class="acronym">MBR</acronym>.  Numbers <code class="literal">0x80</code> and
      greater tells us that we are dealing with a hard drive, so a
      call is made to <code class="literal">nread</code>, where the
      <acronym class="acronym">MBR</acronym> is read.  Arguments to
      <code class="literal">nread</code> are passed through
      <code class="literal">%si</code> and <code class="literal">%dh</code>.  The memory
      address at label <code class="literal">part4</code> is copied to
      <code class="literal">%si</code>.  This memory address holds a
      <span class="quote">&#8220;<span class="quote">fake partition</span>&#8221;</span> to be used by
      <code class="literal">nread</code>.  The following is the data in the fake
      partition:</p><div class="figure"><a id="boot-boot2-make-fake-partition"></a><div class="figure-title">Figure 1.14. <code class="filename">sys/boot/i386/boot2/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      part4:
	.byte 0x80, 0x00, 0x01, 0x00
	.byte 0xa5, 0xfe, 0xff, 0xff
	.byte 0x00, 0x00, 0x00, 0x00
	.byte 0x50, 0xc3, 0x00, 0x00</pre></div></div><br class="figure-break" /><p>In particular, the <acronym class="acronym">LBA</acronym> for this fake
      partition is hardcoded to zero.  This is used as an argument to
      the <acronym class="acronym">BIOS</acronym> for reading absolute sector one from
      the hard drive.  Alternatively, CHS addressing could be used.
      In this case, the fake partition holds cylinder 0, head 0 and
      sector 1, which is equivalent to absolute sector one.</p><p>Let us now proceed to take a look at
      <code class="literal">nread</code>:</p><div class="figure"><a id="boot-boot1-nread"></a><div class="figure-title">Figure 1.15. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">nread:
      mov $0x8c00,%bx		# Transfer buffer
      mov 0x8(%si),%ax		# Get
      mov 0xa(%si),%cx		#  LBA
      push %cs			# Read from
      callw xread.1		#  disk
      jnc return		# If success, return</pre></div></div><br class="figure-break" /><p>Recall that <code class="literal">%si</code> points to the fake
      partition.  The word
      <a href="#ftn.idp45697400" class="footnote" id="idp45697400"><sup class="footnote">[5]</sup></a>
      at offset <code class="literal">0x8</code> is copied to register
      <code class="literal">%ax</code> and word at offset <code class="literal">0xa</code>
      to <code class="literal">%cx</code>.  They are interpreted by the
      <acronym class="acronym">BIOS</acronym> as the lower 4-byte value denoting the
      LBA to be read (the upper four bytes are assumed to be zero).
      Register <code class="literal">%bx</code> holds the memory address where
      the <acronym class="acronym">MBR</acronym> will be loaded.  The instruction
      pushing <code class="literal">%cs</code> onto the stack is very
      interesting.  In this context, it accomplishes nothing.
      However, as we will see shortly, <code class="filename">boot2</code>, in
      conjunction with the <acronym class="acronym">BTX</acronym> server, also uses
      <code class="literal">xread.1</code>.  This mechanism will be discussed in
      the next section.</p><p>The code at <code class="literal">xread.1</code> further calls
      the <code class="literal">read</code> function, which actually calls the
      <acronym class="acronym">BIOS</acronym> asking for the disk sector:</p><div class="figure"><a id="boot-boot1-xread1"></a><div class="figure-title">Figure 1.16. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">xread.1:
	pushl $0x0		#  absolute
	push %cx		#  block
	push %ax		#  number
	push %es		# Address of
	push %bx		#  transfer buffer
	xor %ax,%ax		# Number of
	movb %dh,%al		#  blocks to
	push %ax		#  transfer
	push $0x10		# Size of packet
	mov %sp,%bp		# Packet pointer
	callw read		# Read from disk
	lea 0x10(%bp),%sp	# Clear stack
	lret			# To far caller</pre></div></div><br class="figure-break" /><p>Note the long return instruction at the end of this block.
      This instruction pops out the <code class="literal">%cs</code> register
      pushed by <code class="literal">nread</code>, and returns.  Finally,
      <code class="literal">nread</code> also returns.</p><p>With the <acronym class="acronym">MBR</acronym> loaded to memory, the actual
      loop for searching the FreeBSD slice begins:</p><div class="figure"><a id="boot-boot1-find-part"></a><div class="figure-title">Figure 1.17. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">	mov $0x1,%cx		 # Two passes
main.1:
	mov $0x8dbe,%si # Partition table
	movb $0x1,%dh		 # Partition
main.2:
	cmpb $0xa5,0x4(%si)	 # Our partition type?
	jne main.3		 # No
	jcxz main.5		 # If second pass
	testb $0x80,(%si)	 # Active?
	jnz main.5		 # Yes
main.3:
	add $0x10,%si		 # Next entry
	incb %dh		 # Partition
	cmpb $0x5,%dh		 # In table?
	jb main.2		 # Yes
	dec %cx			 # Do two
	jcxz main.1		 #  passes</pre></div></div><br class="figure-break" /><p>If a FreeBSD slice is identified, execution continues at
      <code class="literal">main.5</code>.  Note that when a FreeBSD slice is found
      <code class="literal">%si</code> points to the appropriate entry in the
      partition table, and <code class="literal">%dh</code> holds the partition
      number.  We assume that a FreeBSD slice is found, so we continue
      execution at <code class="literal">main.5</code>:</p><div class="figure"><a id="boot-boot1-main5"></a><div class="figure-title">Figure 1.18. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">main.5:
	mov %dx,0x900			   # Save args
	movb $0x10,%dh			   # Sector count
	callw nread			   # Read disk
	mov $0x9000,%bx			   # BTX
	mov 0xa(%bx),%si		   # Get BTX length and set
	add %bx,%si			   #  %si to start of boot2.bin
	mov $0xc000,%di			   # Client page 2
	mov $0xa200,%cx			   # Byte
	sub %si,%cx			   #  count
	rep				   # Relocate
	movsb				   #  client</pre></div></div><br class="figure-break" /><p>Recall that at this point, register <code class="literal">%si</code>
      points to the FreeBSD slice entry in the <acronym class="acronym">MBR</acronym>
      partition table, so a call to <code class="literal">nread</code> will
      effectively read sectors at the beginning of this partition.
      The argument passed on register <code class="literal">%dh</code> tells
      <code class="literal">nread</code> to read 16 disk sectors.  Recall that
      the first 512 bytes, or the first sector of the FreeBSD slice,
      coincides with the <code class="filename">boot1</code> program.  Also
      recall that the file written to the beginning of the FreeBSD
      slice is not <code class="filename">/boot/boot1</code>, but
      <code class="filename">/boot/boot</code>.  Let us look at the size of
      these files in the filesystem:</p><a id="boot-boot1-filesize"></a><pre class="screen">-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0
-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1
-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2
-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot</pre><p>Both <code class="filename">boot0</code> and
      <code class="filename">boot1</code> are 512 bytes each, so they fit
      <span class="emphasis"><em>exactly</em></span> in one disk sector.
      <code class="filename">boot2</code> is much bigger, holding both
      the <acronym class="acronym">BTX</acronym> server and the
      <code class="filename">boot2</code> client.  Finally, a file called
      simply <code class="filename">boot</code> is 512 bytes larger than
      <code class="filename">boot2</code>.  This file is a
      concatenation of <code class="filename">boot1</code> and
      <code class="filename">boot2</code>.  As already noted,
      <code class="filename">boot0</code> is the file written to the absolute
      first disk sector (the <acronym class="acronym">MBR</acronym>), and
      <code class="filename">boot</code> is the file written to the first
      sector of the FreeBSD slice; <code class="filename">boot1</code> and
      <code class="filename">boot2</code> are <span class="emphasis"><em>not</em></span> written
      to disk.  The command used to concatenate
      <code class="filename">boot1</code> and <code class="filename">boot2</code> into a
      single <code class="filename">boot</code> is merely
      <code class="command">cat boot1 boot2 &gt; boot</code>.</p><p>So <code class="filename">boot1</code> occupies exactly the first 512
      bytes of <code class="filename">boot</code> and, because
      <code class="filename">boot</code> is written to the first sector of the
      FreeBSD slice, <code class="filename">boot1</code> fits exactly in this
      first sector.  Because <code class="literal">nread</code> reads the first
      16 sectors of the FreeBSD slice, it effectively reads the entire
      <code class="filename">boot</code> file
      <a href="#ftn.idp45818360" class="footnote" id="idp45818360"><sup class="footnote">[6]</sup></a>.
      We will see more details about how <code class="filename">boot</code> is
      formed from <code class="filename">boot1</code> and
      <code class="filename">boot2</code> in the next section.</p><p>Recall that <code class="literal">nread</code> uses memory address
      <code class="literal">0x8c00</code> as the transfer buffer to hold the
      sectors read.  This address is conveniently chosen.  Indeed,
      because <code class="filename">boot1</code> belongs to the first 512
      bytes, it ends up in the address range
      <code class="literal">0x8c00</code>-<code class="literal">0x8dff</code>.  The 512
      bytes that follows (range
      <code class="literal">0x8e00</code>-<code class="literal">0x8fff</code>) is used to
      store the <span class="emphasis"><em>bsdlabel</em></span>
      <a href="#ftn.idp45847928" class="footnote" id="idp45847928"><sup class="footnote">[7]</sup></a>.</p><p>Starting at address <code class="literal">0x9000</code> is the
      beginning of the <acronym class="acronym">BTX</acronym> server, and immediately
      following is the <code class="filename">boot2</code> client.  The
      <acronym class="acronym">BTX</acronym> server acts as a kernel, and executes in
      protected mode in the most privileged level.  In contrast, the
      <acronym class="acronym">BTX</acronym> clients (<code class="filename">boot2</code>, for
      example), execute in user mode.  We will see how this is
      accomplished in the next section.  The code after the call to
      <code class="literal">nread</code> locates the beginning of
      <code class="filename">boot2</code> in the memory buffer, and copies it
      to memory address <code class="literal">0xc000</code>.  This is because
      the <acronym class="acronym">BTX</acronym> server arranges
      <code class="filename">boot2</code> to execute in a segment starting at
      <code class="literal">0xa000</code>.  We explore this in detail in the
      following section.</p><p>The last code block of <code class="filename">boot1</code> enables
      access to memory above 1MB
      <a href="#ftn.idp45870328" class="footnote" id="idp45870328"><sup class="footnote">[8]</sup></a>
	and concludes with a jump to the starting point of the
      <acronym class="acronym">BTX</acronym> server:</p><div class="figure"><a id="boot-boot1-seta20"></a><div class="figure-title">Figure 1.19. <code class="filename">sys/boot/i386/boot2/boot1.S</code></div><div class="figure-contents"><pre class="programlisting">seta20:
	cli			# Disable interrupts
seta20.1:
	dec %cx			# Timeout?
	jz seta20.3		# Yes

	inb $0x64,%al		# Get status
	testb $0x2,%al		# Busy?
	jnz seta20.1		# Yes
	movb $0xd1,%al		# Command: Write
	outb %al,$0x64		#  output port
seta20.2:
	inb $0x64,%al		# Get status
	testb $0x2,%al		# Busy?
	jnz seta20.2		# Yes
	movb $0xdf,%al		# Enable
	outb %al,$0x60		#  A20
seta20.3:
	sti			# Enable interrupts
	jmp 0x9010		# Start BTX</pre></div></div><br class="figure-break" /><p>Note that right before the jump, interrupts are
      enabled.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="btx-server"></a>1.6. The <acronym class="acronym">BTX</acronym> Server</h2></div></div></div><p>Next in our boot sequence is the
      <acronym class="acronym">BTX</acronym> Server.  Let us quickly remember how we
      got here:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The <acronym class="acronym">BIOS</acronym> loads the absolute sector
	  one (the <acronym class="acronym">MBR</acronym>, or
	  <code class="filename">boot0</code>), to address
	  <code class="literal">0x7c00</code> and jumps there.</p></li><li class="listitem"><p><code class="filename">boot0</code> relocates itself to
	  <code class="literal">0x600</code>, the address it was linked to
	  execute, and jumps over there.  It then reads the first
	  sector of the FreeBSD slice (which consists of
	  <code class="filename">boot1</code>) into address
	  <code class="literal">0x7c00</code> and jumps over there.</p></li><li class="listitem"><p><code class="filename">boot1</code> loads the first 16 sectors
	  of the FreeBSD slice into address <code class="literal">0x8c00</code>.
	  This 16 sectors, or 8192 bytes, is the whole file
	  <code class="filename">boot</code>.  The file is a
	  concatenation of <code class="filename">boot1</code> and
	  <code class="filename">boot2</code>.  <code class="filename">boot2</code>, in
	  turn, contains the <acronym class="acronym">BTX</acronym> server and the
	  <code class="filename">boot2</code> client.  Finally, a jump is made
	  to address <code class="literal">0x9010</code>, the entry point of the
	  <acronym class="acronym">BTX</acronym> server.</p></li></ul></div><p>Before studying the <acronym class="acronym">BTX</acronym> Server in detail,
      let us further review how the single, all-in-one
      <code class="filename">boot</code> file is created.  The way
      <code class="filename">boot</code> is built is defined in its
      <code class="filename">Makefile</code>
      (<code class="filename">/usr/src/sys/boot/i386/boot2/Makefile</code>).
      Let us look at the rule that creates the
      <code class="filename">boot</code> file:</p><div class="figure"><a id="boot-boot1-make-boot"></a><div class="figure-title">Figure 1.20. <code class="filename">sys/boot/i386/boot2/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      boot: boot1 boot2
	cat boot1 boot2 &gt; boot</pre></div></div><br class="figure-break" /><p>This tells us that <code class="filename">boot1</code> and
      <code class="filename">boot2</code> are needed, and the rule simply
      concatenates them to produce a single file called
      <code class="filename">boot</code>.  The rules for creating
      <code class="filename">boot1</code> are also quite simple:</p><div class="figure"><a id="boot-boot1-make-boot1"></a><div class="figure-title">Figure 1.21. <code class="filename">sys/boot/i386/boot2/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      boot1: boot1.out
	objcopy -S -O binary boot1.out boot1

      boot1.out: boot1.o
	ld -e start -Ttext 0x7c00 -o boot1.out boot1.o</pre></div></div><br class="figure-break" /><p>To apply the rule for creating
      <code class="filename">boot1</code>, <code class="filename">boot1.out</code> must
      be resolved.  This, in turn, depends on the existence of
      <code class="filename">boot1.o</code>.  This last file is simply the
      result of assembling our familiar <code class="filename">boot1.S</code>,
      without linking.  Now, the rule for creating
      <code class="filename">boot1.out</code> is applied.  This tells us that
      <code class="filename">boot1.o</code> should be linked with
      <code class="literal">start</code> as its entry point, and starting at
      address <code class="literal">0x7c00</code>.  Finally,
      <code class="filename">boot1</code> is created from
      <code class="filename">boot1.out</code> applying the appropriate rule.
      This rule is the <code class="filename">objcopy</code> command applied to
      <code class="filename">boot1.out</code>.  Note the flags passed to
      <code class="filename">objcopy</code>: <code class="literal">-S</code> tells it to
      strip all relocation and symbolic information;
      <code class="literal">-O binary</code> indicates the output format, that
      is, a simple, unformatted binary file.</p><p>Having <code class="filename">boot1</code>, let us take a look at how
      <code class="filename">boot2</code> is constructed:</p><div class="figure"><a id="boot-boot1-make-boot2"></a><div class="figure-title">Figure 1.22. <code class="filename">sys/boot/i386/boot2/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      boot2: boot2.ld
	@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \
	    echo "$$x bytes available"; test $$x -ge 0
	dd if=boot2.ld of=boot2 obs=7680 conv=osync

      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx
	btxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \
	    -o boot2.ld -P 1 boot2.bin

      boot2.ldr:
	dd if=/dev/zero of=boot2.ldr bs=512 count=1

      boot2.bin: boot2.out
	objcopy -S -O binary boot2.out boot2.bin

      boot2.out: ../btx/lib/crt0.o boot2.o sio.o
	ld -Ttext 0x2000 -o boot2.out

      boot2.o: boot2.s
	${CC} ${ACFLAGS} -c boot2.s

      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c
	${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c
	sed -e '/align/d' -e '/nop/d' "MISSING" boot2.s.tmp &gt; boot2.s
	rm -f boot2.s.tmp

      boot2.h: boot1.out
	${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \
	    { x = $$1 - ORG1; \
	    printf("#define XREADORG %#x\n", REL1 + x) }' \
	    ORG1=`printf "%d" ${ORG1}` \
	    REL1=`printf "%d" ${REL1}` &gt; ${.TARGET}</pre></div></div><br class="figure-break" /><p>The mechanism for building <code class="filename">boot2</code> is
      far more elaborate.  Let us point out the most relevant facts.
      The dependency list is as follows:</p><div class="figure"><a id="boot-boot1-make-boot2-more"></a><div class="figure-title">Figure 1.23. <code class="filename">sys/boot/i386/boot2/Makefile</code></div><div class="figure-contents"><pre class="programlisting">      boot2: boot2.ld
      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx
      boot2.bin: boot2.out
      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o
      boot2.o: boot2.s
      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c
      boot2.h: boot1.out</pre></div></div><br class="figure-break" /><p>Note that initially there is no header file
      <code class="filename">boot2.h</code>, but its creation depends on
      <code class="filename">boot1.out</code>, which we already have.  The rule
      for its creation is a bit terse, but the important thing is that
      the output, <code class="filename">boot2.h</code>, is something like
      this:</p><div class="figure"><a id="boot-boot1-make-boot2h"></a><div class="figure-title">Figure 1.24. <code class="filename">sys/boot/i386/boot2/boot2.h</code></div><div class="figure-contents"><pre class="programlisting">#define XREADORG 0x725</pre></div></div><br class="figure-break" /><p>Recall that <code class="filename">boot1</code> was relocated (i.e.,
      copied from <code class="literal">0x7c00</code> to
      <code class="literal">0x700</code>).  This relocation will now make sense,
      because as we will see, the <acronym class="acronym">BTX</acronym> server
      reclaims some memory, including the space where
      <code class="filename">boot1</code> was originally loaded.  However, the
      <acronym class="acronym">BTX</acronym> server needs access to
      <code class="filename">boot1</code>'s <code class="literal">xread</code> function;
      this function, according to the output of
      <code class="filename">boot2.h</code>, is at location
      <code class="literal">0x725</code>.  Indeed, the
      <acronym class="acronym">BTX</acronym> server uses the
      <code class="literal">xread</code> function from
      <code class="filename">boot1</code>'s relocated code.  This function is
      now accessible from within the <code class="filename">boot2</code>
      client.</p><p>We next build <code class="filename">boot2.s</code> from files
      <code class="filename">boot2.h</code>, <code class="filename">boot2.c</code> and
      <code class="filename">/usr/src/sys/boot/common/ufsread.c</code>.  The
      rule for this is to compile the code in
      <code class="filename">boot2.c</code> (which includes
      <code class="filename">boot2.h</code> and <code class="filename">ufsread.c</code>)
      into assembly code.  Having <code class="filename">boot2.s</code>, the
      next rule assembles <code class="filename">boot2.s</code>, creating the
      object file <code class="filename">boot2.o</code>.  The
      next rule directs the linker to link various files
      (<code class="filename">crt0.o</code>,
      <code class="filename">boot2.o</code> and <code class="filename">sio.o</code>).
      Note that the output file, <code class="filename">boot2.out</code>, is
      linked to execute at address <code class="literal">0x2000</code>.  Recall
      that <code class="filename">boot2</code> will be executed in user mode,
      within a special user segment set up by the
      <acronym class="acronym">BTX</acronym> server.  This segment starts at
      <code class="literal">0xa000</code>.  Also, remember that the
      <code class="filename">boot2</code> portion of <code class="filename">boot</code>
      was copied to address <code class="literal">0xc000</code>, that is, offset
      <code class="literal">0x2000</code> from the start of the user segment, so
      <code class="filename">boot2</code> will work properly when we transfer
      control to it.  Next, <code class="filename">boot2.bin</code> is created
      from <code class="filename">boot2.out</code> by stripping its symbols and
      format information; boot2.bin is a <span class="emphasis"><em>raw</em></span>
      binary.  Now, note that a file <code class="filename">boot2.ldr</code> is
      created as a 512-byte file full of zeros.  This space is
      reserved for the bsdlabel.</p><p>Now that we have files <code class="filename">boot1</code>,
      <code class="filename">boot2.bin</code> and
      <code class="filename">boot2.ldr</code>, only the
      <acronym class="acronym">BTX</acronym> server is missing before creating the
      all-in-one <code class="filename">boot</code> file.  The
      <acronym class="acronym">BTX</acronym> server is located in
      <code class="filename">/usr/src/sys/boot/i386/btx/btx</code>; it has its
      own <code class="filename">Makefile</code> with its own set of rules for
      building.  The important thing to notice is that it is also
      compiled as a <span class="emphasis"><em>raw</em></span> binary, and that it is
      linked to execute at address <code class="literal">0x9000</code>.  The
      details can be found in
      <code class="filename">/usr/src/sys/boot/i386/btx/btx/Makefile</code>.</p><p>Having the files that comprise the <code class="filename">boot</code>
      program, the final step is to <span class="emphasis"><em>merge</em></span> them.
      This is done by a special program called
      <code class="filename">btxld</code> (source located in
      <code class="filename">/usr/src/usr.sbin/btxld</code>).  Some arguments
      to this program include the name of the output file
      (<code class="filename">boot</code>), its entry point
      (<code class="literal">0x2000</code>) and its file format
      (raw binary).  The various files are
      finally merged by this utility into the file
      <code class="filename">boot</code>, which consists of
      <code class="filename">boot1</code>, <code class="filename">boot2</code>, the
      <code class="literal">bsdlabel</code> and the
      <acronym class="acronym">BTX</acronym> server.  This file, which takes
      exactly 16 sectors, or 8192 bytes, is what is
      actually written to the beginning of the FreeBSD slice
      during installation.  Let us now proceed to study the
      <acronym class="acronym">BTX</acronym> server program.</p><p>The <acronym class="acronym">BTX</acronym> server prepares a simple
      environment and switches from 16-bit real mode to 32-bit
      protected mode, right before passing control to the client.
      This includes initializing and updating the following data
      structures:</p><a id="idp46093432" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Modifies the
	  <code class="literal">Interrupt Vector Table (IVT)</code>.  The
	  <acronym class="acronym">IVT</acronym> provides exception and interrupt
	  handlers for Real-Mode code.</p></li><li class="listitem"><p>The <code class="literal">Interrupt Descriptor Table (IDT)</code>
	  is created.  Entries are provided for processor exceptions,
	  hardware interrupts, two system calls and V86 interface.
	  The IDT provides exception and interrupt handlers for
	  Protected-Mode code.</p></li><li class="listitem"><p>A <code class="literal">Task-State Segment (TSS)</code> is
	  created.  This is necessary because the processor works in
	  the <span class="emphasis"><em>least</em></span> privileged level when
	  executing the client (<code class="filename">boot2</code>), but in
	  the <span class="emphasis"><em>most</em></span> privileged level when
	  executing the <acronym class="acronym">BTX</acronym> server.</p></li><li class="listitem"><p>The <acronym class="acronym">GDT</acronym> (Global Descriptor Table) is
	  set up.  Entries (descriptors) are provided for
	  supervisor code and data, user code and data, and real-mode
	  code and data.
	  <a href="#ftn.idp46109688" class="footnote" id="idp46109688"><sup class="footnote">[9]</sup></a></p></li></ul></div><p>Let us now start studying the actual implementation.  Recall
      that <code class="filename">boot1</code> made a jump to address
      <code class="literal">0x9010</code>, the <acronym class="acronym">BTX</acronym> server's
      entry point.  Before studying program execution there,
      note that the <acronym class="acronym">BTX</acronym> server has a special header
      at address range <code class="literal">0x9000-0x900f</code>, right before
      its entry point.  This header is defined as follows:</p><div class="figure"><a id="btx-header"></a><div class="figure-title">Figure 1.25. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">start:						# Start of code
/*
 * BTX header.
 */
btx_hdr:	.byte 0xeb			# Machine ID
		.byte 0xe			# Header size
		.ascii "BTX"			# Magic
		.byte 0x1			# Major version
		.byte 0x2			# Minor version
		.byte BTX_FLAGS			# Flags
		.word PAG_CNT-MEM_ORG&gt;&gt;0xc	# Paging control
		.word break-start		# Text size
		.long 0x0			# Entry address</pre></div></div><br class="figure-break" /><p>Note the first two bytes are <code class="literal">0xeb</code> and
      <code class="literal">0xe</code>.  In the IA-32 architecture, these two
      bytes are interpreted as a relative jump past the header into
      the entry point, so in theory, <code class="filename">boot1</code> could
      jump here (address <code class="literal">0x9000</code>) instead of address
      <code class="literal">0x9010</code>.  Note that the last field in the
      <acronym class="acronym">BTX</acronym> header is a pointer to the client's
      (<code class="filename">boot2</code>) entry point.  This field is patched
      at link time.</p><p>Immediately following the header is the
      <acronym class="acronym">BTX</acronym> server's entry point:</p><div class="figure"><a id="btx-init"></a><div class="figure-title">Figure 1.26. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Initialization routine.
 */
init:		cli				# Disable interrupts
		xor %ax,%ax			# Zero/segment
		mov %ax,%ss			# Set up
		mov $0x1800,%sp		#  stack
		mov %ax,%es			# Address
		mov %ax,%ds			#  data
		pushl $0x2			# Clear
		popfl				#  flags</pre></div></div><br class="figure-break" /><p>This code disables interrupts, sets up a working stack
      (starting at address <code class="literal">0x1800</code>) and clears the
      flags in the EFLAGS register.  Note that the
      <code class="literal">popfl</code> instruction pops out a doubleword (4
      bytes) from the stack and places it in the EFLAGS register.
      Because the value actually popped is <code class="literal">2</code>, the
      EFLAGS register is effectively cleared (IA-32 requires that bit
      2 of the EFLAGS register always be 1).</p><p>Our next code block clears (sets to <code class="literal">0</code>)
      the memory range <code class="literal">0x5e00-0x8fff</code>.  This range
      is where the various data structures will be created:</p><div class="figure"><a id="btx-clear-mem"></a><div class="figure-title">Figure 1.27. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Initialize memory.
 */
		mov $0x5e00,%di		# Memory to initialize
		mov $(0x9000-0x5e00)/2,%cx	# Words to zero
		rep				# Zero-fill
		stosw				#  memory</pre></div></div><br class="figure-break" /><p>Recall that <code class="filename">boot1</code> was originally loaded
      to address <code class="literal">0x7c00</code>, so, with this memory
      initialization, that copy effectively disappeared.  However,
      also recall that <code class="filename">boot1</code> was relocated to
      <code class="literal">0x700</code>, so <span class="emphasis"><em>that</em></span> copy is
      still in memory, and the <acronym class="acronym">BTX</acronym> server will make
      use of it.</p><p>Next, the real-mode <acronym class="acronym">IVT</acronym> (Interrupt Vector
      Table is updated.  The <acronym class="acronym">IVT</acronym> is an array of
      segment/offset pairs for exception and interrupt handlers.  The
      <acronym class="acronym">BIOS</acronym> normally maps hardware interrupts to
      interrupt vectors <code class="literal">0x8</code> to
      <code class="literal">0xf</code> and <code class="literal">0x70</code> to
      <code class="literal">0x77</code> but, as will be seen, the 8259A
      Programmable Interrupt Controller, the chip controlling the
      actual mapping of hardware interrupts to interrupt vectors, is
      programmed to remap these interrupt vectors from
      <code class="literal">0x8-0xf</code> to <code class="literal">0x20-0x27</code> and
      from <code class="literal">0x70-0x77</code> to
      <code class="literal">0x28-0x2f</code>.  Thus, interrupt handlers are
      provided for interrupt vectors <code class="literal">0x20-0x2f</code>.
      The reason the <acronym class="acronym">BIOS</acronym>-provided handlers are not
      used directly is because they work in 16-bit real mode, but not
      32-bit protected mode.  Processor mode will be switched to
      32-bit protected mode shortly.  However, the
      <acronym class="acronym">BTX</acronym> server sets up a mechanism to effectively
      use the handlers provided by the <acronym class="acronym">BIOS</acronym>:</p><div class="figure"><a id="btx-ivt"></a><div class="figure-title">Figure 1.28. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Update real mode IDT for reflecting hardware interrupts.
 */
		mov $intr20,%bx			# Address first handler
		mov $0x10,%cx			# Number of handlers
		mov $0x20*4,%di			# First real mode IDT entry
init.0:		mov %bx,(%di)			# Store IP
		inc %di				# Address next
		inc %di				#  entry
		stosw				# Store CS
		add $4,%bx			# Next handler
		loop init.0			# Next IRQ</pre></div></div><br class="figure-break" /><p>The next block creates the <acronym class="acronym">IDT</acronym> (Interrupt
      Descriptor Table).  The <acronym class="acronym">IDT</acronym> is analogous, in
      protected mode, to the <acronym class="acronym">IVT</acronym> in real mode.
      That is, the <acronym class="acronym">IDT</acronym> describes the various
      exception and interrupt handlers used when the processor is
      executing in protected mode.  In essence, it also consists of an
      array of segment/offset pairs, although the structure is
      somewhat more complex, because segments in protected mode are
      different than in real mode, and various protection mechanisms
      apply:</p><div class="figure"><a id="btx-idt"></a><div class="figure-title">Figure 1.29. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Create IDT.
 */
		mov $0x5e00,%di			# IDT's address
		mov $idtctl,%si			# Control string
init.1:		lodsb				# Get entry
		cbw				#  count
		xchg %ax,%cx			#  as word
		jcxz init.4			# If done
		lodsb				# Get segment
		xchg %ax,%dx			#  P:DPL:type
		lodsw				# Get control
		xchg %ax,%bx			#  set
		lodsw				# Get handler offset
		mov $SEL_SCODE,%dh		# Segment selector
init.2:		shr %bx				# Handle this int?
		jnc init.3			# No
		mov %ax,(%di)			# Set handler offset
		mov %dh,0x2(%di)		#  and selector
		mov %dl,0x5(%di)		# Set P:DPL:type
		add $0x4,%ax			# Next handler
init.3:		lea 0x8(%di),%di		# Next entry
		loop init.2			# Till set done
		jmp init.1			# Continue</pre></div></div><br class="figure-break" /><p>Each entry in the <code class="literal">IDT</code> is 8 bytes long.
      Besides the segment/offset information, they also describe the
      segment type, privilege level, and whether the segment is
      present in memory or not.  The construction is such that
      interrupt vectors from <code class="literal">0</code> to
      <code class="literal">0xf</code> (exceptions) are handled by function
      <code class="literal">intx00</code>; vector <code class="literal">0x10</code> (also
      an exception) is handled by <code class="literal">intx10</code>; hardware
      interrupts, which are later configured to start at interrupt
      vector <code class="literal">0x20</code> all the way to interrupt vector
      <code class="literal">0x2f</code>, are handled by function
      <code class="literal">intx20</code>.  Lastly, interrupt vector
      <code class="literal">0x30</code>, which is used for system calls, is
      handled by <code class="literal">intx30</code>, and vectors
      <code class="literal">0x31</code> and <code class="literal">0x32</code> are handled
      by <code class="literal">intx31</code>.  It must be noted that only
      descriptors for interrupt vectors <code class="literal">0x30</code>,
      <code class="literal">0x31</code> and <code class="literal">0x32</code> are given
      privilege level 3, the same privilege level as the
      <code class="filename">boot2</code> client, which means the client can
      execute a software-generated interrupt to this vectors through
      the <code class="literal">int</code> instruction without failing (this is
      the way <code class="filename">boot2</code> use the services provided by
      the <acronym class="acronym">BTX</acronym> server).  Also, note that
      <span class="emphasis"><em>only</em></span> software-generated interrupts are
      protected from code executing in lesser privilege levels.
      Hardware-generated interrupts and processor-generated exceptions
      are <span class="emphasis"><em>always</em></span> handled adequately, regardless
      of the actual privileges involved.</p><p>The next step is to initialize the <acronym class="acronym">TSS</acronym>
      (Task-State Segment).  The <acronym class="acronym">TSS</acronym> is a hardware
      feature that helps the operating system or executive software
      implement multitasking functionality through process
      abstraction.  The IA-32 architecture demands the creation and
      use of <span class="emphasis"><em>at least</em></span> one <acronym class="acronym">TSS</acronym>
      if multitasking facilities are used or different privilege
      levels are defined.  Because the <code class="filename">boot2</code>
      client is executed in privilege level 3, but the
      <acronym class="acronym">BTX</acronym> server does in privilege level 0, a
      <acronym class="acronym">TSS</acronym> must be defined:</p><div class="figure"><a id="btx-tss"></a><div class="figure-title">Figure 1.30. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Initialize TSS.
 */
init.4:		movb $_ESP0H,TSS_ESP0+1(%di)	# Set ESP0
		movb $SEL_SDATA,TSS_SS0(%di)	# Set SS0
		movb $_TSSIO,TSS_MAP(%di)	# Set I/O bit map base</pre></div></div><br class="figure-break" /><p>Note that a value is given for the Privilege Level 0 stack
      pointer and stack segment in the <acronym class="acronym">TSS</acronym>.  This
      is needed because, if an interrupt or exception is received
      while executing <code class="filename">boot2</code> in Privilege Level 3,
      a change to Privilege Level 0 is automatically performed by the
      processor, so a new working stack is needed.  Finally, the I/O
      Map Base Address field of the <acronym class="acronym">TSS</acronym> is given a
      value, which is a 16-bit offset from the beginning of the
      <acronym class="acronym">TSS</acronym> to the I/O Permission Bitmap and the
      Interrupt Redirection Bitmap.</p><p>After the <acronym class="acronym">IDT</acronym> and <acronym class="acronym">TSS</acronym>
      are created, the processor is ready to switch to protected mode.
      This is done in the next block:</p><div class="figure"><a id="btx-prot"></a><div class="figure-title">Figure 1.31. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Bring up the system.
 */
		mov $0x2820,%bx			# Set protected mode
		callw setpic			#  IRQ offsets
		lidt idtdesc			# Set IDT
		lgdt gdtdesc			# Set GDT
		mov %cr0,%eax			# Switch to protected
		inc %ax				#  mode
		mov %eax,%cr0			#
		ljmp $SEL_SCODE,$init.8		# To 32-bit code
		.code32
init.8:		xorl %ecx,%ecx			# Zero
		movb $SEL_SDATA,%cl		# To 32-bit
		movw %cx,%ss			#  stack</pre></div></div><br class="figure-break" /><p>First, a call is made to <code class="literal">setpic</code> to
      program the 8259A <acronym class="acronym">PIC</acronym> (Programmable Interrupt
      Controller).  This chip is connected to multiple hardware
      interrupt sources.  Upon receiving an interrupt from a device,
      it signals the processor with the appropriate interrupt vector.
      This can be customized so that specific interrupts are
      associated with specific interrupt vectors, as explained before.
      Next, the <acronym class="acronym">IDTR</acronym> (Interrupt Descriptor Table
      Register) and <acronym class="acronym">GDTR</acronym> (Global Descriptor Table
      Register) are loaded with the instructions
      <code class="literal">lidt</code> and <code class="literal">lgdt</code>,
      respectively.  These registers are loaded with the base address
      and limit address for the <acronym class="acronym">IDT</acronym> and
      <acronym class="acronym">GDT</acronym>.  The following three instructions set
      the Protection Enable (PE) bit of the <code class="literal">%cr0</code>
      register.  This effectively switches the processor to 32-bit
      protected mode.  Next, a long jump is made to
      <code class="literal">init.8</code> using segment selector SEL_SCODE,
      which selects the Supervisor Code Segment.  The processor is
      effectively executing in CPL 0, the most privileged level, after
      this jump.  Finally, the Supervisor Data Segment is selected for
      the stack by assigning the segment selector SEL_SDATA to the
      <code class="literal">%ss</code> register.  This data segment also has a
      privilege level of <code class="literal">0</code>.</p><p>Our last code block is responsible for loading the
      <acronym class="acronym">TR</acronym> (Task Register) with the segment selector
      for the <acronym class="acronym">TSS</acronym> we created earlier, and setting
      the User Mode environment before passing execution control to
      the <code class="filename">boot2</code> client.</p><div class="figure"><a id="btx-end"></a><div class="figure-title">Figure 1.32. <code class="filename">sys/boot/i386/btx/btx/btx.S</code></div><div class="figure-contents"><pre class="programlisting">/*
 * Launch user task.
 */
		movb $SEL_TSS,%cl		# Set task
		ltr %cx				#  register
		movl $0xa000,%edx		# User base address
		movzwl %ss:BDA_MEM,%eax		# Get free memory
		shll $0xa,%eax			# To bytes
		subl $ARGSPACE,%eax		# Less arg space
		subl %edx,%eax			# Less base
		movb $SEL_UDATA,%cl		# User data selector
		pushl %ecx			# Set SS
		pushl %eax			# Set ESP
		push $0x202			# Set flags (IF set)
		push $SEL_UCODE			# Set CS
		pushl btx_hdr+0xc		# Set EIP
		pushl %ecx			# Set GS
		pushl %ecx			# Set FS
		pushl %ecx			# Set DS
		pushl %ecx			# Set ES
		pushl %edx			# Set EAX
		movb $0x7,%cl			# Set remaining
init.9:		push $0x0			#  general
		loop init.9			#  registers
		popa				#  and initialize
		popl %es			# Initialize
		popl %ds			#  user
		popl %fs			#  segment
		popl %gs			#  registers
		iret				# To user mode</pre></div></div><br class="figure-break" /><p>Note that the client's environment include a stack segment
      selector and stack pointer (registers <code class="literal">%ss</code> and
      <code class="literal">%esp</code>).  Indeed, once the
      <acronym class="acronym">TR</acronym> is loaded with the appropriate stack
      segment selector (instruction <code class="literal">ltr</code>), the stack
      pointer is calculated and pushed onto the stack along with the
      stack's segment selector.  Next, the value
      <code class="literal">0x202</code> is pushed onto the stack; it is the
      value that the EFLAGS will get when control is passed to the
      client.  Also, the User Mode code segment selector and the
      client's entry point are pushed.  Recall that this entry
      point is patched in the <acronym class="acronym">BTX</acronym> header at link
      time.  Finally, segment selectors (stored in register
      <code class="literal">%ecx</code>) for the segment registers
      <code class="literal">%gs, %fs, %ds and %es</code> are pushed onto the
      stack, along with the value at <code class="literal">%edx</code>
      (<code class="literal">0xa000</code>).  Keep in mind the various values
      that have been pushed onto the stack (they will be popped out
      shortly).  Next, values for the remaining general purpose
      registers are also pushed onto the stack (note the
      <code class="literal">loop</code> that pushes the value
      <code class="literal">0</code> seven times).  Now, values will be started
      to be popped out of the stack.  First, the
      <code class="literal">popa</code> instruction pops out of the stack the
      latest seven values pushed.  They are stored in the general
      purpose registers in order
      <code class="literal">%edi, %esi, %ebp, %ebx, %edx, %ecx, %eax</code>.
      Then, the various segment selectors pushed are popped into the
      various segment registers.  Five values still remain on the
      stack.  They are popped when the <code class="literal">iret</code>
      instruction is executed.  This instruction first pops
      the value that was pushed from the <acronym class="acronym">BTX</acronym>
      header.  This value is a pointer to <code class="filename">boot2</code>'s
      entry point.  It is placed in the register
      <code class="literal">%eip</code>, the instruction pointer register.
      Next, the segment selector for the User Code Segment is popped
      and copied to register <code class="literal">%cs</code>.  Remember that
      this segment's privilege level is 3, the least privileged
      level.  This means that we must provide values for the stack of
      this privilege level.  This is why the processor, besides
      further popping the value for the EFLAGS register, does two more
      pops out of the stack.  These values go to the stack
      pointer (<code class="literal">%esp</code>) and the stack segment
      (<code class="literal">%ss</code>).  Now, execution continues at
      <code class="literal">boot0</code>'s entry point.</p><p>It is important to note how the User Code Segment is
      defined.  This segment's <span class="emphasis"><em>base address</em></span> is
      set to <code class="literal">0xa000</code>.  This means that code memory
      addresses are <span class="emphasis"><em>relative</em></span> to address 0xa000;
      if code being executed is fetched from address
      <code class="literal">0x2000</code>, the <span class="emphasis"><em>actual</em></span>
      memory addressed is
      <code class="literal">0xa000+0x2000=0xc000</code>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot2"></a>1.7. <span class="application">boot2</span> Stage</h2></div></div></div><p><code class="literal">boot2</code> defines an important structure,
      <code class="literal">struct bootinfo</code>.  This structure is
      initialized by <code class="literal">boot2</code> and passed to the
      loader, and then further to the kernel.  Some nodes of this
      structures are set by <code class="literal">boot2</code>, the rest by the
      loader.  This structure, among other information, contains the
      kernel filename, <acronym class="acronym">BIOS</acronym> harddisk geometry,
      <acronym class="acronym">BIOS</acronym> drive number for boot device, physical
      memory available, <code class="literal">envp</code> pointer etc.  The
      definition for it is:</p><pre class="programlisting"><code class="filename">/usr/include/machine/bootinfo.h:</code>
struct bootinfo {
	u_int32_t	bi_version;
	u_int32_t	bi_kernelname;		/* represents a char * */
	u_int32_t	bi_nfs_diskless;	/* struct nfs_diskless * */
				/* End of fields that are always present. */
#define	bi_endcommon	bi_n_bios_used
	u_int32_t	bi_n_bios_used;
	u_int32_t	bi_bios_geom[N_BIOS_GEOM];
	u_int32_t	bi_size;
	u_int8_t	bi_memsizes_valid;
	u_int8_t	bi_bios_dev;		/* bootdev BIOS unit number */
	u_int8_t	bi_pad[2];
	u_int32_t	bi_basemem;
	u_int32_t	bi_extmem;
	u_int32_t	bi_symtab;		/* struct symtab * */
	u_int32_t	bi_esymtab;		/* struct symtab * */
				/* Items below only from advanced bootloader */
	u_int32_t	bi_kernend;		/* end of kernel space */
	u_int32_t	bi_envp;		/* environment */
	u_int32_t	bi_modulep;		/* preloaded modules */
};</pre><p><code class="literal">boot2</code> enters into an infinite loop
      waiting for user input, then calls <code class="function">load()</code>.
      If the user does not press anything, the loop breaks by a
      timeout, so <code class="function">load()</code> will load the default
      file (<code class="filename">/boot/loader</code>).  Functions
      <code class="function">ino_t lookup(char *filename)</code> and
      <code class="function">int xfsread(ino_t inode, void *buf, size_t
      nbyte)</code> are used to read the content of a file into
      memory.  <code class="filename">/boot/loader</code> is an
      <acronym class="acronym">ELF</acronym> binary, but where the
      <acronym class="acronym">ELF</acronym> header is prepended with
      <code class="filename">a.out</code>'s <code class="literal">struct
      exec</code> structure.  <code class="function">load()</code> scans the
      loader's ELF header, loading the content of
      <code class="filename">/boot/loader</code> into memory, and passing the
      execution to the loader's entry:</p><pre class="programlisting"><code class="filename">sys/boot/i386/boot2/boot2.c:</code>
    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),
	   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),
	   0, 0, 0, VTOP(&amp;bootinfo));</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-loader"></a>1.8. <span class="application">loader</span> Stage</h2></div></div></div><p><span class="application">loader</span> is a
      <acronym class="acronym">BTX</acronym> client as well.  I will not describe it
      here in detail, there is a comprehensive man page written by
      Mike Smith, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">loader</span>(8)</span></a>.  The underlying mechanisms and
      <acronym class="acronym">BTX</acronym> were discussed above.</p><p>The main task for the loader is to boot the kernel.  When
      the kernel is loaded into memory, it is being called by the
      loader:</p><pre class="programlisting"><code class="filename">sys/boot/common/boot.c:</code>
    /* Call the exec handler from the loader matching the kernel */
    module_formats[km-&gt;m_loader]-&gt;l_exec(km);</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-kernel"></a>1.9. Kernel Initialization</h2></div></div></div><p>Let us take a look at the command that links the kernel.
      This will help identify the exact location where the loader
      passes execution to the kernel.  This location is the kernel's
      actual entry point.</p><pre class="programlisting"><code class="filename">sys/conf/Makefile.i386:</code>
ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \
-dynamic-linker /red/herring -o kernel -X locore.o \
&lt;lots of kernel .o files&gt;</pre><a id="idp46392184" class="indexterm"></a><p>A few interesting things can be seen here.  First, the
      kernel is an ELF dynamically linked binary, but the dynamic
      linker for kernel is <code class="filename">/red/herring</code>, which is
      definitely a bogus file.  Second, taking a look at the file
      <code class="filename">sys/conf/ldscript.i386</code> gives an idea about
      what <span class="application">ld</span> options are used when
      compiling a kernel.  Reading through the first few lines, the
      string</p><pre class="programlisting"><code class="filename">sys/conf/ldscript.i386:</code>
ENTRY(btext)</pre><p>says that a kernel's entry point is the symbol `btext'.
      This symbol is defined in <code class="filename">locore.s</code>:</p><pre class="programlisting"><code class="filename">sys/i386/i386/locore.s:</code>
	.text
/**********************************************************************
 *
 * This is where the bootblocks start us, set the ball rolling...
 *
 */
NON_GPROF_ENTRY(btext)</pre><p>First, the register EFLAGS is set to a predefined value of
      0x00000002.  Then all the segment registers are
      initialized:</p><pre class="programlisting"><code class="filename">sys/i386/i386/locore.s:</code>
/* Don't trust what the BIOS gives for eflags. */
	pushl	$PSL_KERNEL
	popfl

/*
 * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap
 * to set %cs, %ds, %es and %ss.
 */
	mov	%ds, %ax
	mov	%ax, %fs
	mov	%ax, %gs</pre><p>btext calls the routines
      <code class="function">recover_bootinfo()</code>,
      <code class="function">identify_cpu()</code>,
      <code class="function">create_pagetables()</code>, which are also defined
      in <code class="filename">locore.s</code>.  Here is a description of what
      they do:</p><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td align="left"><code class="function">recover_bootinfo</code></td><td align="left">This routine parses the parameters to the kernel
	      passed from the bootstrap.  The kernel may have been
	      booted in 3 ways: by the loader, described above, by the
	      old disk boot blocks, or by the old diskless boot
	      procedure.  This function determines the booting method,
	      and stores the <code class="literal">struct bootinfo</code>
	      structure into the kernel memory.</td></tr><tr><td align="left"><code class="function">identify_cpu</code></td><td align="left">This functions tries to find out what CPU it is
	      running on, storing the value found in a variable
	      <code class="varname">_cpu</code>.</td></tr><tr><td align="left"><code class="function">create_pagetables</code></td><td align="left">This function allocates and fills out a Page Table
	      Directory at the top of the kernel memory area.</td></tr></tbody></table></div><p>The next steps are enabling VME, if the CPU supports
      it:</p><pre class="programlisting">	testl	$CPUID_VME, R(_cpu_feature)
	jz	1f
	movl	%cr4, %eax
	orl	$CR4_VME, %eax
	movl	%eax, %cr4</pre><p>Then, enabling paging:</p><pre class="programlisting">/* Now enable paging */
	movl	R(_IdlePTD), %eax
	movl	%eax,%cr3			/* load ptd addr into mmu */
	movl	%cr0,%eax			/* get control word */
	orl	$CR0_PE|CR0_PG,%eax		/* enable paging */
	movl	%eax,%cr0			/* and let's page NOW! */</pre><p>The next three lines of code are because the paging was set,
      so the jump is needed to continue the execution in virtualized
      address space:</p><pre class="programlisting">	pushl	$begin				/* jump to high virtualized address */
	ret

/* now running relocated at KERNBASE where the system is linked to run */
begin:</pre><p>The function <code class="function">init386()</code> is called with
      a pointer to the first free physical page, after that
      <code class="function">mi_startup()</code>.  <code class="function">init386</code>
      is an architecture dependent initialization function, and
      <code class="function">mi_startup()</code> is an architecture independent
      one (the 'mi_' prefix stands for Machine Independent).  The
      kernel never returns from <code class="function">mi_startup()</code>, and
      by calling it, the kernel finishes booting:</p><pre class="programlisting"><code class="filename">sys/i386/i386/locore.s:</code>
	movl	physfree, %esi
	pushl	%esi				/* value of first for init386(first) */
	call	_init386			/* wire 386 chip for unix operation */
	call	_mi_startup			/* autoconfiguration, mountroot etc */
	hlt		/* never returns to here */</pre><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp46451320"></a>1.9.1. <code class="function">init386()</code></h3></div></div></div><p><code class="function">init386()</code> is defined in
	<code class="filename">sys/i386/i386/machdep.c</code> and performs
	low-level initialization specific to the i386 chip.  The
	switch to protected mode was performed by the loader.  The
	loader has created the very first task, in which the kernel
	continues to operate.  Before looking at the code, consider
	the tasks the processor must complete to initialize protected
	mode execution:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Initialize the kernel tunable parameters, passed from
	    the bootstrapping program.</p></li><li class="listitem"><p>Prepare the GDT.</p></li><li class="listitem"><p>Prepare the IDT.</p></li><li class="listitem"><p>Initialize the system console.</p></li><li class="listitem"><p>Initialize the DDB, if it is compiled into
	    kernel.</p></li><li class="listitem"><p>Initialize the TSS.</p></li><li class="listitem"><p>Prepare the LDT.</p></li><li class="listitem"><p>Set up proc0's pcb.</p></li></ul></div><a id="idp49044856" class="indexterm"></a><p><code class="function">init386()</code> initializes the tunable
	parameters passed from bootstrap by setting the environment
	pointer (envp) and calling <code class="function">init_param1()</code>.
	The envp pointer has been passed from loader in the
	<code class="literal">bootinfo</code> structure:</p><pre class="programlisting"><code class="filename">sys/i386/i386/machdep.c:</code>
		kern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;

	/* Init basic tunables, hz etc */
	init_param1();</pre><p><code class="function">init_param1()</code> is defined in
	<code class="filename">sys/kern/subr_param.c</code>.  That file has a
	number of sysctls, and two functions,
	<code class="function">init_param1()</code> and
	<code class="function">init_param2()</code>, that are called from
	<code class="function">init386()</code>:</p><pre class="programlisting"><code class="filename">sys/kern/subr_param.c:</code>
	hz = HZ;
	TUNABLE_INT_FETCH("kern.hz", &amp;hz);</pre><p>TUNABLE_&lt;typename&gt;_FETCH is used to fetch the value
	from the environment:</p><pre class="programlisting"><code class="filename">/usr/src/sys/sys/kernel.h:</code>
#define	TUNABLE_INT_FETCH(path, var)	getenv_int((path), (var))</pre><p>Sysctl <code class="literal">kern.hz</code> is the system clock
	tick.  Additionally, these sysctls are set by
	<code class="function">init_param1()</code>: <code class="literal">kern.maxswzone,
	kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz,
	  kern.dflssiz, kern.maxssiz, kern.sgrowsiz</code>.</p><a id="idp49053048" class="indexterm"></a><p>Then <code class="function">init386()</code> prepares the Global
	Descriptors Table (GDT).  Every task on an x86 is running in
	its own virtual address space, and this space is addressed by
	a segment:offset pair.  Say, for instance, the current
	instruction to be executed by the processor lies at CS:EIP,
	then the linear virtual address for that instruction would be
	<span class="quote">&#8220;<span class="quote">the virtual address of code segment CS</span>&#8221;</span> + EIP.
	For convenience, segments begin at virtual address 0 and end
	at a 4Gb boundary.  Therefore, the instruction's linear
	virtual address for this example would just be the value of
	EIP. Segment registers such as CS, DS etc are the selectors,
	i.e., indexes, into GDT (to be more precise, an index is not a
	selector itself, but the INDEX field of a selector).
	FreeBSD's GDT holds descriptors for 15 selectors per
	CPU:</p><pre class="programlisting"><code class="filename">sys/i386/i386/machdep.c:</code>
union descriptor gdt[NGDT * MAXCPU];	/* global descriptor table */

<code class="filename">sys/i386/include/segments.h:</code>
/*
 * Entries in the Global Descriptor Table (GDT)
 */
#define	GNULL_SEL	0	/* Null Descriptor */
#define	GCODE_SEL	1	/* Kernel Code Descriptor */
#define	GDATA_SEL	2	/* Kernel Data Descriptor */
#define	GPRIV_SEL	3	/* SMP Per-Processor Private Data */
#define	GPROC0_SEL	4	/* Task state process slot zero and up */
#define	GLDT_SEL	5	/* LDT - eventually one per process */
#define	GUSERLDT_SEL	6	/* User LDT */
#define	GTGATE_SEL	7	/* Process task switch gate */
#define	GBIOSLOWMEM_SEL	8	/* BIOS low memory access (must be entry 8) */
#define	GPANIC_SEL	9	/* Task state to consider panic from */
#define GBIOSCODE32_SEL	10	/* BIOS interface (32bit Code) */
#define GBIOSCODE16_SEL	11	/* BIOS interface (16bit Code) */
#define GBIOSDATA_SEL	12	/* BIOS interface (Data) */
#define GBIOSUTIL_SEL	13	/* BIOS interface (Utility) */
#define GBIOSARGS_SEL	14	/* BIOS interface (Arguments) */</pre><p>Note that those #defines are not selectors themselves, but
	just a field INDEX of a selector, so they are exactly the
	indices of the GDT.  for example, an actual selector for the
	kernel code (GCODE_SEL) has the value 0x08.</p><a id="idp49056376" class="indexterm"></a><p>The next step is to initialize the Interrupt Descriptor
	Table (IDT).  This table is referenced by the processor when a
	software or hardware interrupt occurs.  For example, to make a
	system call, user application issues the
	<code class="literal">INT 0x80</code> instruction.  This is a software
	interrupt, so the processor's hardware looks up a record with
	index 0x80 in the IDT.  This record points to the routine that
	handles this interrupt, in this particular case, this will be
	the kernel's syscall gate.  The IDT may have a maximum of 256
	(0x100) records.  The kernel allocates NIDT records for the
	IDT, where NIDT is the maximum (256):</p><pre class="programlisting"><code class="filename">sys/i386/i386/machdep.c:</code>
static struct gate_descriptor idt0[NIDT];
struct gate_descriptor *idt = &amp;idt0[0];	/* interrupt descriptor table */</pre><p>For each interrupt, an appropriate handler is set.  The
	syscall gate for <code class="literal">INT 0x80</code> is set as
	well:</p><pre class="programlisting"><code class="filename">sys/i386/i386/machdep.c:</code>
	setidt(0x80, &amp;IDTVEC(int0x80_syscall),
			SDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));</pre><p>So when a userland application issues the
	<code class="literal">INT 0x80</code> instruction, control will transfer
	to the function <code class="function">_Xint0x80_syscall</code>, which
	is in the kernel code segment and will be executed with
	supervisor privileges.</p><p>Console and DDB are then initialized:</p><a id="idp49077624" class="indexterm"></a><pre class="programlisting"><code class="filename">sys/i386/i386/machdep.c:</code>
	cninit();
/* skipped */
#ifdef DDB
	kdb_init();
	if (boothowto &amp; RB_KDB)
		Debugger("Boot flags requested debugger");
#endif</pre><p>The Task State Segment is another x86 protected mode
	structure, the TSS is used by the hardware to store task
	information when a task switch occurs.</p><p>The Local Descriptors Table is used to reference userland
	code and data.  Several selectors are defined to point to the
	LDT, they are the system call gates and the user code and data
	selectors:</p><pre class="programlisting"><code class="filename">/usr/include/machine/segments.h:</code>
#define	LSYS5CALLS_SEL	0	/* forced by intel BCS */
#define	LSYS5SIGR_SEL	1
#define	L43BSDCALLS_SEL	2	/* notyet */
#define	LUCODE_SEL	3
#define	LSOL26CALLS_SEL	4	/* Solaris &gt;= 2.6 system call gate */
#define	LUDATA_SEL	5
/* separate stack, es,fs,gs sels ? */
/* #define	LPOSIXCALLS_SEL	5*/	/* notyet */
#define LBSDICALLS_SEL	16	/* BSDI system call gate */
#define NLDT		(LBSDICALLS_SEL + 1)</pre><p>Next, proc0's Process Control Block
	(<code class="literal">struct pcb</code>) structure is initialized.
	proc0 is a <code class="literal">struct proc</code> structure that
	describes a kernel process.  It is always present while the
	kernel is running, therefore it is declared as global:</p><pre class="programlisting"><code class="filename">sys/kern/kern_init.c:</code>
    struct	proc proc0;</pre><p>The structure <code class="literal">struct pcb</code> is a part of a
	proc structure.  It is defined in
	<code class="filename">/usr/include/machine/pcb.h</code> and has a
	process's information specific to the i386 architecture, such
	as registers values.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49083256"></a>1.9.2. <code class="function">mi_startup()</code></h3></div></div></div><p>This function performs a bubble sort of all the system
	initialization objects and then calls the entry of each object
	one by one:</p><pre class="programlisting"><code class="filename">sys/kern/init_main.c:</code>
	for (sipp = sysinit; *sipp; sipp++) {

		/* ... skipped ... */

		/* Call function */
		(*((*sipp)-&gt;func))((*sipp)-&gt;udata);
		/* ... skipped ... */
	}</pre><p>Although the sysinit framework is described in the <a class="link" href="../../../../doc/en_US.ISO8859-1/books/developers-handbook" target="_top">Developers'
	  Handbook</a>, I will discuss the internals of it.</p><a id="idp49085944" class="indexterm"></a><p>Every system initialization object (sysinit object) is
	created by calling a SYSINIT() macro.  Let us take as example
	an <code class="literal">announce</code> sysinit object.  This object
	prints the copyright message:</p><pre class="programlisting"><code class="filename">sys/kern/init_main.c:</code>
static void
print_caddr_t(void *data __unused)
{
	printf("%s", (char *)data);
}
SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)</pre><p>The subsystem ID for this object is SI_SUB_COPYRIGHT
	(0x0800001), which comes right after the SI_SUB_CONSOLE
	(0x0800000).  So, the copyright message will be printed out
	first, just after the console initialization.</p><p>Let us take a look at what exactly the macro
	<code class="literal">SYSINIT()</code> does.  It expands to a
	<code class="literal">C_SYSINIT()</code> macro.  The
	<code class="literal">C_SYSINIT()</code> macro then expands to a static
	<code class="literal">struct sysinit</code> structure declaration with
	another <code class="literal">DATA_SET</code> macro call:</p><pre class="programlisting"><code class="filename">/usr/include/sys/kernel.h:</code>
      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \
      static struct sysinit uniquifier ## _sys_init = { \ subsystem, \
      order, \ func, \ ident \ }; \ DATA_SET(sysinit_set,uniquifier ##
      _sys_init);

#define	SYSINIT(uniquifier, subsystem, order, func, ident)	\
	C_SYSINIT(uniquifier, subsystem, order,			\
	(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)</pre><p>The <code class="literal">DATA_SET()</code> macro expands to a
	<code class="literal">MAKE_SET()</code>, and that macro is the point
	where all the sysinit magic is hidden:</p><pre class="programlisting"><code class="filename">/usr/include/linker_set.h:</code>
#define MAKE_SET(set, sym)						\
	static void const * const __set_##set##_sym_##sym = &amp;sym;	\
	__asm(".section .set." #set ",\"aw\"");				\
	__asm(".long " #sym);						\
	__asm(".previous")
#endif
#define TEXT_SET(set, sym) MAKE_SET(set, sym)
#define DATA_SET(set, sym) MAKE_SET(set, sym)</pre><p>In our case, the following declaration will occur:</p><pre class="programlisting">static struct sysinit announce_sys_init = {
	SI_SUB_COPYRIGHT,
	SI_ORDER_FIRST,
	(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,
	(void *) copyright
};

static void const *const __set_sysinit_set_sym_announce_sys_init =
    &amp;announce_sys_init;
__asm(".section .set.sysinit_set" ",\"aw\"");
__asm(".long " "announce_sys_init");
__asm(".previous");</pre><p>The first <code class="literal">__asm</code> instruction will create
	an ELF section within the kernel's executable.  This will
	happen at kernel link time.  The section will have the name
	<code class="literal">.set.sysinit_set</code>.  The content of this
	section is one 32-bit value, the address of announce_sys_init
	structure, and that is what the second
	<code class="literal">__asm</code> is.  The third
	<code class="literal">__asm</code> instruction marks the end of a
	section.  If a directive with the same section name occurred
	before, the content, i.e., the 32-bit value, will be appended
	to the existing section, so forming an array of 32-bit
	pointers.</p><p>Running <span class="application">objdump</span> on a kernel
	binary, you may notice the presence of such small
	sections:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>objdump -h /kernel</code></strong>
  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2
                  CONTENTS, ALLOC, LOAD, DATA</pre><p>This screen dump shows that the size of .set.sysinit_set
	section is 0x664 bytes, so <code class="literal">0x664/sizeof(void
	*)</code> sysinit objects are compiled into the kernel.
	The other sections such as <code class="literal">.set.sysctl_set</code>
	represent other linker sets.</p><p>By defining a variable of type <code class="literal">struct
	  linker_set</code> the content of
	<code class="literal">.set.sysinit_set</code> section will be
	<span class="quote">&#8220;<span class="quote">collected</span>&#8221;</span> into that variable:</p><pre class="programlisting"><code class="filename">sys/kern/init_main.c:</code>
      extern struct linker_set sysinit_set; /* XXX */</pre><p>The <code class="literal">struct linker_set</code> is defined as
	follows:</p><pre class="programlisting"><code class="filename">/usr/include/linker_set.h:</code>
  struct linker_set {
	int	ls_length;
	void	*ls_items[1];		/* really ls_length of them, trailing NULL */
};</pre><p>The first node will be equal to the number of a sysinit
	objects, and the second node will be a NULL-terminated array
	of pointers to them.</p><p>Returning to the <code class="function">mi_startup()</code>
	discussion, it is must be clear now, how the sysinit objects
	are being organized.  The <code class="function">mi_startup()</code>
	function sorts them and calls each.  The very last object is
	the system scheduler:</p><pre class="programlisting"><code class="filename">/usr/include/sys/kernel.h:</code>
enum sysinit_sub_id {
	SI_SUB_DUMMY		= 0x0000000,	/* not executed; for linker*/
	SI_SUB_DONE		= 0x0000001,	/* processed*/
	SI_SUB_CONSOLE		= 0x0800000,	/* console*/
	SI_SUB_COPYRIGHT	= 0x0800001,	/* first use of console*/
...
	SI_SUB_RUN_SCHEDULER	= 0xfffffff	/* scheduler: no return*/
};</pre><p>The system scheduler sysinit object is defined in the file
	<code class="filename">sys/vm/vm_glue.c</code>, and the entry point for
	that object is <code class="function">scheduler()</code>.  That
	function is actually an infinite loop, and it represents a
	process with PID 0, the swapper process.  The proc0 structure,
	mentioned before, is used to describe it.</p><p>The first user process, called <span class="emphasis"><em>init</em></span>,
	is created by the sysinit object
	<code class="literal">init</code>:</p><pre class="programlisting"><code class="filename">sys/kern/init_main.c:</code>
static void
create_init(const void *udata __unused)
{
	int error;
	int s;

	s = splhigh();
	error = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);
	if (error)
		panic("cannot fork init: %d\n", error);
	initproc-&gt;p_flag |= P_INMEM | P_SYSTEM;
	cpu_set_fork_handler(initproc, start_init, NULL);
	remrunqueue(initproc);
	splx(s);
}
SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)</pre><p>The <code class="function">create_init()</code> allocates a new
	process by calling <code class="function">fork1()</code>, but does not
	mark it runnable.  When this new process is scheduled for
	execution by the scheduler, the
	<code class="function">start_init()</code> will be called.  That
	function is defined in <code class="filename">init_main.c</code>.  It
	tries to load and exec the <code class="filename">init</code> binary,
	probing <code class="filename">/sbin/init</code> first, then
	<code class="filename">/sbin/oinit</code>,
	<code class="filename">/sbin/init.bak</code>, and finally
	<code class="filename">/stand/sysinstall</code>:</p><pre class="programlisting"><code class="filename">sys/kern/init_main.c:</code>
static char init_path[MAXPATHLEN] =
#ifdef	INIT_PATH
    __XSTRING(INIT_PATH);
#else
    "/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall";
#endif</pre></div></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp45185272" class="footnote"><p><a href="#idp45185272" class="para"><sup class="para">[1] </sup></a><a class="link" href="http://en.wikipedia.org/wiki/Master_boot_record" target="_top">http://en.wikipedia.org/wiki/Master_boot_record</a></p></div><div id="ftn.idp45318520" class="footnote"><p><a href="#idp45318520" class="para"><sup class="para">[2] </sup></a>When in doubt, we refer the reader to the official Intel
	  manuals, which describe the exact semantics for each
	  instruction: <a class="link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_top">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a>.</p></div><div id="ftn.idp45579000" class="footnote"><p><a href="#idp45579000" class="para"><sup class="para">[3] </sup></a>There is a file <code class="filename">/boot/boot1</code>, but it
	  is not the written to the beginning of the FreeBSD slice.
	  Instead, it is concatenated with <code class="filename">boot2</code>
	  to form <code class="filename">boot</code>, which
	  <span class="emphasis"><em>is</em></span> written to the beginning of the FreeBSD
	  slice and read at boot time.</p></div><div id="ftn.idp45644280" class="footnote"><p><a href="#idp45644280" class="para"><sup class="para">[4] </sup></a>Actually we did pass a pointer to the slice entry in
	  register <code class="literal">%si</code>.  However,
	  <code class="filename">boot1</code> does not assume that it was
	  loaded by <code class="filename">boot0</code> (perhaps some other
	  <acronym class="acronym">MBR</acronym> loaded it, and did not pass this
	  information), so it assumes nothing.</p></div><div id="ftn.idp45697400" class="footnote"><p><a href="#idp45697400" class="para"><sup class="para">[5] </sup></a>In the context of 16-bit real mode, a word is 2
	  bytes.</p></div><div id="ftn.idp45818360" class="footnote"><p><a href="#idp45818360" class="para"><sup class="para">[6] </sup></a>512*16=8192 bytes, exactly the size of
	  <code class="filename">boot</code></p></div><div id="ftn.idp45847928" class="footnote"><p><a href="#idp45847928" class="para"><sup class="para">[7] </sup></a>Historically known as <span class="quote">&#8220;<span class="quote">disklabel</span>&#8221;</span>.  If you
	  ever wondered where FreeBSD stored this information, it is in
	  this region.  See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bsdlabel</span>(8)</span></a></p></div><div id="ftn.idp45870328" class="footnote"><p><a href="#idp45870328" class="para"><sup class="para">[8] </sup></a>This is necessary for legacy reasons.  Interested
	  readers should see <a class="link" href="http://en.wikipedia.org/wiki/A20_line" target="_top">http://en.wikipedia.org/wiki/A20_line</a>.</p></div><div id="ftn.idp46109688" class="footnote"><p><a href="#idp46109688" class="para"><sup class="para">[9] </sup></a>Real-mode code and data are necessary when switching
	      back to real mode from protected mode, as suggested by
	      the Intel manuals.</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="locking"></a>Chapter 2. Locking Notes</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#locking-mutexes">2.1. Mutexes</a></span></dt><dt><span class="sect1"><a href="#locking-sx">2.2. Shared Exclusive Locks</a></span></dt><dt><span class="sect1"><a href="#locking-atomic">2.3. Atomically Protected Variables</a></span></dt></dl></div><a id="idp49121784" class="indexterm"></a><p><span class="emphasis"><em>This chapter is maintained by the FreeBSD SMP Next
      Generation Project.</em></span></p><a id="idp49123064" class="indexterm"></a><a id="idp49123576" class="indexterm"></a><a id="idp49124088" class="indexterm"></a><a id="idp49124600" class="indexterm"></a><a id="idp49125112" class="indexterm"></a><p>This document outlines the locking used in the FreeBSD kernel
    to permit effective multi-processing within the kernel.  Locking
    can be achieved via several means.  Data structures can be
    protected by mutexes or <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">lockmgr</span>(9)</span></a> locks.  A few variables
    are protected simply by always using atomic operations to access
    them.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="locking-mutexes"></a>2.1. Mutexes</h2></div></div></div><p>A mutex is simply a lock used to guarantee mutual exclusion.
      Specifically, a mutex may only be owned by one entity at a time.
      If another entity wishes to obtain a mutex that is already
      owned, it must wait until the mutex is released.  In the FreeBSD
      kernel, mutexes are owned by processes.</p><p>Mutexes may be recursively acquired, but they are intended
      to be held for a short period of time.  Specifically, one may
      not sleep while holding a mutex.  If you need to hold a lock
      across a sleep, use a <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">lockmgr</span>(9)</span></a> lock.</p><p>Each mutex has several properties of interest:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Variable Name</span></dt><dd><p>The name of the <span class="type">struct mtx</span> variable in
	    the kernel source.</p></dd><dt><span class="term">Logical Name</span></dt><dd><p>The name of the mutex assigned to it by
	    <code class="function">mtx_init</code>.  This name is displayed in
	    KTR trace messages and witness errors and warnings and is
	    used to distinguish mutexes in the witness code.</p></dd><dt><span class="term">Type</span></dt><dd><p>The type of the mutex in terms of the
	    <code class="constant">MTX_*</code> flags.  The meaning for each
	    flag is related to its meaning as documented in
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mutex</span>(9)</span></a>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">MTX_DEF</code></span></dt><dd><p>A sleep mutex</p></dd><dt><span class="term"><code class="constant">MTX_SPIN</code></span></dt><dd><p>A spin mutex</p></dd><dt><span class="term"><code class="constant">MTX_RECURSE</code></span></dt><dd><p>This mutex is allowed to recurse.</p></dd></dl></div></dd><dt><span class="term">Protectees</span></dt><dd><p>A list of data structures or data structure members
	    that this entry protects.  For data structure members, the
	    name will be in the form of <code class="varname">structure name</code>.<code class="varname">member name</code>.</p></dd><dt><span class="term">Dependent Functions</span></dt><dd><p>Functions that can only be called if this mutex is
	    held.</p></dd></dl></div><div class="table"><a id="idp49178616"></a><div class="table-title">Table 2.1. Mutex List</div><div class="table-contents"><a id="idp49183864" class="indexterm"></a><a id="idp49185016" class="indexterm"></a><a id="idp49186168" class="indexterm"></a><a id="idp49187320" class="indexterm"></a><table class="table" summary="Mutex List" width="100%" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>Variable Name</th><th>Logical Name</th><th>Type</th><th>Protectees</th><th>Dependent Functions</th></tr></thead><tbody><tr><td>sched_lock</td><td>
	      <span class="quote">&#8220;<span class="quote">sched lock</span>&#8221;</span></td><td>
	      <code class="constant">MTX_SPIN</code> |
	      <code class="constant">MTX_RECURSE</code></td><td>
	      <code class="varname">_gmonparam</code>,
	      <code class="varname">cnt.v_swtch</code>,
	      <code class="varname">cp_time</code>,
	      <code class="varname">curpriority</code>,
	      <code class="varname">mtx</code>.<code class="varname">mtx_blocked</code>,
	      <code class="varname">mtx</code>.<code class="varname">mtx_contested</code>,
	      <code class="varname">proc</code>.<code class="varname">p_procq</code>,
	      <code class="varname">proc</code>.<code class="varname">p_slpq</code>,
	      <code class="varname">proc</code>.<code class="varname">p_sflag</code>,
	      <code class="varname">proc</code>.<code class="varname">p_stat</code>,
	      <code class="varname">proc</code>.<code class="varname">p_estcpu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_cpticks</code>
	      <code class="varname">proc</code>.<code class="varname">p_pctcpu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_wchan</code>,
	      <code class="varname">proc</code>.<code class="varname">p_wmesg</code>,
	      <code class="varname">proc</code>.<code class="varname">p_swtime</code>,
	      <code class="varname">proc</code>.<code class="varname">p_slptime</code>,
	      <code class="varname">proc</code>.<code class="varname">p_runtime</code>,
	      <code class="varname">proc</code>.<code class="varname">p_uu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_su</code>,
	      <code class="varname">proc</code>.<code class="varname">p_iu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_uticks</code>,
	      <code class="varname">proc</code>.<code class="varname">p_sticks</code>,
	      <code class="varname">proc</code>.<code class="varname">p_iticks</code>,
	      <code class="varname">proc</code>.<code class="varname">p_oncpu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_lastcpu</code>,
	      <code class="varname">proc</code>.<code class="varname">p_rqindex</code>,
	      <code class="varname">proc</code>.<code class="varname">p_heldmtx</code>,
	      <code class="varname">proc</code>.<code class="varname">p_blocked</code>,
	      <code class="varname">proc</code>.<code class="varname">p_mtxname</code>,
	      <code class="varname">proc</code>.<code class="varname">p_contested</code>,
	      <code class="varname">proc</code>.<code class="varname">p_priority</code>,
	      <code class="varname">proc</code>.<code class="varname">p_usrpri</code>,
	      <code class="varname">proc</code>.<code class="varname">p_nativepri</code>,
	      <code class="varname">proc</code>.<code class="varname">p_nice</code>,
	      <code class="varname">proc</code>.<code class="varname">p_rtprio</code>,
	      <code class="varname">pscnt</code>,
	      <code class="varname">slpque</code>,
	      <code class="varname">itqueuebits</code>,
	      <code class="varname">itqueues</code>,
	      <code class="varname">rtqueuebits</code>,
	      <code class="varname">rtqueues</code>,
	      <code class="varname">queuebits</code>,
	      <code class="varname">queues</code>,
	      <code class="varname">idqueuebits</code>,
	      <code class="varname">idqueues</code>,
	      <code class="varname">switchtime</code>,
	      <code class="varname">switchticks</code></td><td>
	      <code class="function">setrunqueue</code>,
	      <code class="function">remrunqueue</code>,
	      <code class="function">mi_switch</code>,
	      <code class="function">chooseproc</code>,
	      <code class="function">schedclock</code>,
	      <code class="function">resetpriority</code>,
	      <code class="function">updatepri</code>,
	      <code class="function">maybe_resched</code>,
	      <code class="function">cpu_switch</code>,
	      <code class="function">cpu_throw</code>,
	      <code class="function">need_resched</code>,
	      <code class="function">resched_wanted</code>,
	      <code class="function">clear_resched</code>,
	      <code class="function">aston</code>,
	      <code class="function">astoff</code>,
	      <code class="function">astpending</code>,
	      <code class="function">calcru</code>,
	      <code class="function">proc_compare</code></td></tr><tr><td>vm86pcb_lock</td><td><span class="quote">&#8220;<span class="quote">vm86pcb lock</span>&#8221;</span></td><td>
	      <code class="constant">MTX_DEF</code></td><td>
	      <code class="varname">vm86pcb</code></td><td>
	      <code class="function">vm86_bioscall</code></td></tr><tr><td>Giant</td><td><span class="quote">&#8220;<span class="quote">Giant</span>&#8221;</span></td><td>
	      <code class="constant">MTX_DEF</code> |
	      <code class="constant">MTX_RECURSE</code></td><td>nearly everything</td><td>lots</td></tr><tr><td>callout_lock</td><td><span class="quote">&#8220;<span class="quote">callout lock</span>&#8221;</span></td><td>
	      <code class="constant">MTX_SPIN</code> |
	      <code class="constant">MTX_RECURSE</code></td><td>
	      <code class="varname">callfree</code>,
	      <code class="varname">callwheel</code>,
	      <code class="varname">nextsoftcheck</code>,
	      <code class="varname">proc</code>.<code class="varname">p_itcallout</code>,
	      <code class="varname">proc</code>.<code class="varname">p_slpcallout</code>,
	      <code class="varname">softticks</code>,
	      <code class="varname">ticks</code></td><td> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="locking-sx"></a>2.2. Shared Exclusive Locks</h2></div></div></div><p>These locks provide basic reader-writer type functionality
      and may be held by a sleeping process.  Currently they are
      backed by <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">lockmgr</span>(9)</span></a>.</p><a id="idp49257080" class="indexterm"></a><div class="table"><a id="idp49258232"></a><div class="table-title">Table 2.2. Shared Exclusive Lock List</div><div class="table-contents"><a id="idp49258872" class="indexterm"></a><a id="idp49260024" class="indexterm"></a><table class="table" summary="Shared Exclusive Lock List" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Variable Name</th><th>Protectees</th></tr></thead><tbody><tr><td><code class="varname">allproc_lock</code></td><td>
	      <code class="varname">allproc</code>
	      <code class="varname">zombproc</code>
	      <code class="varname">pidhashtbl</code>
	      <code class="varname">proc</code>.<code class="varname">p_list</code>
	      <code class="varname">proc</code>.<code class="varname">p_hash</code>
	      <code class="varname">nextpid</code></td></tr><tr><td><code class="varname">proctree_lock</code></td><td>
	      <code class="varname">proc</code>.<code class="varname">p_children</code>
	      <code class="varname">proc</code>.<code class="varname">p_sibling</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="locking-atomic"></a>2.3. Atomically Protected Variables</h2></div></div></div><a id="idp49276664" class="indexterm"></a><p>An atomically protected variable is a special variable that
      is not protected by an explicit lock.  Instead, all data
      accesses to the variables use special atomic operations as
      described in <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=atomic&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">atomic</span>(9)</span></a>.  Very few variables are treated
      this way, although other synchronization primitives such as
      mutexes are implemented with atomically protected
      variables.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">mtx</code>.<code class="varname">mtx_lock</code></p></li></ul></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="kernel-objects"></a>Chapter 3. Kernel Objects</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#kernel-objects-term">3.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-operation">3.2. Kobj Operation</a></span></dt><dt><span class="sect1"><a href="#kernel-objects-using">3.3. Using Kobj</a></span></dt></dl></div><a id="idp49294200" class="indexterm"></a><a id="idp49294712" class="indexterm"></a><a id="idp49295224" class="indexterm"></a><p>Kernel Objects, or <em class="firstterm">Kobj</em> provides an
    object-oriented C programming system for the kernel. As such the
    data being operated on carries the description of how to operate
    on it. This allows operations to be added and removed from an
    interface at run time and without breaking binary
    compatibility.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel-objects-term"></a>3.1. Terminology</h2></div></div></div><a id="idp49297272" class="indexterm"></a><a id="idp49297784" class="indexterm"></a><a id="idp49302392" class="indexterm"></a><a id="idp49302904" class="indexterm"></a><div class="variablelist"><dl class="variablelist"><dt><span class="term">Object</span></dt><dd><p>A set of data - data structure - data
	allocation.</p></dd><dt><span class="term">Method</span></dt><dd><p>An operation - function.</p></dd><dt><span class="term">Class</span></dt><dd><p>One or more methods.</p></dd><dt><span class="term">Interface</span></dt><dd><p>A standard set of one or more methods.</p></dd></dl></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel-objects-operation"></a>3.2. Kobj Operation</h2></div></div></div><p>Kobj works by generating descriptions of methods. Each
      description holds a unique id as well as a default function. The
      description's address is used to uniquely identify the method
      within a class' method table.</p><p>A class is built by creating a method table associating one
      or more functions with method descriptions. Before use the class
      is compiled. The compilation allocates a cache and associates it
      with the class. A unique id is assigned to each method
      description within the method table of the class if not already
      done so by another referencing class compilation. For every
      method to be used a function is generated by script to qualify
      arguments and automatically reference the method description for
      a lookup. The generated function looks up the method by using
      the unique id associated with the method description as a hash
      into the cache associated with the object's class. If the method
      is not cached the generated function proceeds to use the class'
      table to find the method. If the method is found then the
      associated function within the class is used; otherwise, the
      default function associated with the method description is
      used.</p><p>These indirections can be visualized as the
      following:</p><pre class="programlisting">object-&gt;cache&lt;-&gt;class</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel-objects-using"></a>3.3. Using Kobj</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49313144"></a>3.3.1. Structures</h3></div></div></div><pre class="programlisting">struct kobj_method</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49314296"></a>3.3.2. Functions</h3></div></div></div><pre class="programlisting">void kobj_class_compile(kobj_class_t cls);
void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);
void kobj_class_free(kobj_class_t cls);
kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);
void kobj_init(kobj_t obj, kobj_class_t cls);
void kobj_delete(kobj_t obj, struct malloc_type *mtype);</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49335928"></a>3.3.3. Macros</h3></div></div></div><pre class="programlisting">KOBJ_CLASS_FIELDS
KOBJ_FIELDS
DEFINE_CLASS(name, methods, size)
KOBJMETHOD(NAME, FUNC)</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49337080"></a>3.3.4. Headers</h3></div></div></div><pre class="programlisting">&lt;sys/param.h&gt;
&lt;sys/kobj.h&gt;</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49338232"></a>3.3.5. Creating an Interface Template</h3></div></div></div><a id="idp49338872" class="indexterm"></a><p>The first step in using Kobj is to create an
        Interface. Creating the interface involves creating a template
        that the script
        <code class="filename">src/sys/kern/makeobjops.pl</code> can use to
        generate the header and code for the method declarations and
        method lookup functions.</p><p>Within this template the following keywords are used:
        <code class="literal">#include</code>, <code class="literal">INTERFACE</code>,
        <code class="literal">CODE</code>, <code class="literal">METHOD</code>,
        <code class="literal">STATICMETHOD</code>, and
        <code class="literal">DEFAULT</code>.</p><p>The <code class="literal">#include</code> statement and what follows
        it is copied verbatim to the head of the generated code
        file.</p><p>For example:</p><pre class="programlisting">#include &lt;sys/foo.h&gt;</pre><p>The <code class="literal">INTERFACE</code> keyword is used to define
        the interface name. This name is concatenated with each method
        name as [interface name]_[method name]. Its syntax is
        INTERFACE [interface name];.</p><p>For example:</p><pre class="programlisting">INTERFACE foo;</pre><p>The <code class="literal">CODE</code> keyword copies its arguments
      verbatim into the code file. Its syntax is
      <code class="literal">CODE { [whatever] };</code></p><p>For example:</p><pre class="programlisting">CODE {
	struct foo * foo_alloc_null(struct bar *)
	{
		return NULL;
}
};</pre><p>The <code class="literal">METHOD</code> keyword describes a method. Its syntax is
      <code class="literal">METHOD [return type] [method name] { [object [,
      arguments]] };</code></p><p>For example:</p><pre class="programlisting">METHOD int bar {
	struct object *;
	struct foo *;
	struct bar;
};</pre><p>The <code class="literal">DEFAULT</code> keyword may follow the
        <code class="literal">METHOD</code> keyword. It extends the
        <code class="literal">METHOD</code> key word to include the default
        function for method. The extended syntax is
        <code class="literal">METHOD [return type] [method name] {
        [object; [other arguments]] }DEFAULT [default
        function];</code></p><p>For example:</p><pre class="programlisting">METHOD int bar {
	struct object *;
	struct foo *;
	int bar;
} DEFAULT foo_hack;</pre><p>The <code class="literal">STATICMETHOD</code> keyword is used like
      the <code class="literal">METHOD</code> keyword except the kobj data is not
      at the head of the object structure so casting to kobj_t would
      be incorrect. Instead <code class="literal">STATICMETHOD</code> relies on the Kobj data being
      referenced as 'ops'. This is also useful for calling
      methods directly out of a class's method table.</p><p>Other complete examples:</p><pre class="programlisting">src/sys/kern/bus_if.m
src/sys/kern/device_if.m</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49371384"></a>3.3.6. Creating a Class</h3></div></div></div><a id="idp49376120" class="indexterm"></a><p>The second step in using Kobj is to create a class. A
        class consists of a name, a table of methods, and the size of
        objects if Kobj's object handling facilities are used. To
        create the class use the macro
        <code class="function">DEFINE_CLASS()</code>. To create the method
        table create an array of kobj_method_t terminated by a NULL
        entry. Each non-NULL entry may be created using the macro
        <code class="function">KOBJMETHOD()</code>.</p><p>For example:</p><pre class="programlisting">DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));

kobj_method_t foomethods[] = {
	KOBJMETHOD(bar_doo, foo_doo),
	KOBJMETHOD(bar_foo, foo_foo),
	{ NULL, NULL}
};</pre><p>The class must be <span class="quote">&#8220;<span class="quote">compiled</span>&#8221;</span>.  Depending on
        the state of the system at the time that the class is to be
        initialized a statically allocated cache, <span class="quote">&#8220;<span class="quote">ops
        table</span>&#8221;</span> have to be used. This can be accomplished by
        declaring a <code class="varname">struct kobj_ops</code> and using
        <code class="function">kobj_class_compile_static();</code> otherwise,
        <code class="function">kobj_class_compile()</code> should be used.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49381496"></a>3.3.7. Creating an Object</h3></div></div></div><a id="idp49382136" class="indexterm"></a><p>The third step in using Kobj involves how to define the
        object. Kobj object creation routines assume that Kobj data is
        at the head of an object. If this in not appropriate you will
        have to allocate the object yourself and then use
        <code class="function">kobj_init()</code> on the Kobj portion of it;
        otherwise, you may use <code class="function">kobj_create()</code> to
        allocate and initialize the Kobj portion of the object
        automatically. <code class="function">kobj_init()</code> may also be
        used to change the class that an object uses.</p><p>To integrate Kobj into the object you should use the macro
       KOBJ_FIELDS.</p><p>For example</p><pre class="programlisting">struct foo_data {
	KOBJ_FIELDS;
	foo_foo;
	foo_bar;
};</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49385848"></a>3.3.8. Calling Methods</h3></div></div></div><p>The last step in using Kobj is to simply use the generated
	functions to use the desired method within the object's
	class. This is as simple as using the interface name and the
	method name with a few modifications. The interface name
	should be concatenated with the method name using a '_'
	between them, all in upper case.</p><p>For example, if the interface name was foo and the method
      was bar then the call would be:</p><pre class="programlisting">[return value = ] FOO_BAR(object [, other parameters]);</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49387768"></a>3.3.9. Cleaning Up</h3></div></div></div><p>When an object allocated through
        <code class="function">kobj_create()</code> is no longer needed
        <code class="function">kobj_delete()</code> may be called on it, and
        when a class is no longer being used
        <code class="function">kobj_class_free()</code> may be called on it.</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="jail"></a>Chapter 4. The Jail Subsystem</h2></div><div><span xmlns="http://www.w3.org/1999/xhtml" class="personname"><span class="firstname">Evan</span> <span class="surname">Sarmiento</span></span><span xmlns="http://www.w3.org/1999/xhtml" class="affiliation"></span></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2001 Evan Sarmiento</p></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#jail-arch">4.1. Architecture</a></span></dt><dt><span class="sect1"><a href="#jail-restrictions">4.2. Restrictions</a></span></dt></dl></div><a id="idp49408120" class="indexterm"></a><a id="idp49408632" class="indexterm"></a><a id="idp49409144" class="indexterm"></a><p>On most <span class="trademark">UNIX</span>® systems, <code class="literal">root</code> has omnipotent
    power.  This promotes insecurity.  If an attacker gained
    <code class="literal">root</code> on a system, he would have every function
    at his fingertips.  In FreeBSD there are sysctls which dilute the
    power of <code class="literal">root</code>, in order to minimize the damage
    caused by an attacker.  Specifically, one of these functions is
    called <code class="literal">secure levels</code>.  Similarly, another
    function which is present from FreeBSD 4.0 and onward, is a
    utility called <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a>.  <span class="application">Jail</span>
    chroots an environment and sets certain restrictions on processes
    which are forked within the <span class="application">jail</span>.  For
    example, a jailed process cannot affect processes outside the
    <span class="application">jail</span>, utilize certain system calls, or
    inflict any damage on the host environment.</p><p><span class="application">Jail</span> is becoming the new security
    model.  People are running potentially vulnerable servers such as
    <span class="application">Apache</span>,
    <span class="application">BIND</span>, and
    <span class="application">sendmail</span> within jails, so that if an
    attacker gains <code class="literal">root</code> within the
    <span class="application">jail</span>, it is only an annoyance, and not
    a devastation.  This article mainly focuses on the internals
    (source code) of <span class="application">jail</span>.  For information
    on how to set up a jail see the <a class="link" href="../../../../doc/en_US.ISO8859-1/books/handbook/jails.html" target="_top">handbook entry on
      jails</a>.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="jail-arch"></a>4.1. Architecture</h2></div></div></div><p><span class="application">Jail</span> consists of two realms: the
      userland program, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a>, and the code implemented within
      the kernel: the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> system call and associated
      restrictions.  I will be discussing the userland program and
      then how <span class="application">jail</span> is implemented within
      the kernel.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49433464"></a>4.1.1. Userland Code</h3></div></div></div><a id="idp49434104" class="indexterm"></a><p>The source for the userland
	<span class="application">jail</span> is located in
	<code class="filename">/usr/src/usr.sbin/jail</code>, consisting of one
	file, <code class="filename">jail.c</code>.  The program takes these
	arguments: the path of the <span class="application">jail</span>,
	hostname, IP address, and the command to be executed.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49436920"></a>4.1.1.1. Data Structures</h4></div></div></div><p>In <code class="filename">jail.c</code>, the first thing I would
	  note is the declaration of an important structure
	  <code class="literal">struct jail j;</code> which was included from
	  <code class="filename">/usr/include/sys/jail.h</code>.</p><p>The definition of the <code class="literal">jail</code> structure
	  is:</p><pre class="programlisting"><code class="filename">/usr/include/sys/jail.h</code>:

struct jail {
        u_int32_t       version;
        char            *path;
        char            *hostname;
        u_int32_t       ip_number;
};</pre><p>As you can see, there is an entry for each of the
	  arguments passed to the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a> program, and indeed,
	  they are set during its execution.</p><pre class="programlisting"><code class="filename">/usr/src/usr.sbin/jail/jail.c</code>
char path[PATH_MAX];
...
if (realpath(argv[0], path) == NULL)
    err(1, "realpath: %s", argv[0]);
if (chdir(path) != 0)
    err(1, "chdir: %s", path);
memset(&amp;j, 0, sizeof(j));
j.version = 0;
j.path = path;
j.hostname = argv[1];</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49442424"></a>4.1.1.2. Networking</h4></div></div></div><p>One of the arguments passed to the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a> program
	  is an IP address with which the
	  <span class="application">jail</span> can be accessed over the
	  network.  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a> translates the IP address given into
	  host byte order and then stores it in <code class="literal">j</code>
	  (the <code class="literal">jail</code> structure).</p><pre class="programlisting"><code class="filename">/usr/src/usr.sbin/jail/jail.c</code>:
struct in_addr in;
...
if (inet_aton(argv[2], &amp;in) == 0)
    errx(1, "Could not make sense of ip-number: %s", argv[2]);
j.ip_number = ntohl(in.s_addr);</pre><p>The <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">inet_aton</span>(3)</span></a> function "interprets the specified
	  character string as an Internet address, placing the address
	  into the structure provided." The
	  <code class="literal">ip_number</code> member in the
	  <code class="literal">jail</code> structure is set only when the IP
	  address placed onto the <code class="literal">in</code> structure by
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=inet_aton&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">inet_aton</span>(3)</span></a> is translated into host byte order by
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ntohl</span>(3)</span></a>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49467128"></a>4.1.1.3. Jailing the Process</h4></div></div></div><p>Finally, the userland program jails the process.
	  <span class="application">Jail</span> now becomes an imprisoned
	  process itself and then executes the command given using
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=execv&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">execv</span>(3)</span></a>.</p><pre class="programlisting"><code class="filename">/usr/src/usr.sbin/jail/jail.c</code>
i = jail(&amp;j);
...
if (execv(argv[3], argv + 3) != 0)
    err(1, "execv: %s", argv[3]);</pre><p>As you can see, the <code class="literal">jail()</code> function
	  is called, and its argument is the <code class="literal">jail</code>
	  structure which has been filled with the arguments given to
	  the program.  Finally, the program you specify is executed.
	  I will now discuss how <span class="application">jail</span> is
	  implemented within the kernel.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49471736"></a>4.1.2. Kernel Space</h3></div></div></div><a id="idp49472376" class="indexterm"></a><p>We will now be looking at the file
	<code class="filename">/usr/src/sys/kern/kern_jail.c</code>.  This is
	the file where the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> system call, appropriate
	sysctls, and networking functions are defined.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49474808"></a>4.1.2.1. Sysctls</h4></div></div></div><a id="idp49475448" class="indexterm"></a><p>In <code class="filename">kern_jail.c</code>, the following
	  sysctls are defined:</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c:</code>
int     jail_set_hostname_allowed = 1;
SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,
    &amp;jail_set_hostname_allowed, 0,
    "Processes in jail can set their hostnames");

int     jail_socket_unixiproute_only = 1;
SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,
    &amp;jail_socket_unixiproute_only, 0,
    "Processes in jail are limited to creating UNIX/IPv4/route sockets only");

int     jail_sysvipc_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,
    &amp;jail_sysvipc_allowed, 0,
    "Processes in jail can use System V IPC primitives");

static int jail_enforce_statfs = 2;
SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,
    &amp;jail_enforce_statfs, 0,
    "Processes in jail cannot see all mounted file systems");

int    jail_allow_raw_sockets = 0;
SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,
    &amp;jail_allow_raw_sockets, 0,
    "Prison root can create raw sockets");

int    jail_chflags_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,
    &amp;jail_chflags_allowed, 0,
    "Processes in jail can alter system file flags");

int     jail_mount_allowed = 0;
SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,
    &amp;jail_mount_allowed, 0,
    "Processes in jail can mount/unmount jail-friendly file systems");</pre><p>Each of these sysctls can be accessed by the user
	  through the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> program.  Throughout the kernel,
	  these specific sysctls are recognized by their name.  For
	  example, the name of the first sysctl is
	  <code class="literal">security.jail.set_hostname_allowed</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49511800"></a>4.1.2.2. <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> System Call</h4></div></div></div><p>Like all system calls, the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> system call
	  takes two arguments, <code class="literal">struct thread *td</code>
	  and <code class="literal">struct jail_args *uap</code>.
	  <code class="literal">td</code> is a pointer to the
	  <code class="literal">thread</code> structure which describes the
	  calling thread.  In this context, <code class="literal">uap</code> is
	  a pointer to the structure in which a pointer to the
	  <code class="literal">jail</code> structure passed by the userland
	  <code class="filename">jail.c</code> is contained.  When I described
	  the userland program before, you saw that the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a>
	  system call was given a <code class="literal">jail</code> structure as
	  its own argument.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c:</code>
/*
 * struct jail_args {
 *  struct jail *jail;
 * };
 */
int
jail(struct thread *td, struct jail_args *uap)</pre><p>Therefore, <code class="literal">uap-&gt;jail</code> can be used
	  to access the <code class="literal">jail</code> structure which was
	  passed to the system call.  Next, the system call copies the
	  <code class="literal">jail</code> structure into kernel space using
	  the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">copyin</span>(9)</span></a> function.  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=copyin&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">copyin</span>(9)</span></a> takes three
	  arguments: the address of the data which is to be copied
	  into kernel space, <code class="literal">uap-&gt;jail</code>, where to
	  store it, <code class="literal">j</code> and the size of the storage.
	  The <code class="literal">jail</code> structure pointed by
	  <code class="literal">uap-&gt;jail</code> is copied into kernel space
	  and is stored in another <code class="literal">jail</code> structure,
	  <code class="literal">j</code>.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c:</code>
error = copyin(uap-&gt;jail, &amp;j, sizeof(j));</pre><p>There is another important structure defined in
	  <code class="filename">jail.h</code>.  It is the
	  <code class="literal">prison</code> structure.  The
	  <code class="literal">prison</code> structure is used exclusively
	  within kernel space.  Here is the definition of the
	  <code class="literal">prison</code> structure.</p><pre class="programlisting"><code class="filename">/usr/include/sys/jail.h</code>:
struct prison {
        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */
        int              pr_id;                         /* (c) prison id */
        int              pr_ref;                        /* (p) refcount */
        char             pr_path[MAXPATHLEN];           /* (c) chroot path */
        struct vnode    *pr_root;                       /* (c) vnode to rdir */
        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */
        u_int32_t        pr_ip;                         /* (c) ip addr host */
        void            *pr_linux;                      /* (p) linux abi */
        int              pr_securelevel;                /* (p) securelevel */
        struct task      pr_task;                       /* (d) destroy task */
        struct mtx       pr_mtx;
      void            **pr_slots;                     /* (p) additional data */
};</pre><p>The <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> system call then allocates memory for a
	  <code class="literal">prison</code> structure and copies data between
	  the <code class="literal">jail</code> and <code class="literal">prison</code>
	  structure.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c</code>:
MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);
...
error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);
if (error)
    goto e_killmtx;
...
error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);
if (error)
     goto e_dropvnref;
pr-&gt;pr_ip = j.ip_number;</pre><p>Next, we will discuss another important system call
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail_attach</span>(2)</span></a>, which implements the function to put a
	  process into the <span class="application">jail</span>.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c</code>:
/*
 * struct jail_attach_args {
 *      int jid;
 * };
 */
int
jail_attach(struct thread *td, struct jail_attach_args *uap)</pre><p>This system call makes the changes that can distinguish
	  a jailed process from those unjailed ones.  To understand
	  what <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail_attach&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail_attach</span>(2)</span></a> does for us, certain background
	  information is needed.</p><p>On FreeBSD, each kernel visible thread is identified by
	  its <code class="literal">thread</code> structure, while the processes
	  are described by their <code class="literal">proc</code> structures.
	  You can find the definitions of the
	  <code class="literal">thread</code> and <code class="literal">proc</code>
	  structure in <code class="filename">/usr/include/sys/proc.h</code>.
	  For example, the <code class="literal">td</code> argument in any
	  system call is actually a pointer to the calling thread's
	  <code class="literal">thread</code> structure, as stated before.  The
	  <code class="literal">td_proc</code> member in the
	  <code class="literal">thread</code> structure pointed by
	  <code class="literal">td</code> is a pointer to the
	  <code class="literal">proc</code> structure which represents the
	  process that contains the thread represented by
	  <code class="literal">td</code>.  The <code class="literal">proc</code>
	  structure contains members which can describe the owner's
	  identity(<code class="literal">p_ucred</code>), the process resource
	  limits(<code class="literal">p_limit</code>), and so on.  In the
	  <code class="literal">ucred</code> structure pointed by
	  <code class="literal">p_ucred</code> member in the
	  <code class="literal">proc</code> structure, there is a pointer to the
	  <code class="literal">prison</code>
	  structure(<code class="literal">cr_prison</code>).</p><pre class="programlisting"><code class="filename">/usr/include/sys/proc.h:</code>
struct thread {
    ...
    struct proc *td_proc;
    ...
};
struct proc {
    ...
    struct ucred *p_ucred;
    ...
};
<code class="filename">/usr/include/sys/ucred.h</code>
struct ucred {
    ...
    struct prison *cr_prison;
    ...
};</pre><p>In <code class="filename">kern_jail.c</code>, the function
	  <code class="literal">jail()</code> then calls function
	  <code class="literal">jail_attach()</code> with a given
	  <code class="literal">jid</code>.  And
	  <code class="literal">jail_attach()</code> calls function
	  <code class="literal">change_root()</code> to change the root
	  directory of the calling process.  The
	  <code class="literal">jail_attach()</code> then creates a new
	  <code class="literal">ucred</code> structure, and attaches the newly
	  created <code class="literal">ucred</code> structure to the calling
	  process after it has successfully attached the
	  <code class="literal">prison</code> structure to the
	  <code class="literal">ucred</code> structure.  From then on, the
	  calling process is recognized as jailed.  When the kernel
	  routine <code class="literal">jailed()</code> is called in the kernel
	  with the newly created <code class="literal">ucred</code> structure as
	  its argument, it returns 1 to tell that the credential is
	  connected with a <span class="application">jail</span>.  The
	  public ancestor process of all the process forked within the
	  <span class="application">jail</span>, is the process which runs
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a>, as it calls the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> system call.
	  When a program is executed through <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a>, it
	  inherits the jailed property of its parent's
	  <code class="literal">ucred</code> structure, therefore it has a
	  jailed <code class="literal">ucred</code> structure.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c</code>
int
jail(struct thread *td, struct jail_args *uap)
{
...
    struct jail_attach_args jaa;
...
    error = jail_attach(td, &amp;jaa);
    if (error)
        goto e_dropprref;
...
}

int
jail_attach(struct thread *td, struct jail_attach_args *uap)
{
    struct proc *p;
    struct ucred *newcred, *oldcred;
    struct prison *pr;
...
    p = td-&gt;td_proc;
...
    pr = prison_find(uap-&gt;jid);
...
    change_root(pr-&gt;pr_root, td);
...
    newcred-&gt;cr_prison = pr;
    p-&gt;p_ucred = newcred;
...
}</pre><p>When a process is forked from its parent process, the
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span></a> system call uses <code class="literal">crhold()</code> to
	  maintain the credential for the newly forked process.  It
	  inherently keep the newly forked child's credential
	  consistent with its parent, so the child process is also
	  jailed.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_fork.c</code>:
p2-&gt;p_ucred = crhold(td-&gt;td_ucred);
...
td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);</pre></div></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="jail-restrictions"></a>4.2. Restrictions</h2></div></div></div><p>Throughout the kernel there are access restrictions relating
      to jailed processes.  Usually, these restrictions only check
      whether the process is jailed, and if so, returns an error.  For
      example:</p><pre class="programlisting">if (jailed(td-&gt;td_ucred))
    return (EPERM);</pre><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49581688"></a>4.2.1. SysV IPC</h3></div></div></div><a id="idp49582328" class="indexterm"></a><p>System V IPC is based on messages.  Processes can send
	each other these messages which tell them how to act.  The
	functions which deal with messages are: <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=msgctl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">msgctl</span>(3)</span></a>,
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=msgget&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">msgget</span>(3)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=msgsnd&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">msgsnd</span>(3)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=msgrcv&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">msgrcv</span>(3)</span></a>.  Earlier, I
	mentioned that there were certain sysctls you could turn on or
	off in order to affect the behavior of
	<span class="application">jail</span>.  One of these sysctls was
	<code class="literal">security.jail.sysvipc_allowed</code>.  By default,
	this sysctl is set to 0.  If it were set to 1, it would defeat
	the whole purpose of having a <span class="application">jail</span>;
	privileged users from the <span class="application">jail</span>
	would be able to affect processes outside the jailed
	environment.  The difference between a message and a signal is
	that the message only consists of the signal number.</p><p><code class="filename">/usr/src/sys/kern/sysv_msg.c</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">msgget(key, msgflg)</code>:
	    <code class="literal">msgget</code> returns (and possibly creates) a
	    message descriptor that designates a message queue for use
	    in other functions.</p></li><li class="listitem"><p><code class="literal">msgctl(msgid, cmd, buf)</code>: Using this
	    function, a process can query the status of a message
	    descriptor.</p></li><li class="listitem"><p><code class="literal">msgsnd(msgid, msgp, msgsz, msgflg)</code>:
	    <code class="literal">msgsnd</code> sends a message to a
	    process.</p></li><li class="listitem"><p><code class="literal">msgrcv(msgid, msgp, msgsz, msgtyp,
	      msgflg)</code>: a process receives messages using
	    this function</p></li></ul></div><p>In each of the system calls corresponding to these
	functions, there is this conditional:</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/sysv_msg.c</code>:
if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))
    return (ENOSYS);</pre><a id="idp49599096" class="indexterm"></a><p>Semaphore system calls allow processes to synchronize
	execution by doing a set of operations atomically on a set of
	semaphores.  Basically semaphores provide another way for
	processes lock resources.  However, process waiting on a
	semaphore, that is being used, will sleep until the resources
	are relinquished.  The following semaphore system calls are
	blocked inside a <span class="application">jail</span>:
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=semget&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">semget</span>(2)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=semctl&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">semctl</span>(2)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=semop&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">semop</span>(2)</span></a>.</p><p><code class="filename">/usr/src/sys/kern/sysv_sem.c</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">semctl(semid, semnum, cmd, ...)</code>:
	    <code class="literal">semctl</code> does the specified
	    <code class="literal">cmd</code> on the semaphore queue indicated by
	    <code class="literal">semid</code>.</p></li><li class="listitem"><p><code class="literal">semget(key, nsems, flag)</code>:
	    <code class="literal">semget</code> creates an array of semaphores,
	    corresponding to <code class="literal">key</code>.</p><p><code class="literal">key and flag take on the same meaning as they
	      do in msgget.</code></p></li><li class="listitem"><p><code class="literal">semop(semid, array, nops)</code>:
	    <code class="literal">semop</code> performs a group of operations
	    indicated by <code class="literal">array</code>, to the set of
	    semaphores identified by
	    <code class="literal">semid</code>.</p></li></ul></div><a id="idp49622264" class="indexterm"></a><p>System V IPC allows for processes to share memory.
	Processes can communicate directly with each other by sharing
	parts of their virtual address space and then reading and
	writing data stored in the shared memory.  These system calls
	are blocked within a jailed environment: <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=shmdt&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">shmdt</span>(2)</span></a>,
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=shmat&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">shmat</span>(2)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=shmctl&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">shmctl</span>(2)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=shmget&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">shmget</span>(2)</span></a>.</p><p><code class="filename">/usr/src/sys/kern/sysv_shm.c</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">shmctl(shmid, cmd, buf)</code>:
	    <code class="literal">shmctl</code> does various control operations
	    on the shared memory region identified by
	    <code class="literal">shmid</code>.</p></li><li class="listitem"><p><code class="literal">shmget(key, size, flag)</code>:
	    <code class="literal">shmget</code> accesses or creates a shared
	    memory region of <code class="literal">size</code>
	    bytes.</p></li><li class="listitem"><p><code class="literal">shmat(shmid, addr, flag)</code>:
	    <code class="literal">shmat</code> attaches a shared memory region
	    identified by <code class="literal">shmid</code> to the address
	    space of a process.</p></li><li class="listitem"><p><code class="literal">shmdt(addr)</code>:
	    <code class="literal">shmdt</code> detaches the shared memory region
	    previously attached at
	    <code class="literal">addr</code>.</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49318648"></a>4.2.2. Sockets</h3></div></div></div><a id="idp49319288" class="indexterm"></a><p><span class="application">Jail</span> treats the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">socket</span>(2)</span></a>
	system call and related lower-level socket functions in a
	special manner.  In order to determine whether a certain
	socket is allowed to be created, it first checks to see if the
	sysctl
	<code class="literal">security.jail.socket_unixiproute_only</code> is
	set.  If set, sockets are only allowed to be created if the
	family specified is either <code class="literal">PF_LOCAL</code>,
	<code class="literal">PF_INET</code> or <code class="literal">PF_ROUTE</code>.
	Otherwise, it returns an error.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/uipc_socket.c</code>:
int
socreate(int dom, struct socket **aso, int type, int proto,
    struct ucred *cred, struct thread *td)
{
    struct protosw *prp;
...
    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;
        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {
        return (EPROTONOSUPPORT);
    }
...
}</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49323512"></a>4.2.3. Berkeley Packet Filter</h3></div></div></div><a id="idp49324152" class="indexterm"></a><a id="idp49324664" class="indexterm"></a><p>The <span class="application">Berkeley Packet Filter</span>
	provides a raw interface to data link layers in a protocol
	independent fashion.  <span class="application">BPF</span> is now
	controlled by the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">devfs</span>(8)</span></a> whether it can be used in a
	jailed environment.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49327224"></a>4.2.4. Protocols</h3></div></div></div><a id="idp49327864" class="indexterm"></a><p>There are certain protocols which are very common, such as
	TCP, UDP, IP and ICMP.  IP and ICMP are on the same level: the
	network layer 2.  There are certain precautions which are
	taken in order to prevent a jailed process from binding a
	protocol to a certain address only if the
	<code class="literal">nam</code> parameter is set.
	<code class="literal">nam</code> is a pointer to a
	<code class="literal">sockaddr</code> structure, which describes the
	address on which to bind the service.  A more exact definition
	is that <code class="literal">sockaddr</code> "may be used as a template
	for referring to the identifying tag and length of each
	address".  In the function
	<code class="literal">in_pcbbind_setup()</code>, <code class="literal">sin</code>
	is a pointer to a <code class="literal">sockaddr_in</code> structure,
	which contains the port, address, length and domain family of
	the socket which is to be bound.  Basically, this disallows
	any processes from <span class="application">jail</span> to be able
	to specify the address that does not belong to the
	<span class="application">jail</span> in which the calling process
	exists.</p><pre class="programlisting"><code class="filename">/usr/src/sys/netinet/in_pcb.c</code>:
int
in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,
    u_short *lportp, struct ucred *cred)
{
    ...
    struct sockaddr_in *sin;
    ...
    if (nam) {
        sin = (struct sockaddr_in *)nam;
        ...
        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return(EINVAL);
        ...
        if (lport) {
            ...
            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))
                return (EADDRNOTAVAIL);
            ...
        }
    }
    if (lport == 0) {
        ...
        if (laddr.s_addr != INADDR_ANY)
            if (prison_ip(cred, 0, &amp;laddr.s_addr))
                return (EINVAL);
        ...
    }
...
    if (prison_ip(cred, 0, &amp;laddr.s_addr))
        return (EINVAL);
...
}</pre><p>You might be wondering what function
	<code class="literal">prison_ip()</code> does.
	<code class="literal">prison_ip()</code> is given three arguments, a
	pointer to the credential(represented by
	<code class="literal">cred</code>), any flags, and an IP address.  It
	returns 1 if the IP address does NOT belong to the
	<span class="application">jail</span> or 0 otherwise.  As you can
	see from the code, if it is indeed an IP address not belonging
	to the <span class="application">jail</span>, the protocol is not
	allowed to bind to that address.</p><pre class="programlisting"><code class="filename">/usr/src/sys/kern/kern_jail.c:</code>
int
prison_ip(struct ucred *cred, int flag, u_int32_t *ip)
{
    u_int32_t tmp;

    if (!jailed(cred))
        return (0);
    if (flag)
        tmp = *ip;
    else
        tmp = ntohl(*ip);
    if (tmp == INADDR_ANY) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (tmp == INADDR_LOOPBACK) {
        if (flag)
            *ip = cred-&gt;cr_prison-&gt;pr_ip;
        else
            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);
        return (0);
    }
    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)
        return (1);
    return (0);
}</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49647352"></a>4.2.5. Filesystem</h3></div></div></div><a id="idp49647992" class="indexterm"></a><p>Even <code class="literal">root</code> users within the
	<span class="application">jail</span> are not allowed to unset or
	modify any file flags, such as immutable, append-only, and
	undeleteable flags, if the securelevel is greater than
	0.</p><pre class="programlisting"><code class="filename">/usr/src/sys/ufs/ufs/ufs_vnops.c:</code>
static int
ufs_setattr(ap)
    ...
{
    ...
        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {
            if (ip-&gt;i_flags
                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {
                    error = securelevel_gt(cred, 0);
                    if (error)
                        return (error);
            }
            ...
        }
}
<code class="filename">/usr/src/sys/kern/kern_priv.c</code>
int
priv_check_cred(struct ucred *cred, int priv, int flags)
{
    ...
    error = prison_priv_check(cred, priv);
    if (error)
        return (error);
    ...
}
<code class="filename">/usr/src/sys/kern/kern_jail.c</code>
int
prison_priv_check(struct ucred *cred, int priv)
{
    ...
    switch (priv) {
    ...
    case PRIV_VFS_SYSFLAGS:
        if (jail_chflags_allowed)
            return (0);
        else
            return (EPERM);
    ...
    }
    ...
}</pre></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sysinit"></a>Chapter 5. The SYSINIT Framework</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#sysinit-term">5.1. Terminology</a></span></dt><dt><span class="sect1"><a href="#sysinit-operation">5.2. SYSINIT Operation</a></span></dt><dt><span class="sect1"><a href="#sysinit-using">5.3. Using SYSINIT</a></span></dt></dl></div><a id="idp49660792" class="indexterm"></a><a id="idp49661560" class="indexterm"></a><a id="idp49662328" class="indexterm"></a><a id="idp49667576" class="indexterm"></a><a id="idp49668344" class="indexterm"></a><p>SYSINIT is the framework for a generic call sort and dispatch
    mechanism.  FreeBSD currently uses it for the dynamic
    initialization of the kernel.  SYSINIT allows FreeBSD's kernel
    subsystems to be reordered, and added, removed, and replaced at
    kernel link time when the kernel or one of its modules is loaded
    without having to edit a statically ordered initialization routing
    and recompile the kernel.  This system also allows kernel modules,
    currently called <em class="firstterm">KLD's</em>, to be separately
    compiled, linked, and initialized at boot time and loaded even
    later while the system is already running.  This is accomplished
    using the <span class="quote">&#8220;<span class="quote">kernel linker</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">linker
    sets</span>&#8221;</span>.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="sysinit-term"></a>5.1. Terminology</h2></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Linker Set</span></dt><dd><p>A linker technique in which the linker gathers
	    statically declared data throughout a program's source
	    files into a single contiguously addressable unit of
	    data.</p></dd></dl></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="sysinit-operation"></a>5.2. SYSINIT Operation</h2></div></div></div><a id="idp49674232" class="indexterm"></a><p>SYSINIT relies on the ability of the linker to take static
      data declared at multiple locations throughout a program's
      source and group it together as a single contiguous chunk of
      data.  This linker technique is called a <span class="quote">&#8220;<span class="quote">linker
      set</span>&#8221;</span>.  SYSINIT uses two linker sets to maintain two data
      sets containing each consumer's call order, function, and a
      pointer to the data to pass to that function.</p><p>SYSINIT uses two priorities when ordering the functions for
      execution.  The first priority is a subsystem ID giving an
      overall order for SYSINIT's dispatch of functions.  Current
      predeclared ID's are in
      <code class="filename">&lt;sys/kernel.h&gt;</code> in the enum
      list <code class="literal">sysinit_sub_id</code>.  The second priority
      used is an element order within the subsystem.  Current
      predeclared subsystem element orders are in
      <code class="filename">&lt;sys/kernel.h&gt;</code> in the enum list
      <code class="literal">sysinit_elem_order</code>.</p><a id="idp49677432" class="indexterm"></a><p>There are currently two uses for SYSINIT. Function dispatch
      at system startup and kernel module loads, and function dispatch
      at system shutdown and kernel module unload.  Kernel subsystems
      often use system startup SYSINIT's to initialize data
      structures, for example the process scheduling subsystem
      uses a SYSINIT to initialize the run queue data structure.
      Device drivers should avoid using <code class="literal">SYSINIT()</code>
      directly.  Instead drivers for real devices that are part of a
      bus structure should use <code class="literal">DRIVER_MODULE()</code> to
      provide a function that detects the device and, if it is
      present, initializes the device.  It will do a few things
      specific to devices and then call <code class="literal">SYSINIT()</code>
      itself.  For pseudo-devices, which are not part of a bus
      structure, use <code class="literal">DEV_MODULE()</code>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="sysinit-using"></a>5.3. Using SYSINIT</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49684856"></a>5.3.1. Interface</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49685496"></a>5.3.1.1. Headers</h4></div></div></div><pre class="programlisting">&lt;sys/kernel.h&gt;</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49686648"></a>5.3.1.2. Macros</h4></div></div></div><pre class="programlisting">SYSINIT(uniquifier, subsystem, order, func, ident)
SYSUNINIT(uniquifier, subsystem, order, func, ident)</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49687928"></a>5.3.2. Startup</h3></div></div></div><p>The <code class="literal">SYSINIT()</code> macro creates the
	necessary SYSINIT data in SYSINIT's startup data set for
	SYSINIT to sort and dispatch a function at system startup and
	module load.  <code class="literal">SYSINIT()</code> takes a uniquifier
	that SYSINIT uses to identify the particular function dispatch
	data, the subsystem order, the subsystem element order, the
	function to call, and the data to pass the function.  All
	functions must take a constant pointer argument.</p><div class="example"><a id="idp49689720"></a><div class="example-title">Example 5.1. Example of a <code class="literal">SYSINIT()</code></div><div class="example-contents"><pre class="programlisting">#include &lt;sys/kernel.h&gt;

void foo_null(void *unused)
{
        foo_doo();
}
SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);

struct foo foo_voodoo = {
        FOO_VOODOO;
}

void foo_arg(void *vdata)
{
        struct foo *foo = (struct foo *)vdata;
        foo_data(foo);
}
SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);</pre></div></div><br class="example-break" /><p>Note that <code class="literal">SI_SUB_FOO</code> and
	<code class="literal">SI_ORDER_FOO</code> need to be in the
	<code class="literal">sysinit_sub_id</code> and
	<code class="literal">sysinit_elem_order</code> enum's as mentioned
	above.  Either use existing ones or add your own to the
	enum's.  You can also use math for fine-tuning the order
	a SYSINIT will run in.  This example shows a SYSINIT that
	needs to be run just barely before the SYSINIT's that
	handle tuning kernel parameters.</p><div class="example"><a id="idp49692920"></a><div class="example-title">Example 5.2. Example of Adjusting <code class="literal">SYSINIT()</code>
	  Order</div><div class="example-contents"><pre class="programlisting">static void
mptable_register(void *dummy __unused)
{

	apic_register_enumerator(&amp;mptable_enumerator);
}

SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,
    mptable_register, NULL);</pre></div></div><br class="example-break" /></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp49694584"></a>5.3.3. Shutdown</h3></div></div></div><p>The <code class="literal">SYSUNINIT()</code> macro behaves similarly
	to the <code class="literal">SYSINIT()</code> macro except that it adds
	the SYSINIT data to SYSINIT's shutdown data set.</p><div class="example"><a id="idp49696376"></a><div class="example-title">Example 5.3. Example of a <code class="literal">SYSUNINIT()</code></div><div class="example-contents"><pre class="programlisting">#include &lt;sys/kernel.h&gt;

void foo_cleanup(void *unused)
{
        foo_kill();
}
SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);

struct foo_stack foo_stack = {
        FOO_STACK_VOODOO;
}

void foo_flush(void *vdata)
{
}
SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);</pre></div></div><br class="example-break" /></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac"></a>Chapter 6. The TrustedBSD MAC Framework</h2></div><div><span class="authorgroup"><span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Chris</span> <span class="surname">Costello</span></span> and <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Robert</span> <span class="surname">Watson</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#mac-copyright">6.1. MAC Documentation Copyright</a></span></dt><dt><span class="sect1"><a href="#mac-synopsis">6.2. Synopsis</a></span></dt><dt><span class="sect1"><a href="#mac-introduction">6.3. Introduction</a></span></dt><dt><span class="sect1"><a href="#mac-background">6.4. Policy Background</a></span></dt><dt><span class="sect1"><a href="#mac-framework-kernel-arch">6.5. MAC Framework Kernel Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-policy-architecture">6.6. MAC Policy Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-entry-point-reference">6.7. MAC Policy Entry Point Reference</a></span></dt><dt><span class="sect1"><a href="#mac-userland-arch">6.8. Userland Architecture</a></span></dt><dt><span class="sect1"><a href="#mac-conclusion">6.9. Conclusion</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-copyright"></a>6.1. MAC Documentation Copyright</h2></div></div></div><p>This documentation was developed for the FreeBSD Project by
      Chris Costello at Safeport Network Services and Network
      Associates Laboratories, the Security Research Division of
      Network Associates, Inc.  under DARPA/SPAWAR contract
      N66001-01-C-8035 (<span class="quote">&#8220;<span class="quote">CBOSS</span>&#8221;</span>), as part of the DARPA
      CHATS research program.</p><p>Redistribution and use in source (SGML DocBook) and
      'compiled' forms (SGML, HTML, PDF, PostScript, RTF and so forth)
      with or without modification, are permitted provided that the
      following conditions are met:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Redistributions of source code (SGML DocBook) must
	  retain the above copyright notice, this list of conditions
	  and the following disclaimer as the first lines of this file
	  unmodified.</p></li><li class="listitem"><p>Redistributions in compiled form (transformed to other
	  DTDs, converted to PDF, PostScript, RTF and other formats)
	  must reproduce the above copyright notice, this list of
	  conditions and the following disclaimer in the documentation
	  and/or other materials provided with the
	  distribution.</p></li></ol></div><div xmlns="" class="important"><h3 class="admontitle">Important: </h3><p xmlns="http://www.w3.org/1999/xhtml">THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES
	TECHNOLOGY, INC "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY,
	INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
	OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN
	IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-synopsis"></a>6.2. Synopsis</h2></div></div></div><p>FreeBSD includes experimental support for several mandatory
      access control policies, as well as a framework for kernel
      security extensibility, the TrustedBSD MAC Framework.  The MAC
      Framework is a pluggable access control framework, permitting
      new security policies to be easily linked into the kernel,
      loaded at boot, or loaded dynamically at run-time.  The
      framework provides a variety of features to make it easier to
      implement new security policies, including the ability to easily
      tag security labels (such as confidentiality information) onto
      system objects.</p><p>This chapter introduces the MAC policy framework and
      provides documentation for a sample MAC policy module.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-introduction"></a>6.3. Introduction</h2></div></div></div><p>The TrustedBSD MAC framework provides a mechanism to allow
      the compile-time or run-time extension of the kernel access
      control model.  New system policies may be implemented as kernel
      modules and linked to the kernel; if multiple policy modules are
      present, their results will be composed.  The MAC Framework
      provides a variety of access control infrastructure services to
      assist policy writers, including support for transient and
      persistent policy-agnostic object security labels.  This support
      is currently considered experimental.</p><p>This chapter provides information appropriate for developers
      of policy modules, as well as potential consumers of MAC-enabled
      environments, to learn about how the MAC Framework supports
      access control extension of the kernel.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-background"></a>6.4. Policy Background</h2></div></div></div><p>Mandatory Access Control (MAC), refers to a set of access
      control policies that are mandatorily enforced on users by the
      operating system.  MAC policies may be contrasted with
      Discretionary Access Control (DAC) protections, by which
      non-administrative users may (at their discretion) protect
      objects.  In traditional UNIX systems, DAC protections include
      file permissions and access control lists; MAC protections
      include process controls preventing inter-user debugging and
      firewalls.  A variety of MAC policies have been formulated by
      operating system designers and security researches, including
      the Multi-Level Security (MLS) confidentiality policy, the Biba
      integrity policy, Role-Based Access Control (RBAC), Domain and
      Type Enforcement (DTE), and Type Enforcement (TE).  Each model
      bases decisions on a variety of factors, including user
      identity, role, and security clearance, as well as security
      labels on objects representing concepts such as data sensitivity
      and integrity.</p><p>The TrustedBSD MAC Framework is capable of supporting policy
      modules that implement all of these policies, as well as a broad
      class of system hardening policies, which may use existing
      security attributes, such as user and group IDs, as well as
      extended attributes on files, and other system properties.  In
      addition, despite the name, the MAC Framework can also be used
      to implement purely discretionary policies, as policy modules
      are given substantial flexibility in how they authorize
      protections.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-framework-kernel-arch"></a>6.5. MAC Framework Kernel Architecture</h2></div></div></div><p>The TrustedBSD MAC Framework permits kernel modules to
      extend the operating system security policy, as well as
      providing infrastructure functionality required by many access
      control modules.  If multiple policies are simultaneously
      loaded, the MAC Framework will usefully (for some definition of
      useful) compose the results of the policies.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-elements"></a>6.5.1. Kernel Elements</h3></div></div></div><p>The MAC Framework contains a number of kernel
	elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Framework management interfaces</p></li><li class="listitem"><p>Concurrency and synchronization primitives.</p></li><li class="listitem"><p>Policy registration</p></li><li class="listitem"><p>Extensible security label for kernel objects</p></li><li class="listitem"><p>Policy entry point composition operators</p></li><li class="listitem"><p>Label management primitives</p></li><li class="listitem"><p>Entry point API invoked by kernel services</p></li><li class="listitem"><p>Entry point API to policy modules</p></li><li class="listitem"><p>Entry points implementations (policy life cycle,
	    object life cycle/label management, access control
	    checks).</p></li><li class="listitem"><p>Policy-agnostic label-management system calls</p></li><li class="listitem"><p><code class="function">mac_syscall()</code> multiplex system
	    call</p></li><li class="listitem"><p>Various security policies implemented as MAC policy
	    modules</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-management"></a>6.5.2. Framework Management Interfaces</h3></div></div></div><p>The TrustedBSD MAC Framework may be directly managed using
	sysctl's, loader tunables, and system calls.</p><p>In most cases, sysctl's and loader tunables of the same
	name modify the same parameters, and control behavior such as
	enforcement of protections relating to various kernel
	subsystems.  In addition, if MAC debugging support is compiled
	into the kernel, several counters will be maintained tracking
	label allocation.  It is generally advisable that
	per-subsystem enforcement controls not be used to control
	policy behavior in production environments, as they broadly
	impact the operation of all active policies.  Instead,
	per-policy controls should be preferred, as they provide
	greater granularity and greater operational consistency for
	policy modules.</p><p>Loading and unloading of policy modules is performed using
	the system module management system calls and other system
	interfaces, including boot loader variables; policy modules
	will have the opportunity to influence load and unload events,
	including preventing undesired unloading of the policy.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-synchronization"></a>6.5.3. Policy List Concurrency and Synchronization</h3></div></div></div><p>As the set of active policies may change at run-time, and
	the invocation of entry points is non-atomic, synchronization
	is required to prevent loading or unloading of policies while
	an entry point invocation is in progress, freezing the set of
	active policies for the duration.  This is accomplished by
	means of a framework busy count: whenever an entry point is
	entered, the busy count is incremented; whenever it is exited,
	the busy count is decremented.  While the busy count is
	elevated, policy list changes are not permitted, and threads
	attempting to modify the policy list will sleep until the list
	is not busy.  The busy count is protected by a mutex, and a
	condition variable is used to wake up sleepers waiting on
	policy list modifications.  One side effect of this
	synchronization model is that recursion into the MAC Framework
	from within a policy module is permitted, although not
	generally used.</p><p>Various optimizations are used to reduce the overhead of
	the busy count, including avoiding the full cost of
	incrementing and decrementing if the list is empty or contains
	only static entries (policies that are loaded before the
	system starts, and cannot be unloaded).  A compile-time option
	is also provided which prevents any change in the set of
	loaded policies at run-time, which eliminates the mutex
	locking costs associated with supporting dynamically loaded
	and unloaded policies as synchronization is no longer
	required.</p><p>As the MAC Framework is not permitted to block in some
	entry points, a normal sleep lock cannot be used; as a result,
	it is possible for the load or unload attempt to block for a
	substantial period of time waiting for the framework to become
	idle.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-label-synchronization"></a>6.5.4. Label Synchronization</h3></div></div></div><p>As kernel objects of interest may generally be accessed
	from more than one thread at a time, and simultaneous entry of
	more than one thread into the MAC Framework is permitted,
	security attribute storage maintained by the MAC Framework is
	carefully synchronized.  In general, existing kernel
	synchronization on kernel object data is used to protect MAC
	Framework security labels on the object: for example, MAC
	labels on sockets are protected using the existing socket
	mutex.  Likewise, semantics for concurrent access are
	generally identical to those of the container objects: for
	credentials, copy-on-write semantics are maintained for label
	contents as with the remainder of the credential structure.
	The MAC Framework asserts necessary locks on objects when
	invoked with an object reference.  Policy authors must be
	aware of these synchronization semantics, as they will
	sometimes limit the types of accesses permitted on labels: for
	example, when a read-only reference to a credential is passed
	to a policy via an entry point, only read operations are
	permitted on the label state attached to the
	credential.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-policy-synchronization"></a>6.5.5. Policy Synchronization and Concurrency</h3></div></div></div><p>Policy modules must be written to assume that many kernel
	threads may simultaneously enter one more policy entry points
	due to the parallel and preemptive nature of the FreeBSD
	kernel.  If the policy module makes use of mutable state, this
	may require the use of synchronization primitives within the
	policy to prevent inconsistent views on that state resulting
	in incorrect operation of the policy.  Policies will generally
	be able to make use of existing FreeBSD synchronization
	primitives for this purpose, including mutexes, sleep locks,
	condition variables, and counting semaphores.  However,
	policies should be written to employ these primitives
	carefully, respecting existing kernel lock orders, and
	recognizing that some entry points are not permitted to sleep,
	limiting the use of primitives in those entry points to
	mutexes and wakeup operations.</p><p>When policy modules call out to other kernel subsystems,
	they will generally need to release any in-policy locks in
	order to avoid violating the kernel lock order or risking lock
	recursion.  This will maintain policy locks as leaf locks in
	the global lock order, helping to avoid deadlock.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-registration"></a>6.5.6. Policy Registration</h3></div></div></div><p>The MAC Framework maintains two lists of active policies:
	a static list, and a dynamic list.  The lists differ only with
	regards to their locking semantics: an elevated reference
	count is not required to make use of the static list.  When
	kernel modules containing MAC Framework policies are loaded,
	the policy module will use <code class="literal">SYSINIT</code> to
	invoke a registration function; when a policy module is
	unloaded, <code class="literal">SYSINIT</code> will likewise invoke a
	de-registration function.  Registration may fail if a policy
	module is loaded more than once, if insufficient resources are
	available for the registration (for example, the policy might
	require labeling and insufficient labeling state might be
	available), or other policy prerequisites might not be met
	(some policies may only be loaded prior to boot).  Likewise,
	de-registration may fail if a policy is flagged as not
	unloadable.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-entrypoints"></a>6.5.7. Entry Points</h3></div></div></div><p>Kernel services interact with the MAC Framework in two
	ways: they invoke a series of APIs to notify the framework of
	relevant events, and they provide a policy-agnostic label
	structure pointer in security-relevant objects.  The label
	pointer is maintained by the MAC Framework via label
	management entry points, and permits the Framework to offer a
	labeling service to policy modules through relatively
	non-invasive changes to the kernel subsystem maintaining the
	object.  For example, label pointers have been added to
	processes, process credentials, sockets, pipes, vnodes, Mbufs,
	network interfaces, IP reassembly queues, and a variety of
	other security-relevant structures.  Kernel services also
	invoke the MAC Framework when they perform important security
	decisions, permitting policy modules to augment those
	decisions based on their own criteria (possibly including data
	stored in security labels).  Most of these security critical
	decisions will be explicit access control checks; however,
	some affect more general decision functions such as packet
	matching for sockets and label transition at program
	execution.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-composition"></a>6.5.8. Policy Composition</h3></div></div></div><p>When more than one policy module is loaded into the kernel
	at a time, the results of the policy modules will be composed
	by the framework using a composition operator.  This operator
	is currently hard-coded, and requires that all active policies
	must approve a request for it to return success.  As policies
	may return a variety of error conditions (success, access
	denied, object does not exist, ...), a precedence operator
	selects the resulting error from the set of errors returned by
	policies.  In general, errors indicating that an object does
	not exist will be preferred to errors indicating that access
	to an object is denied.  While it is not guaranteed that the
	resulting composition will be useful or secure, we have found
	that it is for many useful selections of policies.  For
	example, traditional trusted systems often ship with two or
	more policies using a similar composition.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-labels"></a>6.5.9. Labeling Support</h3></div></div></div><p>As many interesting access control extensions rely on
	security labels on objects, the MAC Framework provides a set
	of policy-agnostic label management system calls covering a
	variety of user-exposed objects.  Common label types include
	partition identifiers, sensitivity labels, integrity labels,
	compartments, domains, roles, and types.  By policy agnostic,
	we mean that policy modules are able to completely define the
	semantics of meta-data associated with an object.  Policy
	modules participate in the internalization and externalization
	of string-based labels provides by user applications, and can
	expose multiple label elements to applications if
	desired.</p><p>In-memory labels are stored in slab-allocated <code class="varname">struct label</code>, which consists of
	a fixed-length array of unions, each holding a <code class="literal">void
	  *</code> pointer and a <code class="literal">long</code>.  Policies
	registering for label storage will be assigned a "slot"
	identifier, which may be used to dereference the label
	storage.  The semantics of the storage are left entirely up to
	the policy module: modules are provided with a variety of
	entry points associated with the kernel object life cycle,
	including initialization, association/creation, and
	destruction.  Using these interfaces, it is possible to
	implement reference counting and other storage models.  Direct
	access to the object structure is generally not required by
	policy modules to retrieve a label, as the MAC Framework
	generally passes both a pointer to the object and a direct
	pointer to the object's label into entry points.  The primary
	exception to this rule is the process credential, which must
	be manually dereferenced to access the credential label.  This
	may change in future revisions of the MAC Framework.</p><p>Initialization entry points frequently include a sleeping
	disposition flag indicating whether or not an initialization
	is permitted to sleep; if sleeping is not permitted, a failure
	may be returned to cancel allocation of the label (and hence
	object).  This may occur, for example, in the network stack
	during interrupt handling, where sleeping is not permitted, or
	while the caller holds a mutex.  Due to the performance cost
	of maintaining labels on in-flight network packets (Mbufs),
	policies must specifically declare a requirement that Mbuf
	labels be allocated.  Dynamically loaded policies making use
	of labels must be able to handle the case where their init
	function has not been called on an object, as objects may
	already exist when the policy is loaded.  The MAC Framework
	guarantees that uninitialized label slots will hold a 0 or
	NULL value, which policies may use to detect uninitialized
	values.  However, as allocation of Mbuf labels is conditional,
	policies must also be able to handle a NULL label pointer for
	Mbufs if they have been loaded dynamically.</p><p>In the case of file system labels, special support is
	provided for the persistent storage of security labels in
	extended attributes.  Where available, extended attribute
	transactions are used to permit consistent compound updates of
	security labels on vnodes--currently this support is present
	only in the UFS2 file system.  Policy authors may choose to
	implement multilabel file system object labels using one (or
	more) extended attributes.  For efficiency reasons, the vnode
	label (<code class="literal">v_label</code>) is a cache of any on-disk
	label; policies are able to load values into the cache when
	the vnode is instantiated, and update the cache as needed.  As
	a result, the extended attribute need not be directly accessed
	with every access control check.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Currently, if a labeled policy permits dynamic
	  unloading, its state slot cannot be reclaimed, which places
	  a strict (and relatively low) bound on the number of
	  unload-reload operations for labeled policies.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-framework-kernel-arch-syscalls"></a>6.5.10. System Calls</h3></div></div></div><p>The MAC Framework implements a number of system calls:
	most of these calls support the policy-agnostic label
	retrieval and manipulation APIs exposed to user
	applications.</p><p>The label management calls accept a label description
	structure, <code class="varname">struct mac</code>,
	which contains a series of MAC label elements.  Each element
	contains a character string name, and character string value.
	Each policy will be given the chance to claim a particular
	element name, permitting policies to expose multiple
	independent elements if desired.  Policy modules perform the
	internalization and externalization between kernel labels and
	user-provided labels via entry points, permitting a variety of
	semantics.  Label management system calls are generally
	wrapped by user library functions to perform memory allocation
	and error handling, simplifying user applications that must
	manage labels.</p><p>The following MAC-related system calls are present in the
	FreeBSD kernel:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">mac_get_proc()</code> may be used to
	    retrieve the label of the current process.</p></li><li class="listitem"><p><code class="function">mac_set_proc()</code> may be used to
	    request a change in the label of the current
	    process.</p></li><li class="listitem"><p><code class="function">mac_get_fd()</code> may be used to
	    retrieve the label of an object (file, socket, pipe, ...)
	    referenced by a file descriptor.</p></li><li class="listitem"><p><code class="function">mac_get_file()</code> may be used to
	    retrieve the label of an object referenced by a file
	    system path.</p></li><li class="listitem"><p><code class="function">mac_set_fd()</code> may be used to
	    request a change in the label of an object (file, socket,
	    pipe, ...) referenced by a file descriptor.</p></li><li class="listitem"><p><code class="function">mac_set_file()</code> may be used to
	    request a change in the label of an object referenced by a
	    file system path.</p></li><li class="listitem"><p><code class="function">mac_syscall()</code> permits policy
	    modules to create new system calls without modifying the
	    system call table; it accepts a target policy name,
	    operation number, and opaque argument for use by the
	    policy.</p></li><li class="listitem"><p><code class="function">mac_get_pid()</code> may be used to
	    request the label of another process by process id.</p></li><li class="listitem"><p><code class="function">mac_get_link()</code> is identical to
	    <code class="function">mac_get_file()</code>, only it will not
	    follow a symbolic link if it is the final entry in the
	    path, so may be used to retrieve the label on a
	    symlink.</p></li><li class="listitem"><p><code class="function">mac_set_link()</code> is identical to
	    <code class="function">mac_set_file()</code>, only it will not
	    follow a symbolic link if it is the final entry in a path,
	    so may be used to manipulate the label on a
	    symlink.</p></li><li class="listitem"><p><code class="function">mac_execve()</code> is identical to the
	    <code class="function">execve()</code> system call, only it also
	    accepts a requested label to set the process label to when
	    beginning execution of a new program.  This change in
	    label on execution is referred to as a
	    "transition".</p></li><li class="listitem"><p><code class="function">mac_get_peer()</code>, actually
	    implemented via a socket option, retrieves the label of a
	    remote peer on a socket, if available.</p></li></ul></div><p>In addition to these system calls, the
	<code class="literal">SIOCSIGMAC</code> and
	<code class="literal">SIOCSIFMAC</code> network interface ioctls permit
	the labels on network interfaces to be retrieved and
	set.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-policy-architecture"></a>6.6. MAC Policy Architecture</h2></div></div></div><p>Security policies are either linked directly into the
      kernel, or compiled into loadable kernel modules that may be
      loaded at boot, or dynamically using the module loading system
      calls at runtime.  Policy modules interact with the system
      through a set of declared entry points, providing access to a
      stream of system events and permitting the policy to influence
      access control decisions.  Each policy contains a number of
      elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Optional configuration parameters for
	  policy.</p></li><li class="listitem"><p>Centralized implementation of the policy logic and
	  parameters.</p></li><li class="listitem"><p>Optional implementation of policy life cycle events,
	  such as initialization and destruction.</p></li><li class="listitem"><p>Optional support for initializing, maintaining, and
	  destroying labels on selected kernel
	  objects.</p></li><li class="listitem"><p>Optional support for user process inspection and
	  modification of labels on selected
	  objects.</p></li><li class="listitem"><p>Implementation of selected access control entry points
	  that are of interest to the policy.</p></li><li class="listitem"><p>Declaration of policy identity, module entry points, and
	  policy properties.</p></li></ul></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-policy-declaration"></a>6.6.1. Policy Declaration</h3></div></div></div><p>Modules may be declared using the
	<code class="function">MAC_POLICY_SET()</code> macro, which names the
	policy, provides a reference to the MAC entry point vector,
	provides load-time flags determining how the policy framework
	should handle the policy, and optionally requests the
	allocation of label state by the framework.</p><pre class="programlisting">static struct mac_policy_ops mac_<em class="replaceable"><code>policy</code></em>_ops =
{
        .mpo_destroy = mac_<em class="replaceable"><code>policy</code></em>_destroy,
        .mpo_init = mac_<em class="replaceable"><code>policy</code></em>_init,
        .mpo_init_bpfdesc_label = mac_<em class="replaceable"><code>policy</code></em>_init_bpfdesc_label,
        .mpo_init_cred_label = mac_<em class="replaceable"><code>policy</code></em>_init_label,
/* ... */
        .mpo_check_vnode_setutimes = mac_<em class="replaceable"><code>policy</code></em>_check_vnode_setutimes,
        .mpo_check_vnode_stat = mac_<em class="replaceable"><code>policy</code></em>_check_vnode_stat,
        .mpo_check_vnode_write = mac_<em class="replaceable"><code>policy</code></em>_check_vnode_write,
};</pre><p>The MAC policy entry point vector,
	<code class="varname">mac_<em class="replaceable"><code>policy</code></em>_ops</code>
	in this example, associates functions defined in the module
	with specific entry points.  A complete listing of available
	entry points and their prototypes may be found in the MAC
	entry point reference section.  Of specific interest during
	module registration are the <span class="symbol">.mpo_destroy</span> and
	<span class="symbol">.mpo_init</span> entry points.
	<span class="symbol">.mpo_init</span> will be invoked once a policy is
	successfully registered with the module framework but prior to
	any other entry points becoming active.  This permits the
	policy to perform any policy-specific allocation and
	initialization, such as initialization of any data or locks.
	<span class="symbol">.mpo_destroy</span> will be invoked when a policy
	module is unloaded to permit releasing of any allocated memory
	and destruction of locks.  Currently, these two entry points
	are invoked with the MAC policy list mutex held to prevent any
	other entry points from being invoked: this will be changed,
	but in the mean time, policies should be careful about what
	kernel primitives they invoke so as to avoid lock ordering or
	sleeping problems.</p><p>The policy declaration's module name field exists so that
	the module may be uniquely identified for the purposes of
	module dependencies.  An appropriate string should be
	selected.  The full string name of the policy is displayed to
	the user via the kernel log during load and unload events, and
	also exported when providing status information to userland
	processes.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-policy-flags"></a>6.6.2. Policy Flags</h3></div></div></div><p>The policy declaration flags field permits the module to
	provide the framework with information about its capabilities
	at the time the module is loaded.  Currently, three flags are
	defined:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">MPC_LOADTIME_FLAG_UNLOADOK</span></dt><dd><p>This flag indicates that the policy module may be
	      unloaded.  If this flag is not provided, then the policy
	      framework will reject requests to unload the module.
	      This flag might be used by modules that allocate label
	      state and are unable to free that state at
	      runtime.</p></dd><dt><span class="term">MPC_LOADTIME_FLAG_NOTLATE</span></dt><dd><p>This flag indicates that the policy module must be
	      loaded and initialized early in the boot process.  If
	      the flag is specified, attempts to register the module
	      following boot will be rejected.  The flag may be used
	      by policies that require pervasive labeling of all
	      system objects, and cannot handle objects that have not
	      been properly initialized by the policy.</p></dd><dt><span class="term">MPC_LOADTIME_FLAG_LABELMBUFS</span></dt><dd><p>This flag indicates that the policy module requires
	      labeling of Mbufs, and that memory should always be
	      allocated for the storage of Mbuf labels.  By default,
	      the MAC Framework will not allocate label storage for
	      Mbufs unless at least one loaded policy has this flag
	      set.  This measurably improves network performance when
	      policies do not require Mbuf labeling.  A kernel option,
	      <code class="literal">MAC_ALWAYS_LABEL_MBUF</code>, exists to
	      force the MAC Framework to allocate Mbuf label storage
	      regardless of the setting of this flag, and may be
	      useful in some environments.</p></dd></dl></div><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Policies using the
	  <code class="literal">MPC_LOADTIME_FLAG_LABELMBUFS</code> without the
	  <code class="literal">MPC_LOADTIME_FLAG_NOTLATE</code> flag set must
	  be able to correctly handle <code class="literal">NULL</code> Mbuf
	  label pointers passed into entry points.  This is necessary
	  as in-flight Mbufs without label storage may persist after a
	  policy enabling Mbuf labeling has been loaded.  If a policy
	  is loaded before the network subsystem is active (i.e., the
	  policy is not being loaded late), then all Mbufs are
	  guaranteed to have label storage.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-policy-entry-points"></a>6.6.3. Policy Entry Points</h3></div></div></div><p>Four classes of entry points are offered to policies
	registered with the framework: entry points associated with
	the registration and management of policies, entry points
	denoting initialization, creation, destruction, and other life
	cycle events for kernel objects, events associated with access
	control decisions that the policy module may influence, and
	calls associated with the management of labels on objects.  In
	addition, a <code class="function">mac_syscall()</code> entry point is
	provided so that policies may extend the kernel interface
	without registering new system calls.</p><p>Policy module writers should be aware of the kernel
	locking strategy, as well as what object locks are available
	during which entry points.  Writers should attempt to avoid
	deadlock scenarios by avoiding grabbing non-leaf locks inside
	of entry points, and also follow the locking protocol for
	object access and modification.  In particular, writers should
	be aware that while necessary locks to access objects and
	their labels are generally held, sufficient locks to modify an
	object or its label may not be present for all entry points.
	Locking information for arguments is documented in the MAC
	framework entry point document.</p><p>Policy entry points will pass a reference to the object
	label along with the object itself.  This permits labeled
	policies to be unaware of the internals of the object yet
	still make decisions based on the label.  The exception to
	this is the process credential, which is assumed to be
	understood by policies as a first class security object in the
	kernel.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-entry-point-reference"></a>6.7. MAC Policy Entry Point Reference</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-general"></a>6.7.1. General-Purpose Module Entry Points</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init"></a>6.7.1.1. <code class="function">mpo_init</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init</strong>(</code></td><td><var class="pdparam">conf</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mac_policy_conf
	      *<var class="pdparam">conf</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>conf</code></em></td><td>MAC policy definition</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Policy load event.  The policy list mutex is held, so
	  sleep operations cannot be performed, and calls out to other
	  kernel subsystems must be made with caution.  If potentially
	  sleeping memory allocations are required during policy
	  initialization, they should be made using a separate module
	  SYSINIT().</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mpo-destroy"></a>6.7.1.2. <code class="function">mpo_destroy</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy</strong>(</code></td><td><var class="pdparam">conf</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mac_policy_conf
	      *<var class="pdparam">conf</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>conf</code></em></td><td>MAC policy definition</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Policy load event.  The policy list mutex is held, so
	  caution should be applied.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-syscall"></a>6.7.1.3. <code class="function">mpo_syscall</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_syscall</strong>(</code></td><td><var class="pdparam">td</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">call</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">arg</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct thread
	      *<var class="pdparam">td</var></code>;<br /><code>int <var class="pdparam">call</var></code>;<br /><code>void *<var class="pdparam">arg</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>td</code></em></td><td>Calling thread</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>call</code></em></td><td>Policy-specific syscall number</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>arg</code></em></td><td>Pointer to syscall arguments</td><td class="auto-generated"> </td></tr></tbody></table></div><p>This entry point provides a policy-multiplexed system
	  call so that policies may provide additional services to
	  user processes without registering specific system calls.
	  The policy name provided during registration is used to
	  demux calls from userland, and the arguments will be
	  forwarded to this entry point.  When implementing new
	  services, security modules should be sure to invoke
	  appropriate access control checks from the MAC framework as
	  needed.  For example, if a policy implements an augmented
	  signal functionality, it should call the necessary signal
	  access control checks to invoke the MAC framework and other
	  registered policies.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Modules must currently perform the
	    <code class="function">copyin()</code> of the syscall data on their
	    own.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-thread-userret"></a>6.7.1.4. <code class="function">mpo_thread_userret</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_thread_userret</strong>(</code></td><td><var class="pdparam">td</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct thread
	      *<var class="pdparam">td</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>td</code></em></td><td>Returning thread</td><td class="auto-generated"> </td></tr></tbody></table></div><p>This entry point permits policy modules to perform
	  MAC-related events when a thread returns to user space, via
	  a system call return, trap return, or otherwise.  This is
	  required for policies that have floating process labels, as
	  it is not always possible to acquire the process lock at
	  arbitrary points in the stack during system call processing;
	  process labels might represent traditional authentication
	  data, process history information, or other data.  To employ
	  this mechanism, intended changes to the process credential
	  label may be stored in the <code class="literal">p_label</code>
	  protected by a per-policy spin lock, and then set the
	  per-thread <code class="literal">TDF_ASTPENDING</code> flag and
	  per-process <code class="literal">PS_MACPENDM</code> flag to schedule
	  a call to the userret entry point.  From this entry point,
	  the policy may create a replacement credential with less
	  concern about the locking context.  Policy writers are
	  cautioned that event ordering relating to scheduling an AST
	  and the AST being performed may be complex and interlaced in
	  multithreaded applications.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-label-ops"></a>6.7.2. Label Operations</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-bpfdesc"></a>6.7.2.1. <code class="function">mpo_init_bpfdesc_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_bpfdesc_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to apply</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated bpfdesc
	  (BPF descriptor).  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-cred-label"></a>6.7.2.2. <code class="function">mpo_init_cred_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_cred_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to initialize</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label for a newly instantiated user
	  credential.  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-devfsdirent"></a>6.7.2.3. <code class="function">mpo_init_devfsdirent_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_devfsdirent_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to apply</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated devfs
	  entry.  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-ifnet"></a>6.7.2.4. <code class="function">mpo_init_ifnet_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_ifnet_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to apply</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated network
	  interface.  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-ipq"></a>6.7.2.5. <code class="function">mpo_init_ipq_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_ipq_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">flag</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">flag</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to apply</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>flag</code></em></td><td>Sleeping/non-sleeping <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a>; see
		  below</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated IP fragment
	  reassembly queue.  The <em class="parameter"><code>flag</code></em> field may
	  be one of <span class="symbol">M_WAITOK</span> and
	  <span class="symbol">M_NOWAIT</span>, and should be employed to avoid
	  performing a sleeping <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> during this
	  initialization call.  IP fragment reassembly queue
	  allocation frequently occurs in performance sensitive
	  environments, and the implementation should be careful to
	  avoid sleeping or long-lived operations.  This entry point
	  is permitted to fail resulting in the failure to allocate
	  the IP fragment reassembly queue.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-mbuf"></a>6.7.2.6. <code class="function">mpo_init_mbuf_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_mbuf_label</strong>(</code></td><td><var class="pdparam">flag</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int <var class="pdparam">flag</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>flag</code></em></td><td>Sleeping/non-sleeping <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a>; see
		  below</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label to initialize</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated mbuf packet
	  header (<em class="parameter"><code>mbuf</code></em>).  The
	  <em class="parameter"><code>flag</code></em> field may be one of
	  <span class="symbol">M_WAITOK</span> and <span class="symbol">M_NOWAIT</span>, and
	  should be employed to avoid performing a sleeping
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> during this initialization call.  Mbuf
	  allocation frequently occurs in performance sensitive
	  environments, and the implementation should be careful to
	  avoid sleeping or long-lived operations.  This entry point
	  is permitted to fail resulting in the failure to allocate
	  the mbuf header.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-mount"></a>6.7.2.7. <code class="function">mpo_init_mount_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_mount_label</strong>(</code></td><td><var class="pdparam">mntlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">mntlabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">fslabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mntlabel</code></em></td><td>Policy label to be initialized for the mount
		  itself</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>Policy label to be initialized for the file
		  system</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the labels on a newly instantiated mount
	  point.  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-mount-fs-label"></a>6.7.2.8. <code class="function">mpo_init_mount_fs_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_mount_fs_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be initialized</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly mounted file system.
	  Sleeping is permitted</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-pipe-label"></a>6.7.2.9. <code class="function">mpo_init_pipe_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_pipe_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct
	      label*<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize a label for a newly instantiated pipe.
	  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-socket"></a>6.7.2.10. <code class="function">mpo_init_socket_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_socket_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">flag</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">flag</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to initialize</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>flag</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> flags</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize a label for a newly instantiated socket.  The
	  <em class="parameter"><code>flag</code></em> field may be one of
	  <span class="symbol">M_WAITOK</span> and <span class="symbol">M_NOWAIT</span>, and
	  should be employed to avoid performing a sleeping
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> during this initialization call.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-socket-peer-label"></a>6.7.2.11. <code class="function">mpo_init_socket_peer_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_socket_peer_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">flag</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">flag</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to initialize</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>flag</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> flags</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the peer label for a newly instantiated
	  socket.  The <em class="parameter"><code>flag</code></em> field may be one of
	  <span class="symbol">M_WAITOK</span> and <span class="symbol">M_NOWAIT</span>, and
	  should be employed to avoid performing a sleeping
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> during this initialization call.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-proc-label"></a>6.7.2.12. <code class="function">mpo_init_proc_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_proc_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to initialize</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label for a newly instantiated process.
	  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-init-vnode"></a>6.7.2.13. <code class="function">mpo_init_vnode_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_init_vnode_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>New label to initialize</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Initialize the label on a newly instantiated vnode.
	  Sleeping is permitted.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-bpfdesc"></a>6.7.2.14. <code class="function">mpo_destroy_bpfdesc_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_bpfdesc_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>bpfdesc label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a BPF descriptor.  In this entry
	  point a policy should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-cred"></a>6.7.2.15. <code class="function">mpo_destroy_cred_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_cred_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a credential.  In this entry point,
	  a policy module should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-devfsdirent"></a>6.7.2.16. <code class="function">mpo_destroy_devfsdirent_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_devfsdirent_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a devfs entry.  In this entry
	  point, a policy module should free any internal storage
	  associated with <em class="parameter"><code>label</code></em> so that it may
	  be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-ifnet-label"></a>6.7.2.17. <code class="function">mpo_destroy_ifnet_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_ifnet_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a removed interface.  In this entry
	  point, a policy module should free any internal storage
	  associated with <em class="parameter"><code>label</code></em> so that it may
	  be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-ipq-label"></a>6.7.2.18. <code class="function">mpo_destroy_ipq_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_ipq_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on an IP fragment queue.  In this
	  entry point, a policy module should free any internal
	  storage associated with <em class="parameter"><code>label</code></em> so that
	  it may be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-mbuf-label"></a>6.7.2.19. <code class="function">mpo_destroy_mbuf_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_mbuf_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on an mbuf header.  In this entry
	  point, a policy module should free any internal storage
	  associated with <em class="parameter"><code>label</code></em> so that it may
	  be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-mount-label"></a>6.7.2.20. <code class="function">mpo_destroy_mount_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_mount_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Mount point label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the labels on a mount point.  In this entry
	  point, a policy module should free the internal storage
	  associated with <em class="parameter"><code>mntlabel</code></em> so that they
	  may be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-mount"></a>6.7.2.21. <code class="function">mpo_destroy_mount_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_mount_label</strong>(</code></td><td><var class="pdparam">mntlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">mntlabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">fslabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mntlabel</code></em></td><td>Mount point label being destroyed</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>File system label being destroyed&gt;</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the labels on a mount point.  In this entry
	  point, a policy module should free the internal storage
	  associated with <em class="parameter"><code>mntlabel</code></em> and
	  <em class="parameter"><code>fslabel</code></em> so that they may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-socket"></a>6.7.2.22. <code class="function">mpo_destroy_socket_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_socket_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Socket label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a socket.  In this entry point, a
	  policy module should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-socket-peer-label"></a>6.7.2.23. <code class="function">mpo_destroy_socket_peer_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_socket_peer_label</strong>(</code></td><td><var class="pdparam">peerlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">peerlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>peerlabel</code></em></td><td>Socket peer label being destroyed</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the peer label on a socket.  In this entry
	  point, a policy module should free any internal storage
	  associated with <em class="parameter"><code>label</code></em> so that it may
	  be destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-pipe-label"></a>6.7.2.24. <code class="function">mpo_destroy_pipe_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_pipe_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Pipe label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a pipe.  In this entry point, a
	  policy module should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-proc-label"></a>6.7.2.25. <code class="function">mpo_destroy_proc_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_proc_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Process label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a process.  In this entry point, a
	  policy module should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-destroy-vnode-label"></a>6.7.2.26. <code class="function">mpo_destroy_vnode_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_destroy_vnode_label</strong>(</code></td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Process label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Destroy the label on a vnode.  In this entry point, a
	  policy module should free any internal storage associated
	  with <em class="parameter"><code>label</code></em> so that it may be
	  destroyed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-copy-mbuf-label"></a>6.7.2.27. <code class="function">mpo_copy_mbuf_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_copy_mbuf_label</strong>(</code></td><td><var class="pdparam">src</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dest</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">src</var></code>;<br /><code>struct label
	      *<var class="pdparam">dest</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>src</code></em></td><td>Source label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dest</code></em></td><td>Destination label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Copy the label information in <em class="parameter"><code>src</code></em>
	  into <em class="parameter"><code>dest</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-copy-pipe-label"></a>6.7.2.28. <code class="function">mpo_copy_pipe_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_copy_pipe_label</strong>(</code></td><td><var class="pdparam">src</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dest</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">src</var></code>;<br /><code>struct label
	      *<var class="pdparam">dest</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>src</code></em></td><td>Source label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dest</code></em></td><td>Destination label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Copy the label information in <em class="parameter"><code>src</code></em>
	  into <em class="parameter"><code>dest</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-copy-vnode-label"></a>6.7.2.29. <code class="function">mpo_copy_vnode_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_copy_vnode_label</strong>(</code></td><td><var class="pdparam">src</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dest</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label
	      *<var class="pdparam">src</var></code>;<br /><code>struct label
	      *<var class="pdparam">dest</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>src</code></em></td><td>Source label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dest</code></em></td><td>Destination label</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Copy the label information in <em class="parameter"><code>src</code></em>
	  into <em class="parameter"><code>dest</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-cred-label"></a>6.7.2.30. <code class="function">mpo_externalize_cred_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_cred_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-ifnet-label"></a>6.7.2.31. <code class="function">mpo_externalize_ifnet_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_ifnet_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-pipe-label"></a>6.7.2.32. <code class="function">mpo_externalize_pipe_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_pipe_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-socket-label"></a>6.7.2.33. <code class="function">mpo_externalize_socket_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_socket_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-socket-peer-label"></a>6.7.2.34. <code class="function">mpo_externalize_socket_peer_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_socket_peer_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-externalize-vnode-label"></a>6.7.2.35. <code class="function">mpo_externalize_vnode_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_externalize_vnode_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sb</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">*claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>struct sbuf *<var class="pdparam">sb</var></code>;<br /><code>int <var class="pdparam">*claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be externalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sb</code></em></td><td>String buffer to be filled with a text representation of
	label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when <em class="parameter"><code>element_data</code></em>
	can be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an externalized label based on the label structure passed.
    An externalized label consists of a text representation of the label
    contents that can be used with userland applications and read by the
    user.  Currently, all policies' <code class="function">externalize</code> entry
    points will be called, so the implementation should check the contents
    of <em class="parameter"><code>element_name</code></em> before attempting to fill in
    <em class="parameter"><code>sb</code></em>.  If
    <em class="parameter"><code>element_name</code></em> does not match the name of your
    policy, simply return <span class="returnvalue">0</span>.  Only return nonzero
    if an error occurs while externalizing the label data.  Once the policy
    fills in <em class="parameter"><code>element_data</code></em>, <code class="varname">*claimed</code>
    should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-internalize-cred-label"></a>6.7.2.36. <code class="function">mpo_internalize_cred_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_internalize_cred_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>char *<var class="pdparam">element_data</var></code>;<br /><code>int *<var class="pdparam">claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_data</code></em></td><td>Text data to be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when data can be successfully
	internalized.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an internal label structure based on externalized label data
    in text format.  Currently, all policies' <code class="function">internalize</code>
    entry points are called when internalization is requested, so the
    implementation should compare the contents of
    <em class="parameter"><code>element_name</code></em> to its own name in order to be sure
    it should be internalizing the data in <em class="parameter"><code>element_data</code></em>.
    Just as in the <code class="function">externalize</code> entry points, the entry
    point should return <span class="returnvalue">0</span> if
    <em class="parameter"><code>element_name</code></em> does not match its own name, or when
    data can successfully be internalized, in which case
    <code class="varname">*claimed</code> should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-internalize-ifnet-label"></a>6.7.2.37. <code class="function">mpo_internalize_ifnet_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_internalize_ifnet_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>char *<var class="pdparam">element_data</var></code>;<br /><code>int *<var class="pdparam">claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_data</code></em></td><td>Text data to be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when data can be successfully
	internalized.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an internal label structure based on externalized label data
    in text format.  Currently, all policies' <code class="function">internalize</code>
    entry points are called when internalization is requested, so the
    implementation should compare the contents of
    <em class="parameter"><code>element_name</code></em> to its own name in order to be sure
    it should be internalizing the data in <em class="parameter"><code>element_data</code></em>.
    Just as in the <code class="function">externalize</code> entry points, the entry
    point should return <span class="returnvalue">0</span> if
    <em class="parameter"><code>element_name</code></em> does not match its own name, or when
    data can successfully be internalized, in which case
    <code class="varname">*claimed</code> should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-internalize-pipe-label"></a>6.7.2.38. <code class="function">mpo_internalize_pipe_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_internalize_pipe_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>char *<var class="pdparam">element_data</var></code>;<br /><code>int *<var class="pdparam">claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_data</code></em></td><td>Text data to be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when data can be successfully
	internalized.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an internal label structure based on externalized label data
    in text format.  Currently, all policies' <code class="function">internalize</code>
    entry points are called when internalization is requested, so the
    implementation should compare the contents of
    <em class="parameter"><code>element_name</code></em> to its own name in order to be sure
    it should be internalizing the data in <em class="parameter"><code>element_data</code></em>.
    Just as in the <code class="function">externalize</code> entry points, the entry
    point should return <span class="returnvalue">0</span> if
    <em class="parameter"><code>element_name</code></em> does not match its own name, or when
    data can successfully be internalized, in which case
    <code class="varname">*claimed</code> should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-internalize-socket-label"></a>6.7.2.39. <code class="function">mpo_internalize_socket_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_internalize_socket_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>char *<var class="pdparam">element_data</var></code>;<br /><code>int *<var class="pdparam">claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_data</code></em></td><td>Text data to be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when data can be successfully
	internalized.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an internal label structure based on externalized label data
    in text format.  Currently, all policies' <code class="function">internalize</code>
    entry points are called when internalization is requested, so the
    implementation should compare the contents of
    <em class="parameter"><code>element_name</code></em> to its own name in order to be sure
    it should be internalizing the data in <em class="parameter"><code>element_data</code></em>.
    Just as in the <code class="function">externalize</code> entry points, the entry
    point should return <span class="returnvalue">0</span> if
    <em class="parameter"><code>element_name</code></em> does not match its own name, or when
    data can successfully be internalized, in which case
    <code class="varname">*claimed</code> should be incremented.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-internalize-vnode-label"></a>6.7.2.40. <code class="function">mpo_internalize_vnode_label</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_internalize_vnode_label</strong>(</code></td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">element_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">claimed</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct label *<var class="pdparam">label</var></code>;<br /><code>char *<var class="pdparam">element_name</var></code>;<br /><code>char *<var class="pdparam">element_data</var></code>;<br /><code>int *<var class="pdparam">claimed</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>label</code></em></td><td>Label to be filled in</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_name</code></em></td><td>Name of the policy whose label should be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>element_data</code></em></td><td>Text data to be internalized</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>claimed</code></em></td><td>Should be incremented when data can be successfully
	internalized.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Produce an internal label structure based on externalized label data
    in text format.  Currently, all policies' <code class="function">internalize</code>
    entry points are called when internalization is requested, so the
    implementation should compare the contents of
    <em class="parameter"><code>element_name</code></em> to its own name in order to be sure
    it should be internalizing the data in <em class="parameter"><code>element_data</code></em>.
    Just as in the <code class="function">externalize</code> entry points, the entry
    point should return <span class="returnvalue">0</span> if
    <em class="parameter"><code>element_name</code></em> does not match its own name, or when
    data can successfully be internalized, in which case
    <code class="varname">*claimed</code> should be incremented.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-label-events"></a>6.7.3. Label Events</h3></div></div></div><p>This class of entry points is used by the MAC framework to
	permit policies to maintain label information on kernel
	objects.  For each labeled kernel object of interest to a MAC
	policy, entry points may be registered for relevant life cycle
	events.  All objects implement initialization, creation, and
	destruction hooks.  Some objects will also implement
	relabeling, allowing user processes to change the labels on
	objects.  Some objects will also implement object-specific
	events, such as label events associated with IP reassembly.  A
	typical labeled object will have the following life cycle of
	entry points:</p><pre class="programlisting">Label initialization          o
(object-specific wait)         \
Label creation                  o
                                 \
Relabel events,                   o--&lt;--.
Various object-specific,          |     |
Access control events             ~--&gt;--o
                                         \
Label destruction                         o</pre><p>Label initialization permits policies to allocate memory
	and set initial values for labels without context for the use
	of the object.  The label slot allocated to a policy will be
	zeroed by default, so some policies may not need to perform
	initialization.</p><p>Label creation occurs when the kernel structure is
	associated with an actual kernel object.  For example, Mbufs
	may be allocated and remain unused in a pool until they are
	required.  mbuf allocation causes label initialization on the
	mbuf to take place, but mbuf creation occurs when the mbuf is
	associated with a datagram.  Typically, context will be
	provided for a creation event, including the circumstances of
	the creation, and labels of other relevant objects in the
	creation process.  For example, when an mbuf is created from a
	socket, the socket and its label will be presented to
	registered policies in addition to the new mbuf and its label.
	Memory allocation in creation events is discouraged, as it may
	occur in performance sensitive ports of the kernel; in
	addition, creation calls are not permitted to fail so a
	failure to allocate memory cannot be reported.</p><p>Object specific events do not generally fall into the
	other broad classes of label events, but will generally
	provide an opportunity to modify or update the label on an
	object based on additional context.  For example, the label on
	an IP fragment reassembly queue may be updated during the
	<span class="symbol">MAC_UPDATE_IPQ</span> entry point as a result of the
	acceptance of an additional mbuf to that queue.</p><p>Access control events are discussed in detail in the
	following section.</p><p>Label destruction permits policies to release storage or
	state associated with a label during its association with an
	object so that the kernel data structures supporting the
	object may be reused or released.</p><p>In addition to labels associated with specific kernel
	objects, an additional class of labels exists: temporary
	labels.  These labels are used to store update information
	submitted by user processes.  These labels are initialized and
	destroyed as with other label types, but the creation event is
	<span class="symbol">MAC_INTERNALIZE</span>, which accepts a user label
	to be converted to an in-kernel representation.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-fs-label-event-ops"></a>6.7.3.1. File System Object Labeling Event Operations</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-associate-vnode-devfs"></a>6.7.3.1.1. <code class="function">mpo_associate_vnode_devfs</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_associate_vnode_devfs</strong>(</code></td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">de</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">delabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;<br /><code>struct devfs_dirent
		*<var class="pdparam">de</var></code>;<br /><code>struct label
		*<var class="pdparam">delabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mp</code></em></td><td>Devfs mount point</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>Devfs file system label
		    (<code class="varname">mp-&gt;mnt_fslabel</code>)</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>de</code></em></td><td>Devfs directory entry</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>delabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>de</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>vnode associated with
		    <em class="parameter"><code>de</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Fill in the label (<em class="parameter"><code>vlabel</code></em>) for
	    a newly created devfs vnode based on the devfs directory
	    entry passed in <em class="parameter"><code>de</code></em> and its
	    label.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-associate-vnode-extattr"></a>6.7.3.1.2. <code class="function">mpo_associate_vnode_extattr</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
		<strong class="fsfunc">mpo_associate_vnode_extattr</strong>(</code></td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mp</code></em></td><td>File system mount point</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>File system label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Vnode to label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Attempt to retrieve the label for
	    <em class="parameter"><code>vp</code></em> from the file system extended
	    attributes.  Upon success, the value <code class="literal">0</code>
	    is returned.  Should extended attribute retrieval not be
	    supported, an accepted fallback is to copy
	    <em class="parameter"><code>fslabel</code></em> into
	    <em class="parameter"><code>vlabel</code></em>.  In the event of an error,
	    an appropriate value for <code class="varname">errno</code> should
	    be returned.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-associate-vnode-singlelabel"></a>6.7.3.1.3. <code class="function">mpo_associate_vnode_singlelabel</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_associate_vnode_singlelabel</strong>(</code></td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mp</code></em></td><td>File system mount point</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>File system label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Vnode to label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>On non-multilabel file systems, this entry point is
	    called to set the policy label for
	    <em class="parameter"><code>vp</code></em> based on the file system label,
	    <em class="parameter"><code>fslabel</code></em>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-devfs-device"></a>6.7.3.1.4. <code class="function">mpo_create_devfs_device</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_devfs_device</strong>(</code></td><td><var class="pdparam">dev</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">devfs_dirent</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>dev_t <var class="pdparam">dev</var></code>;<br /><code>struct devfs_dirent
		*<var class="pdparam">devfs_dirent</var></code>;<br /><code>struct label
		*<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>dev</code></em></td><td>Device corresponding with
		    <em class="parameter"><code>devfs_dirent</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>devfs_dirent</code></em></td><td>Devfs directory entry to be labeled.</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Label for <em class="parameter"><code>devfs_dirent</code></em>
		    to be filled in.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Fill out the label on a devfs_dirent being created for
	    the passed device.  This call will be made when the device
	    file system is mounted, regenerated, or a new device is
	    made available.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-devfs-directory"></a>6.7.3.1.5. <code class="function">mpo_create_devfs_directory</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_devfs_directory</strong>(</code></td><td><var class="pdparam">dirname</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dirnamelen</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">devfs_dirent</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char
		*<var class="pdparam">dirname</var></code>;<br /><code>int
		<var class="pdparam">dirnamelen</var></code>;<br /><code>struct devfs_dirent
		*<var class="pdparam">devfs_dirent</var></code>;<br /><code>struct label
		*<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>dirname</code></em></td><td>Name of directory being created</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>namelen</code></em></td><td>Length of string
		    <em class="parameter"><code>dirname</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>devfs_dirent</code></em></td><td>Devfs directory entry for directory being
		    created.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Fill out the label on a devfs_dirent being created for
	    the passed directory.  This call will be made when the
	    device file system is mounted, regenerated, or a new
	    device requiring a specific directory hierarchy is made
	    available.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-devfs-symlink"></a>6.7.3.1.6. <code class="function">mpo_create_devfs_symlink</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_devfs_symlink</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dd</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ddlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">de</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">delabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct devfs_dirent
		*<var class="pdparam">dd</var></code>;<br /><code>struct label
		*<var class="pdparam">ddlabel</var></code>;<br /><code>struct devfs_dirent
		*<var class="pdparam">de</var></code>;<br /><code>struct label
		*<var class="pdparam">delabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mp</code></em></td><td>Devfs mount point</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dd</code></em></td><td>Link destination</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ddlabel</code></em></td><td>Label associated with
		    <em class="parameter"><code>dd</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>de</code></em></td><td>Symlink entry</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>delabel</code></em></td><td>Label associated with
		    <em class="parameter"><code>de</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Fill in the label (<em class="parameter"><code>delabel</code></em>) for
	    a newly created <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">devfs</span>(5)</span></a> symbolic link entry.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-vnode-extattr"></a>6.7.3.1.7. <code class="function">mpo_create_vnode_extattr</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
		<strong class="fsfunc">mpo_create_vnode_extattr</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">dvp</var></code>;<br /><code>struct label
		*<var class="pdparam">dlabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vlabel</var></code>;<br /><code>struct componentname
		*<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mount</code></em></td><td>File system mount point</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>File system label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Parent directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Label associated with
		    <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Newly created vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name for
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Write out the label for <em class="parameter"><code>vp</code></em> to
	    the appropriate extended attribute.  If the write
	    succeeds, fill in <em class="parameter"><code>vlabel</code></em> with the
	    label, and return <span class="returnvalue">0</span>.
	    Otherwise, return an appropriate error.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mount"></a>6.7.3.1.8. <code class="function">mpo_create_mount</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mount</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mnt</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct
		label *<var class="pdparam">mnt</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mp</code></em></td><td>Object; file system being mounted</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mntlabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>mp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fslabel</code></em></td><td>Policy label for the file system
		    <em class="parameter"><code>mp</code></em> mounts.</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Fill out the labels on the mount point being created
	    by the passed subject credential.  This call will be made
	    when a new file system is mounted.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-root-mount"></a>6.7.3.1.9. <code class="function">mpo_create_root_mount</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_root_mount</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mntlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fslabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct mount
		*<var class="pdparam">mp</var></code>;<br /><code>struct label
		*<var class="pdparam">mntlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">fslabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td colspan="3">See <a class="xref" href="#mac-mpo-create-mount" title="6.7.3.1.8. mpo_create_mount">Section 6.7.3.1.8, &#8220;<code class="function">mpo_create_mount</code>&#8221;</a>.</td></tr></tbody></table></div><p>Fill out the labels on the mount point being created
	    by the passed subject credential.  This call will be made
	    when the root file system is mounted, after
	    mpo_create_mount;.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-relabel-vnode"></a>6.7.3.1.10. <code class="function">mpo_relabel_vnode</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_relabel_vnode</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vnodelabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vnodelabel</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>vnode to relabel</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vnodelabel</code></em></td><td>Existing policy label for
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>New, possibly partial label to replace
		    <em class="parameter"><code>vnodelabel</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label on the passed vnode given the passed
	    update vnode label and the passed subject
	    credential.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-setlabel-vnode-extattr"></a>6.7.3.1.11. <code class="function">mpo_setlabel_vnode_extattr</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
		<strong class="fsfunc">mpo_setlabel_vnode_extattr</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">intlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">intlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Vnode for which the label is being
		    written</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>intlabel</code></em></td><td>Label to write out</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Write out the policy from
	    <em class="parameter"><code>intlabel</code></em> to an extended attribute.
	    This is called from
	    <code class="function">vop_stdcreatevnode_ea</code>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-update-devfsdirent"></a>6.7.3.1.12. <code class="function">mpo_update_devfsdirent</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_update_devfsdirent</strong>(</code></td><td><var class="pdparam">devfs_dirent</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">direntlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vnodelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct devfs_dirent
		*<var class="pdparam">devfs_dirent</var></code>;<br /><code>struct label
		*<var class="pdparam">direntlabel</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vnodelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>devfs_dirent</code></em></td><td>Object; devfs directory entry</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>direntlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>devfs_dirent</code></em> to be
		    updated.</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Parent vnode</td><td>Locked</td></tr><tr><td><em class="parameter"><code>vnodelabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the <em class="parameter"><code>devfs_dirent</code></em> label
	    from the passed devfs vnode label.  This call will be made
	    when a devfs vnode has been successfully relabeled to
	    commit the label change such that it lasts even if the
	    vnode is recycled.  It will also be made when a symlink is
	    created in devfs, following a call to
	    <code class="function">mac_vnode_create_from_vnode</code> to
	    initialize the vnode label.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-ipc-label-ops"></a>6.7.3.2. IPC Object Labeling Event Operations</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-from-socket"></a>6.7.3.2.1. <code class="function">mpo_create_mbuf_from_socket</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_from_socket</strong>(</code></td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">m</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct socket
		*<var class="pdparam">so</var></code>;<br /><code>struct label
		*<var class="pdparam">socketlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">m</var></code>;<br /><code>struct label
		*<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>socket</code></em></td><td>Socket</td><td>Socket locking WIP</td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>m</code></em></td><td>Object; mbuf</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label to fill in for
		    <em class="parameter"><code>m</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created mbuf header from the
	    passed socket label.  This call is made when a new
	    datagram or message is generated by the socket and stored
	    in the passed mbuf.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-pipe"></a>6.7.3.2.2. <code class="function">mpo_create_pipe</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_pipe</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct pipe
		*<var class="pdparam">pipe</var></code>;<br /><code>struct label
		*<var class="pdparam">pipelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created pipe from the passed
	    subject credential.  This call is made when a new pipe is
	    created.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-socket"></a>6.7.3.2.3. <code class="function">mpo_create_socket</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_socket</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct socket
		*<var class="pdparam">so</var></code>;<br /><code>struct label
		*<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>so</code></em></td><td>Object; socket to label</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Label to fill in for
		    <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created socket from the
	    passed subject credential.  This call is made when a
	    socket is created.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-socket-from-socket"></a>6.7.3.2.4. <code class="function">mpo_create_socket_from_socket</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_socket_from_socket</strong>(</code></td><td><var class="pdparam">oldsocket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldsocketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newsocket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newsocketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct socket
		*<var class="pdparam">oldsocket</var></code>;<br /><code>struct label
		*<var class="pdparam">oldsocketlabel</var></code>;<br /><code>struct socket
		*<var class="pdparam">newsocket</var></code>;<br /><code>struct label
		*<var class="pdparam">newsocketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>oldsocket</code></em></td><td>Listening socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldsocketlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>oldsocket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newsocket</code></em></td><td>New socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newsocketlabel</code></em></td><td>Policy label associated with
		    <em class="parameter"><code>newsocketlabel</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Label a socket, <em class="parameter"><code>newsocket</code></em>,
	    newly <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">accept</span>(2)</span></a>ed, based on the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=listen&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">listen</span>(2)</span></a>
	    socket, <em class="parameter"><code>oldsocket</code></em>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-relabel-pipe"></a>6.7.3.2.5. <code class="function">mpo_relabel_pipe</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_relabel_pipe</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct pipe
		*<var class="pdparam">pipe</var></code>;<br /><code>struct label
		*<var class="pdparam">oldlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldlabel</code></em></td><td>Current policy label associated with
		    <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Policy label update to apply to
		    <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Apply a new label, <em class="parameter"><code>newlabel</code></em>, to
	    <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-relabel-socket"></a>6.7.3.2.6. <code class="function">mpo_relabel_socket</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_relabel_socket</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct socket
		*<var class="pdparam">so</var></code>;<br /><code>struct label
		*<var class="pdparam">oldlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>so</code></em></td><td>Object; socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldlabel</code></em></td><td>Current label for
		    <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update for
		    <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label on a socket from the passed socket
	    label update.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mpo-set-socket-peer-from-mbuf"></a>6.7.3.2.7. <code class="function">mpo_set_socket_peer_from_mbuf</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_set_socket_peer_from_mbuf</strong>(</code></td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">mbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">mbuflabel</var></code>;<br /><code>struct label
		*<var class="pdparam">oldlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mbuf</code></em></td><td>First datagram received over socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Label for <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldlabel</code></em></td><td>Current label for the socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Policy label to be filled out for the
		    socket</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the peer label on a stream socket from the passed
	    mbuf label.  This call will be made when the first
	    datagram is received by the stream socket, with the
	    exception of Unix domain sockets.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-set-socket-peer-from-socket"></a>6.7.3.2.8. <code class="function">mpo_set_socket_peer_from_socket</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_set_socket_peer_from_socket</strong>(</code></td><td><var class="pdparam">oldsocket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldsocketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newsocket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newsocketpeerlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct socket
		*<var class="pdparam">oldsocket</var></code>;<br /><code>struct label
		*<var class="pdparam">oldsocketlabel</var></code>;<br /><code>struct socket
		*<var class="pdparam">newsocket</var></code>;<br /><code>struct label
		*<var class="pdparam">newsocketpeerlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>oldsocket</code></em></td><td>Local socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldsocketlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>oldsocket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newsocket</code></em></td><td>Peer socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newsocketpeerlabel</code></em></td><td>Policy label to fill in for
		    <em class="parameter"><code>newsocket</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the peer label on a stream UNIX domain socket from
	    the passed remote socket endpoint.  This call will be made
	    when the socket pair is connected, and will be made for
	    both endpoints.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-net-labeling-event-ops"></a>6.7.3.3. Network Object Labeling Event Operations</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-bpfdesc"></a>6.7.3.3.1. <code class="function">mpo_create_bpfdesc</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_bpfdesc</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bpf_d</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bpflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct bpf_d
		*<var class="pdparam">bpf_d</var></code>;<br /><code>struct label
		*<var class="pdparam">bpflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>bpf_d</code></em></td><td>Object; bpf descriptor</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>bpf</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>bpf_d</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created BPF descriptor from
	    the passed subject credential.  This call will be made
	    when a BPF device node is opened by a process with the
	    passed subject credential.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-ifnet"></a>6.7.3.3.2. <code class="function">mpo_create_ifnet</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_ifnet</strong>(</code></td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ifnet
		*<var class="pdparam">ifnet</var></code>;<br /><code>struct label
		*<var class="pdparam">ifnetlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label to fill in for
		    <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created interface.  This call
	    may be made when a new physical interface becomes
	    available to the system, or when a pseudo-interface is
	    instantiated during the boot or as a result of a user
	    action.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-ipq"></a>6.7.3.3.3. <code class="function">mpo_create_ipq</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_ipq</strong>(</code></td><td><var class="pdparam">fragment</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fragmentlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipq</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipqlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">fragment</var></code>;<br /><code>struct label
		*<var class="pdparam">fragmentlabel</var></code>;<br /><code>struct ipq
		*<var class="pdparam">ipq</var></code>;<br /><code>struct label
		*<var class="pdparam">ipqlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>fragment</code></em></td><td>First received IP fragment</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fragmentlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>fragment</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipq</code></em></td><td>IP reassembly queue to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipqlabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>ipq</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly created IP fragment
	    reassembly queue from the mbuf header of the first
	    received fragment.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-datagram-from-ipq"></a>6.7.3.3.4. <code class="function">mpo_create_datagram_from_ipq</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_create_datagram_from_ipq</strong>(</code></td><td><var class="pdparam">ipq</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipqlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">datagram</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">datagramlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ipq
		*<var class="pdparam">ipq</var></code>;<br /><code>struct label
		*<var class="pdparam">ipqlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">datagram</var></code>;<br /><code>struct label
		*<var class="pdparam">datagramlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>ipq</code></em></td><td>IP reassembly queue</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipqlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ipq</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>datagram</code></em></td><td>Datagram to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>datagramlabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>datagramlabel</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on a newly reassembled IP datagram from
	    the IP fragment reassembly queue from which it was
	    generated.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-fragment"></a>6.7.3.3.5. <code class="function">mpo_create_fragment</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_fragment</strong>(</code></td><td><var class="pdparam">datagram</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">datagramlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fragment</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fragmentlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">datagram</var></code>;<br /><code>struct label
		*<var class="pdparam">datagramlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">fragment</var></code>;<br /><code>struct label
		*<var class="pdparam">fragmentlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>datagram</code></em></td><td>Datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>datagramlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>datagram</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fragment</code></em></td><td>Fragment to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fragmentlabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>datagram</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created IP
	    fragment from the label on the mbuf header of the datagram
	    it was generate from.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-from-mbuf"></a>6.7.3.3.6. <code class="function">mpo_create_mbuf_from_mbuf</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_from_mbuf</strong>(</code></td><td><var class="pdparam">oldmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldmbuflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">oldmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">oldmbuflabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">newmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">newmbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>oldmbuf</code></em></td><td>Existing (source) mbuf</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldmbuflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>oldmbuf</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuf</code></em></td><td>New mbuf to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuflabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>newmbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram from the mbuf header of an existing datagram.
	    This call may be made in a number of situations, including
	    when an mbuf is re-allocated for alignment
	    purposes.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-linklayer"></a>6.7.3.3.7. <code class="function">mpo_create_mbuf_linklayer</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_linklayer</strong>(</code></td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ifnet
		*<var class="pdparam">ifnet</var></code>;<br /><code>struct label
		*<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">mbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuf</code></em></td><td>mbuf header for new datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram generated for the purposes of a link layer
	    response for the passed interface.  This call may be made
	    in a number of situations, including for ARP or ND6
	    responses in the IPv4 and IPv6 stacks.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-from-bpfdesc"></a>6.7.3.3.8. <code class="function">mpo_create_mbuf_from_bpfdesc</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_from_bpfdesc</strong>(</code></td><td><var class="pdparam">bpf_d</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bpflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct bpf_d
		*<var class="pdparam">bpf_d</var></code>;<br /><code>struct label
		*<var class="pdparam">bpflabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">mbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>bpf_d</code></em></td><td>BPF descriptor</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>bpflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>bpflabel</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuf</code></em></td><td>New mbuf to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label to fill in for
		    <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram generated using the passed BPF descriptor.  This
	    call is made when a write is performed to the BPF device
	    associated with the passed BPF descriptor.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-from-ifnet"></a>6.7.3.3.9. <code class="function">mpo_create_mbuf_from_ifnet</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_from_ifnet</strong>(</code></td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ifnet
		*<var class="pdparam">ifnet</var></code>;<br /><code>struct label
		*<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">mbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ifnetlabel</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuf</code></em></td><td>mbuf header for new datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram generated from the passed network
	    interface.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-multicast-encap"></a>6.7.3.3.10. <code class="function">mpo_create_mbuf_multicast_encap</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_multicast_encap</strong>(</code></td><td><var class="pdparam">oldmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldmbuflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">oldmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">oldmbuflabel</var></code>;<br /><code>struct ifnet
		*<var class="pdparam">ifnet</var></code>;<br /><code>struct label
		*<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">newmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">newmbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>oldmbuf</code></em></td><td>mbuf header for existing datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldmbuflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>oldmbuf</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuf</code></em></td><td>mbuf header to be labeled for new
		    datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuflabel</code></em></td><td>Policy label to be filled in for
		    <em class="parameter"><code>newmbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram generated from the existing passed datagram when
	    it is processed by the passed multicast encapsulation
	    interface.  This call is made when an mbuf is to be
	    delivered using the virtual interface.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-mbuf-netlayer"></a>6.7.3.3.11. <code class="function">mpo_create_mbuf_netlayer</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_mbuf_netlayer</strong>(</code></td><td><var class="pdparam">oldmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldmbuflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newmbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">oldmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">oldmbuflabel</var></code>;<br /><code>struct mbuf
		*<var class="pdparam">newmbuf</var></code>;<br /><code>struct label
		*<var class="pdparam">newmbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>oldmbuf</code></em></td><td>Received datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldmbuflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>oldmbuf</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuf</code></em></td><td>Newly created datagram</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newmbuflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>newmbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label on the mbuf header of a newly created
	    datagram generated by the IP stack in response to an
	    existing received datagram
	    (<em class="parameter"><code>oldmbuf</code></em>).  This call may be made
	    in a number of situations, including when responding to
	    ICMP request datagrams.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-fragment-match"></a>6.7.3.3.12. <code class="function">mpo_fragment_match</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
		<strong class="fsfunc">mpo_fragment_match</strong>(</code></td><td><var class="pdparam">fragment</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fragmentlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipq</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipqlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">fragment</var></code>;<br /><code>struct label
		*<var class="pdparam">fragmentlabel</var></code>;<br /><code>struct ipq
		*<var class="pdparam">ipq</var></code>;<br /><code>struct label
		*<var class="pdparam">ipqlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>fragment</code></em></td><td>IP datagram fragment</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>fragmentlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>fragment</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipq</code></em></td><td>IP fragment reassembly queue</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipqlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ipq</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether an mbuf header containing an IP
	    datagram (<em class="parameter"><code>fragment</code></em>) fragment
	    matches the label of the passed IP fragment reassembly
	    queue (<em class="parameter"><code>ipq</code></em>).  Return
	    (<span class="returnvalue">1</span>) for a successful match, or
	    (<span class="returnvalue">0</span>) for no match.  This call is
	    made when the IP stack attempts to find an existing
	    fragment reassembly queue for a newly received fragment;
	    if this fails, a new fragment reassembly queue may be
	    instantiated for the fragment.  Policies may use this
	    entry point to prevent the reassembly of otherwise
	    matching IP fragments if policy does not permit them to be
	    reassembled based on the label or other
	    information.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-ifnet-relabel"></a>6.7.3.3.13. <code class="function">mpo_relabel_ifnet</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_relabel_ifnet</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct ifnet
		*<var class="pdparam">ifnet</var></code>;<br /><code>struct label
		*<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Object; Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update to apply to
		    <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label of network interface,
	    <em class="parameter"><code>ifnet</code></em>, based on the passed update
	    label, <em class="parameter"><code>newlabel</code></em>, and the passed
	    subject credential, <em class="parameter"><code>cred</code></em>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-update-ipq"></a>6.7.3.3.14. <code class="function">mpo_update_ipq</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_update_ipq</strong>(</code></td><td><var class="pdparam">fragment</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fragmentlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipq</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ipqlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct mbuf
		*<var class="pdparam">fragment</var></code>;<br /><code>struct label
		*<var class="pdparam">fragmentlabel</var></code>;<br /><code>struct ipq
		*<var class="pdparam">ipq</var></code>;<br /><code>struct label
		*<var class="pdparam">ipqlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>mbuf</code></em></td><td>IP fragment</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipq</code></em></td><td>IP fragment reassembly queue</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ipqlabel</code></em></td><td>Policy label to be updated for
		    <em class="parameter"><code>ipq</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label on an IP fragment reassembly queue
	    (<em class="parameter"><code>ipq</code></em>) based on the acceptance of
	    the passed IP fragment mbuf header
	    (<em class="parameter"><code>mbuf</code></em>).</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-proc-labeling-event-ops"></a>6.7.3.4. Process Labeling Event Operations</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-cred"></a>6.7.3.4.1. <code class="function">mpo_create_cred</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_cred</strong>(</code></td><td><var class="pdparam">parent_cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">child_cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">parent_cred</var></code>;<br /><code>struct ucred
		*<var class="pdparam">child_cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>parent_cred</code></em></td><td>Parent subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>child_cred</code></em></td><td>Child subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Set the label of a newly created subject credential
	    from the passed subject credential.  This call will be
	    made when <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=crcopy&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">crcopy</span>(9)</span></a> is invoked on a newly created
	    <span class="type">struct ucred</span>.  This call should not be
	    confused with a process forking or creation event.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-execve-transition"></a>6.7.3.4.2. <code class="function">mpo_execve_transition</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_execve_transition</strong>(</code></td><td><var class="pdparam">old</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">new</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vnodelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">old</var></code>;<br /><code>struct ucred
		*<var class="pdparam">new</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vnodelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>old</code></em></td><td>Existing subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>new</code></em></td><td>New subject credential to be labeled</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>File to execute</td><td>Locked</td></tr><tr><td><em class="parameter"><code>vnodelabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label of a newly created subject credential
	    (<em class="parameter"><code>new</code></em>) from the passed existing
	    subject credential (<em class="parameter"><code>old</code></em>) based on a
	    label transition caused by executing the passed vnode
	    (<em class="parameter"><code>vp</code></em>).  This call occurs when a
	    process executes the passed vnode and one of the policies
	    returns a success from the
	    <code class="function">mpo_execve_will_transition</code> entry
	    point.  Policies may choose to implement this call simply
	    by invoking <code class="function">mpo_create_cred</code> and
	    passing the two subject credentials so as not to implement
	    a transitioning event.  Policies should not leave this
	    entry point unimplemented if they implement
	    <code class="function">mpo_create_cred</code>, even if they do not
	    implement
	    <code class="function">mpo_execve_will_transition</code>.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-execve-will-transition"></a>6.7.3.4.3. <code class="function">mpo_execve_will_transition</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
		<strong class="fsfunc">mpo_execve_will_transition</strong>(</code></td><td><var class="pdparam">old</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vnodelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">old</var></code>;<br /><code>struct vnode
		*<var class="pdparam">vp</var></code>;<br /><code>struct label
		*<var class="pdparam">vnodelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>old</code></em></td><td>Subject credential prior to
		    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a></td><td>Immutable</td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>File to execute</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vnodelabel</code></em></td><td>Policy label for
		    <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the policy will want to perform a
	    transition event as a result of the execution of the
	    passed vnode by the passed subject credential.  Return
	    <span class="returnvalue">1</span> if a transition is required,
	    <span class="returnvalue">0</span> if not.  Even if a policy
	    returns <span class="returnvalue">0</span>, it should behave
	    correctly in the presence of an unexpected invocation of
	    <code class="function">mpo_execve_transition</code>, as that call
	    may happen as a result of another policy requesting a
	    transition.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-proc0"></a>6.7.3.4.4. <code class="function">mpo_create_proc0</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_proc0</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential to be filled in</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Create the subject credential of process 0, the parent
	    of all kernel processes.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-create-proc1"></a>6.7.3.4.5. <code class="function">mpo_create_proc1</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_create_proc1</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential to be filled in</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Create the subject credential of process 1, the parent
	    of all user processes.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-relabel-cred"></a>6.7.3.4.6. <code class="function">mpo_relabel_cred</code></h5></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
		<strong class="fsfunc">mpo_relabel_cred</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
		*<var class="pdparam">cred</var></code>;<br /><code>struct label
		*<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update to apply to
		    <em class="parameter"><code>cred</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Update the label on a subject credential from the
	    passed update label.</p></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-access-control-checks"></a>6.7.4. Access Control Checks</h3></div></div></div><p>Access control entry points permit policy modules to
	influence access control decisions made by the kernel.
	Generally, although not always, arguments to an access control
	entry point will include one or more authorizing credentials,
	information (possibly including a label) for any other objects
	involved in the operation.  An access control entry point may
	return 0 to permit the operation, or an <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=errno&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">errno</span>(2)</span></a> error
	value.  The results of invoking the entry point across various
	registered policy modules will be composed as follows: if all
	modules permit the operation to succeed, success will be
	returned.  If one or modules returns a failure, a failure will
	be returned.  If more than one module returns a failure, the
	errno value to return to the user will be selected using the
	following precedence, implemented by the
	<code class="function">error_select()</code> function in
	<code class="filename">kern_mac.c</code>:</p><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>Most precedence</td><td><span class="errorcode">EDEADLK</span></td></tr><tr><td> </td><td><span class="errorcode">EINVAL</span></td></tr><tr><td> </td><td><span class="errorcode">ESRCH</span></td></tr><tr><td> </td><td>EACCES</td></tr><tr><td>Least precedence</td><td>EPERM</td></tr></tbody></table></div><p>If none of the error values returned by all modules are
	listed in the precedence chart then an arbitrarily selected
	value from the set will be returned.  In general, the rules
	provide precedence to errors in the following order: kernel
	failures, invalid arguments, object not present, access not
	permitted, other.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-bpfdesc-check-receive-from-ifnet"></a>6.7.4.1. <code class="function">mpo_check_bpfdesc_receive</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_bpfdesc_receive</strong>(</code></td><td><var class="pdparam">bpf_d</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bpflabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct bpf_d
	      *<var class="pdparam">bpf_d</var></code>;<br /><code>struct label
	      *<var class="pdparam">bpflabel</var></code>;<br /><code>struct ifnet
	      *<var class="pdparam">ifnet</var></code>;<br /><code>struct label
	      *<var class="pdparam">ifnetlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>bpf_d</code></em></td><td>Subject; BPF descriptor</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>bpflabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>bpf_d</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Object; network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the MAC framework should permit
	  datagrams from the passed interface to be delivered to the
	  buffers of the passed BPF descriptor.  Return
	  (<span class="returnvalue">0</span>) for success, or an
	  <code class="varname">errno</code> value for failure Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches,
	  <span class="errorcode">EPERM</span> for lack of privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kenv-dump"></a>6.7.4.2. <code class="function">mpo_check_kenv_dump</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kenv_dump</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  retrieve the kernel environment (see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=kenv&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">kenv</span>(2)</span></a>).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kenv-get"></a>6.7.4.3. <code class="function">mpo_check_kenv_get</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kenv_get</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>char *<var class="pdparam">name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td>Kernel environment variable name</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  retrieve the value of the specified kernel environment
	  variable.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kenv-set"></a>6.7.4.4. <code class="function">mpo_check_kenv_set</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kenv_set</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>char *<var class="pdparam">name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td>Kernel environment variable name</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to set
	  the specified kernel environment variable.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kenv-unset"></a>6.7.4.5. <code class="function">mpo_check_kenv_unset</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kenv_unset</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>char *<var class="pdparam">name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td>Kernel environment variable name</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to unset
	  the specified kernel environment variable.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kld-load"></a>6.7.4.6. <code class="function">mpo_check_kld_load</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kld_load</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Kernel module vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to load
	  the specified module file.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kld-stat"></a>6.7.4.7. <code class="function">mpo_check_kld_stat</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kld_stat</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  retrieve a list of loaded kernel module files and associated
	  statistics.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-kld-unload"></a>6.7.4.8. <code class="function">mpo_check_kld_unload</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_kld_unload</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  unload a kernel module.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-ioctl"></a>6.7.4.9. <code class="function">mpo_check_pipe_ioctl</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_ioctl</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cmd</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;<br /><code>unsigned long
	      <var class="pdparam">cmd</var></code>;<br /><code>void *<var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cmd</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> command</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>data</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> data</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to make
	  the specified <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> call.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-poll"></a>6.7.4.10. <code class="function">mpo_check_pipe_poll</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_poll</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to poll
	  <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-read"></a>6.7.4.11. <code class="function">mpo_check_pipe_read</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_read</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed read
	  access to <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-relabel"></a>6.7.4.12. <code class="function">mpo_check_pipe_relabel</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_relabel</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Current policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update to
		  <em class="parameter"><code>pipelabel</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  relabel <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-stat"></a>6.7.4.13. <code class="function">mpo_check_pipe_stat</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_stat</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  retrieve statistics related to
	  <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-pipe-write"></a>6.7.4.14. <code class="function">mpo_check_pipe_write</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_pipe_write</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">pipelabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct pipe
	      *<var class="pdparam">pipe</var></code>;<br /><code>struct label
	      *<var class="pdparam">pipelabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipe</code></em></td><td>Pipe</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>pipelabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>pipe</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to write
	  to <em class="parameter"><code>pipe</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-bind"></a>6.7.4.15. <code class="function">mpo_check_socket_bind</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_bind</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sockaddr</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">socket</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;<br /><code>struct sockaddr
	      *<var class="pdparam">sockaddr</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socket</code></em></td><td>Socket to be bound</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sockaddr</code></em></td><td>Address of
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-connect"></a>6.7.4.16. <code class="function">mpo_check_socket_connect</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_connect</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sockaddr</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">socket</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;<br /><code>struct sockaddr
	      *<var class="pdparam">sockaddr</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socket</code></em></td><td>Socket to be connected</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>sockaddr</code></em></td><td>Address of
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential
	  (<em class="parameter"><code>cred</code></em>) can connect the passed socket
	  (<em class="parameter"><code>socket</code></em>) to the passed socket address
	  (<em class="parameter"><code>sockaddr</code></em>).  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches,
	  <span class="errorcode">EPERM</span> for lack of privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-socket-receive"></a>6.7.4.17. <code class="function">mpo_check_socket_receive</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_receive</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">so</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>so</code></em></td><td>Socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  receive information from the socket
	  <em class="parameter"><code>so</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-socket-send"></a>6.7.4.18. <code class="function">mpo_check_socket_send</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_send</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">so</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>so</code></em></td><td>Socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to send
	  information across the socket
	  <em class="parameter"><code>so</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-cred-visible"></a>6.7.4.19. <code class="function">mpo_check_cred_visible</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_cred_visible</strong>(</code></td><td><var class="pdparam">u1</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">u2</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">u1</var></code>;<br /><code>struct ucred
	      *<var class="pdparam">u2</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>u1</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>u2</code></em></td><td>Object credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential
	  <em class="parameter"><code>u1</code></em> can <span class="quote">&#8220;<span class="quote">see</span>&#8221;</span> other
	  subjects with the passed subject credential
	  <em class="parameter"><code>u2</code></em>.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches,
	  <span class="errorcode">EPERM</span> for lack of privilege, or
	  <span class="errorcode">ESRCH</span> to hide visibility.  This call
	  may be made in a number of situations, including
	  inter-process status sysctl's used by <code class="command">ps</code>,
	  and in procfs lookups.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-visible"></a>6.7.4.20. <code class="function">mpo_check_socket_visible</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_visible</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">socket</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socket</code></em></td><td>Object; socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-ifnet-relabel"></a>6.7.4.21. <code class="function">mpo_check_ifnet_relabel</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_ifnet_relabel</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct ifnet
	      *<var class="pdparam">ifnet</var></code>;<br /><code>struct label
	      *<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Object; network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Existing policy label for
		  <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Policy label update to later be applied to
		  <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can relabel the
	  passed network interface to the passed label update.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-relabel"></a>6.7.4.22. <code class="function">mpo_check_socket_relabel</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_relabel</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">socket</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socket</code></em></td><td>Object; socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Existing policy label for
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update to later be applied to
		  <em class="parameter"><code>socketlabel</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can relabel the
	  passed socket to the passed label update.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-cred-relabel"></a>6.7.4.23. <code class="function">mpo_check_cred_relabel</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_cred_relabel</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct label
	      *<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Label update to later be applied to
		  <em class="parameter"><code>cred</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can relabel
	  itself to the passed label update.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-relabel"></a>6.7.4.24. <code class="function">mpo_check_vnode_relabel</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_relabel</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vnodelabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">vnodelabel</var></code>;<br /><code>struct label
	      *<var class="pdparam">newlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td>Locked</td></tr><tr><td><em class="parameter"><code>vnodelabel</code></em></td><td>Existing policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlabel</code></em></td><td>Policy label update to later be applied to
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can relabel the
	  passed vnode to the passed label update.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mpo-cred-check-mount-stat"></a>6.7.4.25. <code class="function">mpo_check_mount_stat</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_mount_stat</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mountlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct mount
	      *<var class="pdparam">mp</var></code>;<br /><code>struct label
	      *<var class="pdparam">mountlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mp</code></em></td><td>Object; file system mount</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mountlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>mp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can see the
	  results of a statfs performed on the file system.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches
	  or <span class="errorcode">EPERM</span> for lack of privilege.  This
	  call may be made in a number of situations, including during
	  invocations of <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=statfs&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">statfs</span>(2)</span></a> and related calls, as well as
	  to determine what file systems to exclude from listings of
	  file systems, such as when <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getfsstat&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getfsstat</span>(2)</span></a> is
	  invoked.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-proc-debug"></a>6.7.4.26. <code class="function">mpo_check_proc_debug</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_proc_debug</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">proc</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct proc
	      *<var class="pdparam">proc</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>proc</code></em></td><td>Object; process</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can debug the
	  passed process.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, <span class="errorcode">EPERM</span> for lack of
	  privilege, or <span class="errorcode">ESRCH</span> to hide
	  visibility of the target.  This call may be made in a number
	  of situations, including use of the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ptrace</span>(2)</span></a> and
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ktrace&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ktrace</span>(2)</span></a> APIs, as well as for some types of procfs
	  operations.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-access"></a>6.7.4.27. <code class="function">mpo_check_vnode_access</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_access</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">flags</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">flags</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>flags</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=access&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">access</span>(2)</span></a> flags</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine how invocations of <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=access&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">access</span>(2)</span></a> and related
	  calls by the subject credential should return when performed
	  on the passed vnode using the passed access flags.  This
	  should generally be implemented using the same semantics
	  used in <code class="function">mpo_check_vnode_open</code>.
	  Return <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-chdir"></a>6.7.4.28. <code class="function">mpo_check_vnode_chdir</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_chdir</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Object; vnode to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=chdir&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">chdir</span>(2)</span></a> into</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can change the
	  process working directory to the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-chroot"></a>6.7.4.29. <code class="function">mpo_check_vnode_chroot</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_chroot</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">chroot</span>(2)</span></a> into the specified directory
	  (<em class="parameter"><code>dvp</code></em>).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-create"></a>6.7.4.30. <code class="function">mpo_check_vnode_create</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_create</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vap</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;<br /><code>struct vattr
	      *<var class="pdparam">vap</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vap</code></em></td><td>vnode attributes for
		  <em class="parameter"><code>vap</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can create a
	  vnode with the passed parent directory, passed name
	  information, and passed attribute information.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of privilege.  This
	  call may be made in a number of situations, including as a
	  result of calls to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=open&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a> with
	  <span class="symbol">O_CREAT</span>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mkfifo&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mkfifo</span>(2)</span></a>, and others.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-delete"></a>6.7.4.31. <code class="function">mpo_check_vnode_delete</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_delete</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>void *<var class="pdparam">label</var></code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Parent directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode to delete</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can delete a
	  vnode from the passed parent directory and passed name
	  information.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, or <span class="errorcode">EPERM</span> for lack of
	  privilege.  This call may be made in a number of situations,
	  including as a result of calls to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=unlink&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">unlink</span>(2)</span></a> and
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rmdir&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rmdir</span>(2)</span></a>.  Policies implementing this entry point
	  should also implement
	  <code class="function">mpo_check_rename_to</code> to authorize
	  deletion of objects as a result of being the target of a
	  rename.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-deleteacl"></a>6.7.4.32. <code class="function">mpo_check_vnode_deleteacl</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_deleteacl</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">type</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>acl_type_t
	      <var class="pdparam">type</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td>Locked</td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>type</code></em></td><td>ACL type</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can delete the
	  ACL of passed type from the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-exec"></a>6.7.4.33. <code class="function">mpo_check_vnode_exec</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_exec</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode to execute</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can execute the
	  passed vnode.  Determination of execute privilege is made
	  separately from decisions about any transitioning event.
	  Return <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mpo-cred-check-vnode-getacl"></a>6.7.4.34. <code class="function">mpo_check_vnode_getacl</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_getacl</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">type</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>acl_type_t
	      <var class="pdparam">type</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>type</code></em></td><td>ACL type</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can retrieve
	  the ACL of passed type from the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-getextattr"></a>6.7.4.35. <code class="function">mpo_check_vnode_getextattr</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_getextattr</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">attrnamespace</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">uio</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int
	      <var class="pdparam">attrnamespace</var></code>;<br /><code>const char
	      *<var class="pdparam">name</var></code>;<br /><code>struct uio
	      *<var class="pdparam">uio</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>attrnamespace</code></em></td><td>Extended attribute namespace</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td>Extended attribute name</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>uio</code></em></td><td>I/O structure pointer; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=uio&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">uio</span>(9)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can retrieve
	  the extended attribute with the passed namespace and name
	  from the passed vnode.  Policies implementing labeling using
	  extended attributes may be interested in special handling of
	  operations on those extended attributes.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-link"></a>6.7.4.36. <code class="function">mpo_check_vnode_link</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_link</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Link destination vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name for the link being
		  created</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  create a link to the vnode <em class="parameter"><code>vp</code></em> with
	  the name specified by <em class="parameter"><code>cnp</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-mmap"></a>6.7.4.37. <code class="function">mpo_check_vnode_mmap</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_mmap</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">prot</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">prot</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Vnode to map</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>prot</code></em></td><td>Mmap protections (see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>)</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to map
	  the vnode <em class="parameter"><code>vp</code></em> with the protections
	  specified in <em class="parameter"><code>prot</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-mmap-downgrade"></a>6.7.4.38. <code class="function">mpo_check_vnode_mmap_downgrade</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void
	      <strong class="fsfunc">mpo_check_vnode_mmap_downgrade</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">prot</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int *<var class="pdparam">prot</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td rowspan="3">See <a class="xref" href="#mac-mpo-check-vnode-mmap" title="6.7.4.37. mpo_check_vnode_mmap">Section 6.7.4.37, &#8220;<code class="function">mpo_check_vnode_mmap</code>&#8221;</a>.</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>prot</code></em></td><td>Mmap protections to be downgraded</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Downgrade the mmap protections based on the subject and
	  object labels.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-mprotect"></a>6.7.4.39. <code class="function">mpo_check_vnode_mprotect</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_mprotect</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">prot</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">prot</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Mapped vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>prot</code></em></td><td>Memory protections</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to set
	  the specified memory protections on memory mapped from the
	  vnode <em class="parameter"><code>vp</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-poll"></a>6.7.4.40. <code class="function">mpo_check_vnode_poll</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_poll</strong>(</code></td><td><var class="pdparam">active_cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">file_cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">active_cred</var></code>;<br /><code>struct ucred
	      *<var class="pdparam">file_cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>active_cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>file_cred</code></em></td><td>Credential associated with the <span class="type">struct
		  file</span></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Polled vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to poll
	  the vnode <em class="parameter"><code>vp</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-rename-from"></a>6.7.4.41. <code class="function">mpo_check_vnode_rename_from</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_vnode_rename_from</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Vnode to be renamed</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  rename the vnode <em class="parameter"><code>vp</code></em> to something
	  else.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-vnode-rename-to"></a>6.7.4.42. <code class="function">mpo_check_vnode_rename_to</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_rename_to</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dvp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">dlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">samedir</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">dvp</var></code>;<br /><code>struct label
	      *<var class="pdparam">dlabel</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">samedir</var></code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Overwritten vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>samedir</code></em></td><td>Boolean; <code class="literal">1</code> if the source and
		  destination directories are the same</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Destination component name</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  rename to the vnode <em class="parameter"><code>vp</code></em>, into the
	  directory <em class="parameter"><code>dvp</code></em>, or to the name
	  represented by <em class="parameter"><code>cnp</code></em>.  If there is no
	  existing file to overwrite, <em class="parameter"><code>vp</code></em> and
	  <em class="parameter"><code>label</code></em> will be NULL.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-listen"></a>6.7.4.43. <code class="function">mpo_check_socket_listen</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_listen</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socket</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">socket</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socket</code></em></td><td>Object; socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>socket</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can listen on
	  the passed socket.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-lookup"></a>6.7.4.44. <code class="function">mpo_check_vnode_lookup</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_lookup</strong>(</code></td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">cnp</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred *<var class="pdparam"></var>cred</code>;<br /><code>struct vnode *<var class="pdparam"></var>dvp</code>;<br /><code>struct label *<var class="pdparam"></var>dlabel</code>;<br /><code>struct componentname
	      *<var class="pdparam">cnp</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>cnp</code></em></td><td>Component name being looked up</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can perform a
	  lookup in the passed directory vnode for the passed name.
	  Return <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-open"></a>6.7.4.45. <code class="function">mpo_check_vnode_open</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_open</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">acc_mode</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int <var class="pdparam">acc_mode</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>acc_mode</code></em></td><td><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=open&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a> access mode</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can perform an
	  open operation on the passed vnode with the passed access
	  mode.  Return <span class="returnvalue">0</span> for success, or
	  an errno value for failure.  Suggested failure:
	  <span class="errorcode">EACCES</span> for label mismatch, or
	  <span class="errorcode">EPERM</span> for lack of privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-readdir"></a>6.7.4.46. <code class="function">mpo_check_vnode_readdir</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_readdir</strong>(</code></td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred *<var class="pdparam"></var>cred</code>;<br /><code>struct vnode *<var class="pdparam"></var>dvp</code>;<br /><code>struct label *<var class="pdparam"></var>dlabel</code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dvp</code></em></td><td>Object; directory vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>dlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>dvp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can perform a
	  <code class="function">readdir</code> operation on the passed
	  directory vnode.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-readlink"></a>6.7.4.47. <code class="function">mpo_check_vnode_readlink</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_readlink</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can perform a
	  <code class="function">readlink</code> operation on the passed
	  symlink vnode.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, or <span class="errorcode">EPERM</span> for lack of
	  privilege.  This call may be made in a number of situations,
	  including an explicit <code class="function">readlink</code> call by
	  the user process, or as a result of an implicit
	  <code class="function">readlink</code> during a name lookup by the
	  process.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-revoke"></a>6.7.4.48. <code class="function">mpo_check_vnode_revoke</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_revoke</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can revoke
	  access to the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setacl"></a>6.7.4.49. <code class="function">mpo_check_vnode_setacl</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setacl</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">type</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">acl</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>acl_type_t
	      <var class="pdparam">type</var></code>;<br /><code>struct acl
	      *<var class="pdparam">acl</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>type</code></em></td><td>ACL type</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>acl</code></em></td><td>ACL</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  passed ACL of passed type on the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setextattr"></a>6.7.4.50. <code class="function">mpo_check_vnode_setextattr</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setextattr</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">attrnamespace</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">uio</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>int
	      <var class="pdparam">attrnamespace</var></code>;<br /><code>const char
	      *<var class="pdparam">name</var></code>;<br /><code>struct uio
	      *<var class="pdparam">uio</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>attrnamespace</code></em></td><td>Extended attribute namespace</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td>Extended attribute name</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>uio</code></em></td><td>I/O structure pointer; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=uio&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">uio</span>(9)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  extended attribute of passed name and passed namespace on
	  the passed vnode.  Policies implementing security labels
	  backed into extended attributes may want to provide
	  additional protections for those attributes.  Additionally,
	  policies should avoid making decisions based on the data
	  referenced from <em class="parameter"><code>uio</code></em>, as there is a
	  potential race condition between this check and the actual
	  operation.  The <em class="parameter"><code>uio</code></em> may also be
	  <code class="literal">NULL</code> if a delete operation is being
	  performed.  Return <span class="returnvalue">0</span> for success,
	  or an <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setflags"></a>6.7.4.51. <code class="function">mpo_check_vnode_setflags</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setflags</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">flags</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>u_long <var class="pdparam">flags</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>flags</code></em></td><td>File flags; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">chflags</span>(2)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  passed flags on the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setmode"></a>6.7.4.52. <code class="function">mpo_check_vnode_setmode</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setmode</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mode</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>mode_t <var class="pdparam">mode</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mode</code></em></td><td>File mode; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">chmod</span>(2)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  passed mode on the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setowner"></a>6.7.4.53. <code class="function">mpo_check_vnode_setowner</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setowner</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">uid</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">gid</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;<br /><code>uid_t <var class="pdparam">uid</var></code>;<br /><code>gid_t <var class="pdparam">gid</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>uid</code></em></td><td>User ID</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>gid</code></em></td><td>Group ID</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  passed uid and passed gid as file uid and file gid on the
	  passed vnode.  The IDs may be set to (<code class="literal">-1</code>)
	  to request no update.  Return <span class="returnvalue">0</span>
	  for success, or an <code class="varname">errno</code> value for
	  failure.  Suggested failure: <span class="errorcode">EACCES</span>
	  for label mismatch, or <span class="errorcode">EPERM</span> for lack
	  of privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-setutimes"></a>6.7.4.54. <code class="function">mpo_check_vnode_setutimes</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_setutimes</strong>(</code></td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"></var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred *<var class="pdparam"></var>cred</code>;<br /><code>struct vnode *<var class="pdparam"></var>vp</code>;<br /><code>struct label *<var class="pdparam"></var>label</code>;<br /><code>struct timespec <var class="pdparam"></var>atime</code>;<br /><code>struct timespec <var class="pdparam"></var>mtime</code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vp</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>atime</code></em></td><td>Access time; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=utimes&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">utimes</span>(2)</span></a></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mtime</code></em></td><td>Modification time; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=utimes&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">utimes</span>(2)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can set the
	  passed access timestamps on the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-proc-sched"></a>6.7.4.55. <code class="function">mpo_check_proc_sched</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_proc_sched</strong>(</code></td><td><var class="pdparam">ucred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">proc</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">ucred</var></code>;<br /><code>struct proc
	      *<var class="pdparam">proc</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>proc</code></em></td><td>Object; process</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can change the
	  scheduling parameters of the passed process.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  <span class="errorcode">EPERM</span> for lack of privilege, or
	  <span class="errorcode">ESRCH</span> to limit visibility.</p><p>See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setpriority&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setpriority</span>(2)</span></a> for more information.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-proc-signal"></a>6.7.4.56. <code class="function">mpo_check_proc_signal</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_proc_signal</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">proc</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">signal</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct proc
	      *<var class="pdparam">proc</var></code>;<br /><code>int <var class="pdparam">signal</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>proc</code></em></td><td>Object; process</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>signal</code></em></td><td>Signal; see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">kill</span>(2)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can deliver the
	  passed signal to the passed process.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  <span class="errorcode">EPERM</span> for lack of privilege, or
	  <span class="errorcode">ESRCH</span> to limit visibility.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-vnode-stat"></a>6.7.4.57. <code class="function">mpo_check_vnode_stat</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_vnode_stat</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">label</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">label</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Object; vnode</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>label</code></em></td><td>Policy label for
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential can
	  <code class="function">stat</code> the passed vnode.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p><p>See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=stat&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">stat</span>(2)</span></a> for more information.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-ifnet-transmit"></a>6.7.4.58. <code class="function">mpo_check_ifnet_transmit</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_ifnet_transmit</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct ifnet
	      *<var class="pdparam">ifnet</var></code>;<br /><code>struct label
	      *<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct mbuf
	      *<var class="pdparam">mbuf</var></code>;<br /><code>struct label
	      *<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuf</code></em></td><td>Object; mbuf to be sent</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the network interface can transmit the
	  passed mbuf.  Return <span class="returnvalue">0</span> for
	  success, or an <code class="varname">errno</code> value for failure.
	  Suggested failure: <span class="errorcode">EACCES</span> for label
	  mismatch, or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-cred-check-socket-deliver"></a>6.7.4.59. <code class="function">mpo_check_socket_deliver</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_deliver</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ifnetlabel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuf</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">mbuflabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct ifnet
	      *<var class="pdparam">ifnet</var></code>;<br /><code>struct label
	      *<var class="pdparam">ifnetlabel</var></code>;<br /><code>struct mbuf
	      *<var class="pdparam">mbuf</var></code>;<br /><code>struct label
	      *<var class="pdparam">mbuflabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnet</code></em></td><td>Network interface</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>ifnetlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>ifnet</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuf</code></em></td><td>Object; mbuf to be delivered</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>mbuflabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>mbuf</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the socket may receive the datagram
	  stored in the passed mbuf header.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failures: <span class="errorcode">EACCES</span> for label mismatch,
	  or <span class="errorcode">EPERM</span> for lack of
	  privilege.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-socket-visible"></a>6.7.4.60. <code class="function">mpo_check_socket_visible</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_socket_visible</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">so</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">socketlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct socket
	      *<var class="pdparam">so</var></code>;<br /><code>struct label
	      *<var class="pdparam">socketlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td>Immutable</td></tr><tr><td><em class="parameter"><code>so</code></em></td><td>Object; socket</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>socketlabel</code></em></td><td>Policy label for
		  <em class="parameter"><code>so</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject credential cred can "see"
	  the passed socket (<em class="parameter"><code>socket</code></em>) using
	  system monitoring functions, such as those employed by
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">netstat</span>(8)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sockstat&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sockstat</span>(1)</span></a>.  Return
	  <span class="returnvalue">0</span> for success, or an
	  <code class="varname">errno</code> value for failure.  Suggested
	  failure: <span class="errorcode">EACCES</span> for label mismatches,
	  <span class="errorcode">EPERM</span> for lack of privilege, or
	  <span class="errorcode">ESRCH</span> to hide visibility.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-acct"></a>6.7.4.61. <code class="function">mpo_check_system_acct</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_acct</strong>(</code></td><td><var class="pdparam">ucred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">ucred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>ucred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Accounting file; <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">acct</span>(5)</span></a></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  enable accounting, based on its label and the label of the
	  accounting log file.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-nfsd"></a>6.7.4.62. <code class="function">mpo_check_system_nfsd</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_nfsd</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to call
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=nfssvc&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">nfssvc</span>(2)</span></a>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-reboot"></a>6.7.4.63. <code class="function">mpo_check_system_reboot</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_reboot</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">howto</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>int <var class="pdparam">howto</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>howto</code></em></td><td><em class="parameter"><code>howto</code></em> parameter from
		  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=reboot&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">reboot</span>(2)</span></a></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to
	  reboot the system in the specified manner.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-settime"></a>6.7.4.64. <code class="function">mpo_check_system_settime</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_settime</strong>(</code></td><td><var class="pdparam">cred</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the user should be allowed to set the
	  system clock.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-swapon"></a>6.7.4.65. <code class="function">mpo_check_system_swapon</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_swapon</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vlabel</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>struct vnode
	      *<var class="pdparam">vp</var></code>;<br /><code>struct label
	      *<var class="pdparam">vlabel</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vp</code></em></td><td>Swap device</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>vlabel</code></em></td><td>Label associated with
		  <em class="parameter"><code>vp</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to add
	  <em class="parameter"><code>vp</code></em> as a swap device.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-mpo-check-system-sysctl"></a>6.7.4.66. <code class="function">mpo_check_system_sysctl</code></h4></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int
	      <strong class="fsfunc">mpo_check_system_sysctl</strong>(</code></td><td><var class="pdparam">cred</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">namelen</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">old</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">oldlenp</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">inkernel</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">new</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">newlen</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>struct ucred
	      *<var class="pdparam">cred</var></code>;<br /><code>int *<var class="pdparam">name</var></code>;<br /><code>u_int *<var class="pdparam">namelen</var></code>;<br /><code>void *<var class="pdparam">old</var></code>;<br /><code>size_t
	      *<var class="pdparam">oldlenp</var></code>;<br /><code>int <var class="pdparam">inkernel</var></code>;<br /><code>void *<var class="pdparam">new</var></code>;<br /><code>size_t <var class="pdparam">newlen</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col width="0" class="first" /><col width="0" /><col width="0" class="last" /></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Locking</th></tr></thead><tbody><tr><td><em class="parameter"><code>cred</code></em></td><td>Subject credential</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>name</code></em></td><td rowspan="4">See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>namelen</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>old</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>oldlenp</code></em></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>inkernel</code></em></td><td>Boolean; <code class="literal">1</code> if called from
		  kernel</td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>new</code></em></td><td rowspan="2">See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a></td><td class="auto-generated"> </td></tr><tr><td><em class="parameter"><code>newlen</code></em></td><td class="auto-generated"> </td></tr></tbody></table></div><p>Determine whether the subject should be allowed to make
	  the specified <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a> transaction.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-label-management"></a>6.7.5. Label Management Calls</h3></div></div></div><p>Relabel events occur when a user process has requested
	that the label on an object be modified.  A two-phase update
	occurs: first, an access control check will be performed to
	determine if the update is both valid and permitted, and then
	the update itself is performed via a separate entry point.
	Relabel entry points typically accept the object, object label
	reference, and an update label submitted by the process.
	Memory allocation during relabel is discouraged, as relabel
	calls are not permitted to fail (failure should be reported
	earlier in the relabel check).</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-userland-arch"></a>6.8. Userland Architecture</h2></div></div></div><p>The TrustedBSD MAC Framework includes a number of
      policy-agnostic elements, including MAC library interfaces for
      abstractly managing labels, modifications to the system
      credential management and login libraries to support the
      assignment of MAC labels to users, and a set of tools to monitor
      and modify labels on processes, files, and network interfaces.
      More details on the user architecture will be added to this
      section in the near future.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-userland-labels"></a>6.8.1. APIs for Policy-Agnostic Label Management</h3></div></div></div><p>The TrustedBSD MAC Framework provides a number of
	library and system calls permitting applications to
	manage MAC labels on objects using a policy-agnostic
	interface.  This permits applications to manipulate
	labels for a variety of policies without being
	written to support specific policies.  These interfaces
	are used by general-purpose tools such as <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>,
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> to view labels on network
	interfaces, files, and processes.  The APIs also support
	MAC management tools including <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getfmac&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getfmac</span>(8)</span></a>,
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getpmac&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getpmac</span>(8)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setfmac</span>(8)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setfsmac&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setfsmac</span>(8)</span></a>,
	and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setpmac</span>(8)</span></a>.  The MAC APIs are documented in
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mac&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mac</span>(3)</span></a>.</p><p>Applications handle MAC labels in two forms: an
	internalized form used to return and set labels on
	processes and objects (<code class="literal">mac_t</code>),
	and externalized form based on C strings appropriate for
	storage in configuration files, display to the user, or
	input from the user.  Each MAC label contains a number of
	elements, each consisting of a name and value pair.
	Policy modules in the kernel bind to specific names
	and interpret the values in policy-specific ways.  In
	the externalized string form, labels are represented
	by a comma-delimited list of name and value pairs separated
	by the <code class="literal">/</code> character.  Labels may be
	directly converted to and from text using provided APIs;
	when retrieving labels from the kernel, internalized
	label storage must first be prepared for the desired
	label element set.  Typically, this is done in one of
	two ways: using <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mac_prepare&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mac_prepare</span>(3)</span></a> and an arbitrary
	list of desired label elements, or one of the variants
	of the call that loads a default element set from the
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mac.conf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mac.conf</span>(5)</span></a> configuration file.  Per-object
	defaults permit application writers to usefully display
	labels associated with objects without being aware of
	the policies present in the system.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Currently, direct manipulation of label elements other
	  than by conversion to a text string, string editing, and
	  conversion back to an internalized label is not supported by
	  the MAC library.  Such interfaces may be added in the future
	  if they prove necessary for application
	  writers.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="mac-userland-credentials"></a>6.8.2. Binding of Labels to Users</h3></div></div></div><p>The standard user context management interface,
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setusercontext&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setusercontext</span>(3)</span></a>, has been modified to retrieve
	MAC labels associated with a user's class from
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">login.conf</span>(5)</span></a>.  These labels are then set along
	with other user context when either
	<code class="literal">LOGIN_SETALL</code> is specified, or when
	<code class="literal">LOGIN_SETMAC</code> is explicitly
	specified.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">It is expected that, in a future version of FreeBSD,
	the MAC label database will be separated from the
	<code class="filename">login.conf</code> user class abstraction,
	and be maintained in a separate database.  However, the
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setusercontext&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setusercontext</span>(3)</span></a> API should remain the same
	following such a change.</p></div></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="mac-conclusion"></a>6.9. Conclusion</h2></div></div></div><p>The TrustedBSD MAC framework permits kernel modules to
      augment the system security policy in a highly integrated
      manner.  They may do this based on existing object properties,
      or based on label data that is maintained with the assistance of
      the MAC framework.  The framework is sufficiently flexible to
      implement a variety of policy types, including information flow
      security policies such as MLS and Biba, as well as policies
      based on existing BSD credentials or file protections.  Policy
      authors may wish to consult this documentation as well as
      existing security modules when implementing a new security
      service.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="vm"></a>Chapter 7. Virtual Memory System</h2></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Matthew</span> <span class="surname">Dillon</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#vm-physmem">7.1. Management of Physical
      Memory&#8212;<code class="literal">vm_page_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-cache">7.2. The Unified Buffer
      Cache&#8212;<code class="literal">vm_object_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-fileio">7.3. Filesystem I/O&#8212;<code class="literal">struct buf</code></a></span></dt><dt><span class="sect1"><a href="#vm-pagetables">7.4. Mapping Page Tables&#8212;<code class="literal">vm_map_t,
	vm_entry_t</code></a></span></dt><dt><span class="sect1"><a href="#vm-kvm">7.5. KVM Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#vm-tuning">7.6. Tuning the FreeBSD VM System</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-physmem"></a>7.1. Management of Physical
      Memory&#8212;<code class="literal">vm_page_t</code></h2></div></div></div><a id="idp53688440" class="indexterm"></a><a id="idp53688952" class="indexterm"></a><a id="idp53689464" class="indexterm"></a><p>Physical memory is managed on a page-by-page basis through
      the <code class="literal">vm_page_t</code> structure.  Pages of physical
      memory are categorized through the placement of their respective
      <code class="literal">vm_page_t</code> structures on one of several paging
      queues.</p><p>A page can be in a wired, active, inactive, cache, or free
      state.  Except for the wired state, the page is typically placed
      in a doubly link list queue representing the state that it is
      in.  Wired pages are not placed on any queue.</p><p>FreeBSD implements a more involved paging queue for cached
      and free pages in order to implement page coloring.  Each of
      these states involves multiple queues arranged according to the
      size of the processor's L1 and L2 caches.  When a new page needs
      to be allocated, FreeBSD attempts to obtain one that is
      reasonably well aligned from the point of view of the L1 and L2
      caches relative to the VM object the page is being allocated
      for.</p><p>Additionally, a page may be held with a reference count or
      locked with a busy count.  The VM system also implements an
      <span class="quote">&#8220;<span class="quote">ultimate locked</span>&#8221;</span> state for a page using the
      PG_BUSY bit in the page's flags.</p><p>In general terms, each of the paging queues operates in a
      LRU fashion.  A page is typically placed in a wired or active
      state initially.  When wired, the page is usually associated
      with a page table somewhere.  The VM system ages the page by
      scanning pages in a more active paging queue (LRU) in order to
      move them to a less-active paging queue.  Pages that get moved
      into the cache are still associated with a VM object but are
      candidates for immediate reuse.  Pages in the free queue are
      truly free.  FreeBSD attempts to minimize the number of pages in
      the free queue, but a certain minimum number of truly free pages
      must be maintained in order to accommodate page allocation at
      interrupt time.</p><p>If a process attempts to access a page that does not exist
      in its page table but does exist in one of the paging queues
      (such as the inactive or cache queues), a relatively inexpensive
      page reactivation fault occurs which causes the page to be
      reactivated.  If the page does not exist in system memory at
      all, the process must block while the page is brought in from
      disk.</p><a id="idp53698040" class="indexterm"></a><p>FreeBSD dynamically tunes its paging queues and attempts to
      maintain reasonable ratios of pages in the various queues as
      well as attempts to maintain a reasonable breakdown of clean
      versus dirty pages.  The amount of rebalancing that occurs
      depends on the system's memory load.  This rebalancing is
      implemented by the pageout daemon and involves laundering dirty
      pages (syncing them with their backing store), noticing when
      pages are activity referenced (resetting their position in the
      LRU queues or moving them between queues), migrating pages
      between queues when the queues are out of balance, and so forth.
      FreeBSD's VM system is willing to take a reasonable number of
      reactivation page faults to determine how active or how idle a
      page actually is.  This leads to better decisions being made as
      to when to launder or swap-out a page.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-cache"></a>7.2. The Unified Buffer
      Cache&#8212;<code class="literal">vm_object_t</code></h2></div></div></div><a id="idp53700088" class="indexterm"></a><a id="idp53700600" class="indexterm"></a><p>FreeBSD implements the idea of a generic
      <span class="quote">&#8220;<span class="quote">VM object</span>&#8221;</span>.  VM objects can be associated with
      backing store of various types&#8212;unbacked, swap-backed,
      physical device-backed, or file-backed storage.  Since the
      filesystem uses the same VM objects to manage in-core data
      relating to files, the result is a unified buffer cache.</p><p>VM objects can be <span class="emphasis"><em>shadowed</em></span>.  That is,
      they can be stacked on top of each other.  For example, you
      might have a swap-backed VM object stacked on top of a
      file-backed VM object in order to implement a MAP_PRIVATE
      mmap()ing.  This stacking is also used to implement various
      sharing properties, including copy-on-write, for forked address
      spaces.</p><p>It should be noted that a <code class="literal">vm_page_t</code> can
      only be associated with one VM object at a time.  The VM object
      shadowing implements the perceived sharing of the same page
      across multiple instances.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-fileio"></a>7.3. Filesystem I/O&#8212;<code class="literal">struct buf</code></h2></div></div></div><a id="idp53721464" class="indexterm"></a><p>vnode-backed VM objects, such as file-backed objects,
      generally need to maintain their own clean/dirty info
      independent from the VM system's idea of clean/dirty.  For
      example, when the VM system decides to synchronize a physical
      page to its backing store, the VM system needs to mark the page
      clean before the page is actually written to its backing store.
      Additionally, filesystems need to be able to map portions of a
      file or file metadata into KVM in order to operate on it.</p><p>The entities used to manage this are known as filesystem
      buffers, <code class="literal">struct buf</code>'s, or
      <code class="literal">bp</code>'s.  When a filesystem needs to operate on
      a portion of a VM object, it typically maps part of the object
      into a struct buf and then maps the pages in the struct buf into
      KVM.  In the same manner, disk I/O is typically issued by
      mapping portions of objects into buffer structures and then
      issuing the I/O on the buffer structures.  The underlying
      vm_page_t's are typically busied for the duration of the I/O.
      Filesystem buffers also have their own notion of being busy,
      which is useful to filesystem driver code which would rather
      operate on filesystem buffers instead of hard VM pages.</p><p>FreeBSD reserves a limited amount of KVM to hold mappings
      from struct bufs, but it should be made clear that this KVM is
      used solely to hold mappings and does not limit the ability to
      cache data.  Physical data caching is strictly a function of
      <code class="literal">vm_page_t</code>'s, not filesystem buffers.
      However, since filesystem buffers are used to placehold I/O,
      they do inherently limit the amount of concurrent I/O possible.
      However, as there are usually a few thousand filesystem buffers
      available, this is not usually a problem.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-pagetables"></a>7.4. Mapping Page Tables&#8212;<code class="literal">vm_map_t,
	vm_entry_t</code></h2></div></div></div><a id="idp53725432" class="indexterm"></a><p>FreeBSD separates the physical page table topology from the
      VM system.  All hard per-process page tables can be
      reconstructed on the fly and are usually considered throwaway.
      Special page tables such as those managing KVM are typically
      permanently preallocated.  These page tables are not
      throwaway.</p><p>FreeBSD associates portions of vm_objects with address
      ranges in virtual memory through <code class="literal">vm_map_t</code> and
      <code class="literal">vm_entry_t</code> structures.  Page tables are
      directly synthesized from the
      <code class="literal">vm_map_t</code>/<code class="literal">vm_entry_t</code>/
      <code class="literal">vm_object_t</code> hierarchy.  Recall that I
      mentioned that physical pages are only directly associated with
      a <code class="literal">vm_object</code>; that is not quite true.
      <code class="literal">vm_page_t</code>'s are also linked into page tables
      that they are actively associated with.  One
      <code class="literal">vm_page_t</code> can be linked into several
      <span class="emphasis"><em>pmaps</em></span>, as page tables are called.  However,
      the hierarchical association holds, so all references to the
      same page in the same object reference the same
      <code class="literal">vm_page_t</code> and thus give us buffer cache
      unification across the board.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-kvm"></a>7.5. KVM Memory Mapping</h2></div></div></div><p>FreeBSD uses KVM to hold various kernel structures.  The
      single largest entity held in KVM is the filesystem buffer
      cache.  That is, mappings relating to
      <code class="literal">struct buf</code> entities.</p><p>Unlike Linux, FreeBSD does <span class="emphasis"><em>not</em></span> map all
      of physical memory into KVM.  This means that FreeBSD can handle
      memory configurations up to 4G on 32 bit platforms.  In fact, if
      the mmu were capable of it, FreeBSD could theoretically handle
      memory configurations up to 8TB on a 32 bit platform.  However,
      since most 32 bit platforms are only capable of mapping 4GB of
      ram, this is a moot point.</p><p>KVM is managed through several mechanisms.  The main
      mechanism used to manage KVM is the
      <span class="emphasis"><em>zone allocator</em></span>.  The zone allocator takes a
      chunk of KVM and splits it up into constant-sized blocks of
      memory in order to allocate a specific type of structure.  You
      can use <code class="command">vmstat -m</code> to get an overview of
      current KVM utilization broken down by zone.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-tuning"></a>7.6. Tuning the FreeBSD VM System</h2></div></div></div><p>A concerted effort has been made to make the FreeBSD kernel
      dynamically tune itself.  Typically you do not need to mess with
      anything beyond the <code class="option">maxusers</code> and
      <code class="option">NMBCLUSTERS</code> kernel config options.  That is,
      kernel compilation options specified in (typically)
      <code class="filename">/usr/src/sys/i386/conf/<em class="replaceable"><code>CONFIG_FILE</code></em></code>.
      A description of all available kernel configuration options can
      be found in
      <code class="filename">/usr/src/sys/i386/conf/LINT</code>.</p><p>In a large system configuration you may wish to increase
      <code class="option">maxusers</code>.  Values typically range from 10 to
      128. Note that raising <code class="option">maxusers</code> too high can
      cause the system to overflow available KVM resulting in
      unpredictable operation.  It is better to leave
      <code class="option">maxusers</code> at some reasonable number and add
      other options, such as <code class="option">NMBCLUSTERS</code>, to increase
      specific resources.</p><p>If your system is going to use the network heavily, you may
      want to increase <code class="option">NMBCLUSTERS</code>.  Typical values
      range from 1024 to 4096.</p><p>The <code class="literal">NBUF</code> parameter is also traditionally
      used to scale the system.  This parameter determines the amount
      of KVA the system can use to map filesystem buffers for I/O.
      Note that this parameter has nothing whatsoever to do with the
      unified buffer cache! This parameter is dynamically tuned in
      3.0-CURRENT and later kernels and should generally not be
      adjusted manually.  We recommend that you
      <span class="emphasis"><em>not</em></span> try to specify an
      <code class="literal">NBUF</code> parameter.  Let the system pick it.  Too
      small a value can result in extremely inefficient filesystem
      operation while too large a value can starve the page queues by
      causing too many pages to become wired down.</p><p>By default, FreeBSD kernels are not optimized.  You can set
      debugging and optimization flags with the
      <code class="literal">makeoptions</code> directive in the kernel
      configuration.  Note that you should not use <code class="option">-g</code>
      unless you can accommodate the large (typically 7 MB+) kernels
      that result.</p><pre class="programlisting">makeoptions      DEBUG="-g"
makeoptions      COPTFLAGS="-O -pipe"</pre><p>Sysctl provides a way to tune kernel parameters at run-time.
      You typically do not need to mess with any of the sysctl
      variables, especially the VM related ones.</p><p>Run time VM and system tuning is relatively straightforward.
      First, use Soft Updates on your UFS/FFS filesystems whenever
      possible.
      <code class="filename">/usr/src/sys/ufs/ffs/README.softupdates</code>
      contains instructions (and restrictions) on how to configure
      it.</p><a id="idp53744248" class="indexterm"></a><p>Second, configure  sufficient swap.  You should have a swap
      partition configured on each physical disk, up to four, even on
      your <span class="quote">&#8220;<span class="quote">work</span>&#8221;</span> disks.  You should have at least 2x the
      swap space as you have main memory, and possibly even more if
      you do not have a lot of memory.  You should also size your swap
      partition based on the maximum memory configuration you ever
      intend to put on the machine so you do not have to repartition
      your disks later on.  If you want to be able to accommodate a
      crash dump, your first swap partition must be at least as large
      as main memory and <code class="filename">/var/crash</code> must have
      sufficient free space to hold the dump.</p><p>NFS-based swap is perfectly acceptable on 4.X or later
      systems, but you must be aware that the NFS server will take the
      brunt of the paging load.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="smp"></a>Chapter 8. SMPng Design Document</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">John</span> <span class="surname">Baldwin</span></span> and <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Robert</span> <span class="surname">Watson</span></span>. </span></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2002, 2004-2005 John Baldwin, Robert Watson</p></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#smp-intro">8.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#smp-lock-fundamentals">8.2. Basic Tools and Locking Fundamentals</a></span></dt><dt><span class="sect1"><a href="#smp-design">8.3. General Architecture and Design</a></span></dt><dt><span class="sect1"><a href="#smp-lock-strategies">8.4. Specific Locking Strategies</a></span></dt><dt><span class="sect1"><a href="#smp-implementation-notes">8.5. Implementation Notes</a></span></dt><dt><span class="sect1"><a href="#smp-misc">8.6. Miscellaneous Topics</a></span></dt><dt><span class="glossary"><a href="#smp-glossary">Glossary</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-intro"></a>8.1. Introduction</h2></div></div></div><a id="idp53769848" class="indexterm"></a><a id="idp53770360" class="indexterm"></a><p>This document presents the current design and implementation
      of the SMPng Architecture.  First, the basic primitives and
      tools are introduced.  Next, a general architecture for the
      FreeBSD kernel's synchronization and execution model is laid
      out.  Then, locking strategies for specific subsystems are
      discussed, documenting the approaches taken to introduce
      fine-grained synchronization and parallelism for each subsystem.
      Finally, detailed implementation notes are provided to motivate
      design choices, and make the reader aware of important
      implications involving the use of specific primitives. </p><p>This document is a work-in-progress, and will be updated to
      reflect on-going design and implementation activities associated
      with the SMPng Project.  Many sections currently exist only in
      outline form, but will be fleshed out as work proceeds.  Updates or
      suggestions regarding the document may be directed to the document
      editors.</p><a id="idp53771640" class="indexterm"></a><p>The goal of SMPng is to allow concurrency in the kernel.
      The kernel is basically one rather large and complex program. To
      make the kernel multi-threaded we use some of the same tools used
      to make other programs multi-threaded.  These include mutexes,
      shared/exclusive locks, semaphores, and condition variables.  For
      the definitions of these and other SMP-related terms, please see
      the <a class="xref" href="#smp-glossary" title="Glossary">Glossary</a> section of this article.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-lock-fundamentals"></a>8.2. Basic Tools and Locking Fundamentals</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53773816"></a>8.2.1. Atomic Instructions and Memory Barriers</h3></div></div></div><a id="idp53774456" class="indexterm"></a><a id="idp53774968" class="indexterm"></a><p>There are several existing treatments of memory barriers
	and atomic instructions, so this section will not include a
	lot of detail.  To put it simply, one can not go around reading
	variables without a lock if a lock is used to protect writes
	to that variable.  This becomes obvious when you consider that
	memory barriers simply determine relative order of memory
	operations; they do not make any guarantee about timing of
	memory operations.  That is, a memory barrier does not force
	the contents of a CPU's local cache or store buffer to flush.
	Instead, the memory barrier at lock release simply ensures
	that all writes to the protected data will be visible to other
	CPU's or devices if the write to release the lock is visible.
	The CPU is free to keep that data in its cache or store buffer
	as long as it wants. However, if another CPU performs an
	atomic instruction on the same datum, the first CPU must
	guarantee that the updated value is made visible to the second
	CPU along with any other operations that memory barriers may
	require.</p><p>For example, assuming a simple model where data is
	considered visible when it is in main memory (or a global
	cache), when an atomic instruction is triggered on one CPU,
	other CPU's store buffers and caches must flush any writes to
	that same cache line along with any pending operations behind
	a memory barrier.</p><p>This requires one to take special care when using an item
	protected by atomic instructions.  For example, in the sleep
	mutex implementation, we have to use an
	<code class="function">atomic_cmpset</code> rather than an
	<code class="function">atomic_set</code> to turn on the
	<code class="constant">MTX_CONTESTED</code> bit.  The reason is that we
	read the value of <code class="varname">mtx_lock</code> into a
	variable and then make a decision based on that read.
	However, the value we read may be stale, or it may change
	while we are making our decision.  Thus, when the
	<code class="function">atomic_set</code> executed, it may end up
	setting the bit on another value than the one we made the
	decision on. Thus, we have to use an
	<code class="function">atomic_cmpset</code> to set the value only if
	the value we made the decision on is up-to-date and
	valid.</p><p>Finally, atomic instructions only allow one item to be
	updated or read.  If one needs to atomically update several
	items, then a lock must be used instead.  For example, if two
	counters must be read and have values that are consistent
	relative to each other, then those counters must be protected
	by a lock rather than by separate atomic instructions.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53841144"></a>8.2.2. Read Locks Versus Write Locks</h3></div></div></div><a id="idp53841784" class="indexterm"></a><a id="idp53842296" class="indexterm"></a><p>Read locks do not need to be as strong as write locks.
	Both types of locks need to ensure that the data they are
	accessing is not stale.  However, only write access requires
	exclusive access.  Multiple threads can safely read a value.
	Using different types of locks for reads and writes can be
	implemented in a number of ways.</p><p>First, sx locks can be used in this manner by using an
	exclusive lock when writing and a shared lock when reading.
	This method is quite straightforward.</p><p>A second method is a bit more obscure.  You can protect a
	datum with multiple locks.  Then for reading that data you
	simply need to have a read lock of one of the locks.  However,
	to write to the data, you need to have a write lock of all of
	the locks.  This can make writing rather expensive but can be
	useful when data is accessed in various ways.  For example,
	the parent process pointer is protected by both the
	<code class="varname">proctree_lock</code> sx lock and the per-process
	mutex.  Sometimes the proc lock is easier as we are just
	checking to see who a parent of a process is that we already
	have locked.  However, other places such as
	<code class="function">inferior</code> need to walk the tree of
	processes via parent pointers and locking each process would
	be prohibitive as well as a pain to guarantee that the
	condition you are checking remains valid for both the check
	and the actions taken as a result of the check.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53873528"></a>8.2.3. Locking Conditions and Results</h3></div></div></div><p>If you need a lock to check the state of a variable so
	that you can take an action based on the state you read, you
	can not just hold the lock while reading the variable and then
	drop the lock before you act on the value you read.  Once you
	drop the lock, the variable can change rendering your decision
	invalid. Thus, you must hold the lock both while reading the
	variable and while performing the action as a result of the
	test.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-design"></a>8.3. General Architecture and Design</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53875576"></a>8.3.1. Interrupt Handling</h3></div></div></div><a id="idp53876216" class="indexterm"></a><p>Following the pattern of several other multi-threaded <span class="trademark">UNIX</span>®
	kernels, FreeBSD deals with interrupt handlers by giving them
	their own thread context.  Providing a context for interrupt
	handlers allows them to block on locks.  To help avoid
	latency, however, interrupt threads run at real-time kernel
	priority. Thus, interrupt handlers should not execute for very
	long to avoid starving other kernel threads.  In addition,
	since multiple handlers may share an interrupt thread,
	interrupt handlers should not sleep or use a sleepable lock to
	avoid starving another interrupt handler.</p><a id="idp53885816" class="indexterm"></a><p>The interrupt threads currently in FreeBSD are referred to
	as heavyweight interrupt threads.  They are called this
	because switching to an interrupt thread involves a full
	context switch. In the initial implementation, the kernel was
	not preemptive and thus interrupts that interrupted a kernel
	thread would have to wait until the kernel thread blocked or
	returned to userland before they would have an opportunity to
	run.</p><a id="idp53886712" class="indexterm"></a><a id="idp53887224" class="indexterm"></a><p>To deal with the latency problems, the kernel in FreeBSD
	has been made preemptive.  Currently, we only preempt a kernel
	thread when we release a sleep mutex or when an interrupt
	comes in.  However, the plan is to make the FreeBSD kernel
	fully preemptive as described below.</p><p>Not all interrupt handlers execute in a thread context.
	Instead, some handlers execute directly in primary interrupt
	context.  These interrupt handlers are currently misnamed
	<span class="quote">&#8220;<span class="quote">fast</span>&#8221;</span> interrupt handlers since the
	<code class="constant">INTR_FAST</code> flag used in earlier versions
	of the kernel is used to mark these handlers.  The only
	interrupts which currently use these types of interrupt
	handlers are clock interrupts and serial I/O device
	interrupts.  Since these handlers do not have their own
	context, they may not acquire blocking locks and thus may only
	use spin mutexes.</p><a id="idp53889272" class="indexterm"></a><p>Finally, there is one optional optimization that can be
	added in MD code called lightweight context switches.  Since
	an interrupt thread executes in a kernel context, it can
	borrow the vmspace of any process.  Thus, in a lightweight
	context switch, the switch to the interrupt thread does not
	switch vmspaces but borrows the vmspace of the interrupted
	thread.  In order to ensure that the vmspace of the
	interrupted thread does not disappear out from under us, the
	interrupted thread is not allowed to execute until the
	interrupt thread is no longer borrowing its vmspace.  This can
	happen when the interrupt thread either blocks or finishes.
	If an interrupt thread blocks, then it will use its own
	context when it is made runnable again.  Thus, it can release
	the interrupted thread.</p><p>The cons of this optimization are that they are very
	machine specific and complex and thus only worth the effort if
	their is a large performance improvement.  At this point it is
	probably too early to tell, and in fact, will probably hurt
	performance as almost all interrupt handlers will immediately
	block on Giant and require a thread fix-up when they block.
	Also, an alternative method of interrupt handling has been
	proposed by Mike Smith that works like so:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Each interrupt handler has two parts: a predicate
	    which runs in primary interrupt context and a handler
	    which runs in its own thread context.</p></li><li class="listitem"><p>If an interrupt handler has a predicate, then when an
	    interrupt is triggered, the predicate is run.  If the
	    predicate returns true then the interrupt is assumed to be
	    fully handled and the kernel returns from the interrupt.
	    If the predicate returns false or there is no predicate,
	    then the threaded handler is scheduled to run.</p></li></ol></div><p>Fitting light weight context switches into this scheme
	might prove rather complicated.  Since we may want to change
	to this scheme at some point in the future, it is probably
	best to defer work on light weight context switches until we
	have settled on the final interrupt handling architecture and
	determined how light weight context switches might or might
	not fit into it.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53905272"></a>8.3.2. Kernel Preemption and Critical Sections</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53905912"></a>8.3.2.1. Kernel Preemption in a Nutshell</h4></div></div></div><p>Kernel preemption is fairly simple.  The basic idea is
	  that a CPU should always be doing the highest priority work
	  available.  Well, that is the ideal at least.  There are a
	  couple of cases where the expense of achieving the ideal is
	  not worth being perfect.</p><p>Implementing full kernel preemption is very
	  straightforward: when you schedule a thread to be executed
	  by putting it on a run queue, you check to see if its
	  priority is higher than the currently executing thread.  If
	  so, you initiate a context switch to that thread.</p><p>While locks can protect most data in the case of a
	  preemption, not all of the kernel is preemption safe.  For
	  example, if a thread holding a spin mutex preempted and the
	  new thread attempts to grab the same spin mutex, the new
	  thread may spin forever as the interrupted thread may never
	  get a chance to execute.  Also, some code such as the code
	  to assign an address space number for a process during
	  <code class="function">exec</code> on the Alpha needs to not be
	  preempted as it supports the actual context switch code.
	  Preemption is disabled for these code sections by using a
	  critical section.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53916408"></a>8.3.2.2. Critical Sections</h4></div></div></div><a id="idp53917048" class="indexterm"></a><p>The responsibility of the critical section API is to
	  prevent context switches inside of a critical section.  With
	  a fully preemptive kernel, every
	  <code class="function">setrunqueue</code> of a thread other than the
	  current thread is a preemption point.  One implementation is
	  for <code class="function">critical_enter</code> to set a per-thread
	  flag that is cleared by its counterpart.  If
	  <code class="function">setrunqueue</code> is called with this flag
	  set, it does not preempt regardless of the priority of the new
	  thread relative to the current thread.  However, since
	  critical sections are used in spin mutexes to prevent
	  context switches and multiple spin mutexes can be acquired,
	  the critical section API must support nesting.  For this
	  reason the current implementation uses a nesting count
	  instead of a single per-thread flag.</p><p>In order to minimize latency, preemptions inside of a
	  critical section are deferred rather than dropped.  If a
	  thread that would normally be preempted to is made
	  runnable while the current thread is in a critical section,
	  then a per-thread flag is set
	  to indicate that there is a pending preemption.  When the
	  outermost critical section is exited, the flag is checked.
	  If the flag is set, then the current thread is preempted to
	  allow the higher priority thread to run.</p><a id="idp53919480" class="indexterm"></a><a id="idp53919992" class="indexterm"></a><p>Interrupts pose a problem with regards to spin mutexes.
	  If a low-level interrupt handler needs a lock, it needs to
	  not interrupt any code needing that lock to avoid possible
	  data structure corruption.  Currently, providing this
	  mechanism is piggybacked onto critical section API by means
	  of the <code class="function">cpu_critical_enter</code> and
	  <code class="function">cpu_critical_exit</code> functions.  Currently
	  this API disables and re-enables interrupts on all of
	  FreeBSD's current platforms.  This approach may not be
	  purely optimal, but it is simple to understand and simple to
	  get right.  Theoretically, this second API need only be used
	  for spin mutexes that are used in primary interrupt context.
	  However, to make the code simpler, it is used for all spin
	  mutexes and even all critical sections.  It may be desirable
	  to split out the MD API from the MI API and only use it in
	  conjunction with the MI API in the spin mutex
	  implementation.  If this approach is taken, then the MD API
	  likely would need a rename to show that it is a separate
	  API.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53922040"></a>8.3.2.3. Design Tradeoffs</h4></div></div></div><p>As mentioned earlier, a couple of trade-offs have been
	  made to sacrifice cases where perfect preemption may not
	  always provide the best performance.</p><p>The first trade-off is that the preemption code does not
	  take other CPUs into account.  Suppose we have a two CPU's A
	  and B with the priority of A's thread as 4 and the priority
	  of B's thread as 2.  If CPU B makes a thread with priority 1
	  runnable, then in theory, we want CPU A to switch to the new
	  thread so that we will be running the two highest priority
	  runnable threads.  However, the cost of determining which
	  CPU to enforce a preemption on as well as actually signaling
	  that CPU via an IPI along with the synchronization that
	  would be required would be enormous.  Thus, the current code
	  would instead force CPU B to switch to the higher priority
	  thread. Note that this still puts the system in a better
	  position as CPU B is executing a thread of priority 1 rather
	  than a thread of priority 2.</p><p>The second trade-off limits immediate kernel preemption
	  to real-time priority kernel threads.  In the simple case of
	  preemption defined above, a thread is always preempted
	  immediately (or as soon as a critical section is exited) if
	  a higher priority thread is made runnable.  However, many
	  threads executing in the kernel only execute in a kernel
	  context for a short time before either blocking or returning
	  to userland.  Thus, if the kernel preempts these threads to
	  run another non-realtime kernel thread, the kernel may
	  switch out the executing thread just before it is about to
	  sleep or execute.  The cache on the CPU must then adjust to
	  the new thread.  When the kernel returns to the preempted
	  thread, it must refill all the cache information that was lost.
	  In addition, two extra context switches are performed that
	  could be avoided if the kernel deferred the preemption until
	  the first thread blocked or returned to userland.  Thus, by
	  default, the preemption code will only preempt immediately
	  if the higher priority thread is a real-time priority
	  thread.</p><p>Turning on full kernel preemption for all kernel threads
	  has value as a debugging aid since it exposes more race
	  conditions.  It is especially useful on UP systems were many
	  races are hard to simulate otherwise.  Thus, there is a
	  kernel option <code class="literal">FULL_PREEMPTION</code> to enable
	  preemption for all kernel threads that can be used for
	  debugging purposes.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53924856"></a>8.3.3. Thread Migration</h3></div></div></div><a id="idp53925496" class="indexterm"></a><p>Simply put, a thread migrates when it moves from one CPU
	to another.  In a non-preemptive kernel this can only happen
	at well-defined points such as when calling
	<code class="function">msleep</code> or returning to userland.
	However, in the preemptive kernel, an interrupt can force a
	preemption and possible migration at any time.  This can have
	negative affects on per-CPU data since with the exception of
	<code class="varname">curthread</code> and <code class="varname">curpcb</code> the
	data can change whenever you migrate.  Since you can
	potentially migrate at any time this renders unprotected
	per-CPU data access rather useless. Thus it is desirable to be
	able to disable migration for sections of code that need
	per-CPU data to be stable.</p><a id="idp53948024" class="indexterm"></a><p>Critical sections currently prevent migration since they
	do not allow context switches.  However, this may be too
	strong of a requirement to enforce in some cases since a
	critical section also effectively blocks interrupt threads on
	the current processor.  As a result, another API has been
	provided to allow the current thread to indicate that if it
	preempted it should not migrate to another CPU.</p><p>This API is known as thread pinning and is provided by the
	scheduler.  The API consists of two functions:
	<code class="function">sched_pin</code> and
	<code class="function">sched_unpin</code>.  These functions manage a
	per-thread nesting count <code class="varname">td_pinned</code>.  A
	thread is pinned when its nesting count is greater than zero
	and a thread starts off unpinned with a nesting count of zero.
	Each scheduler implementation is required to ensure that
	pinned threads are only executed on the CPU that they were
	executing on when the <code class="function">sched_pin</code> was first
	called.  Since the nesting count is only written to by the
	thread itself and is only read by other threads when the
	pinned thread is not executing but while
	<code class="varname">sched_lock</code> is held, then
	<code class="varname">td_pinned</code> does not need any locking.  The
	<code class="function">sched_pin</code> function increments the nesting
	count and <code class="function">sched_unpin</code> decrements the
	nesting count.  Note that these functions only operate on the
	current thread and bind the current thread to the CPU it is
	executing on at the time.  To bind an arbitrary thread to a
	specific CPU, the <code class="function">sched_bind</code> and
	<code class="function">sched_unbind</code> functions should be used
	instead.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53957368"></a>8.3.4. Callouts</h3></div></div></div><p>The <code class="function">timeout</code> kernel facility permits
	kernel services to register functions for execution as part
	of the <code class="function">softclock</code> software interrupt.
	Events are scheduled based on a desired number of clock
	ticks, and callbacks to the consumer-provided function
	will occur at approximately the right time.</p><p>The global list of pending timeout events is protected
	by a global spin mutex, <code class="varname">callout_lock</code>;
	all access to the timeout list must be performed with this
	mutex held.  When <code class="function">softclock</code> is
	woken up, it scans the list of pending timeouts for those
	that should fire.  In order to avoid lock order reversal,
	the <code class="function">softclock</code> thread will release the
	<code class="varname">callout_lock</code> mutex when invoking the
	provided <code class="function">timeout</code> callback function.
	If the <code class="constant">CALLOUT_MPSAFE</code> flag was not set
	during registration, then Giant will be grabbed before
	invoking the callout, and then released afterwards.  The
	<code class="varname">callout_lock</code> mutex will be re-grabbed
	before proceeding.  The <code class="function">softclock</code>
	code is careful to leave the list in a consistent state
	while releasing the mutex.  If <code class="constant">DIAGNOSTIC</code>
	is enabled, then the time taken to execute each function is
	measured, and a warning is generated if it exceeds a
	threshold.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-lock-strategies"></a>8.4. Specific Locking Strategies</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53976568"></a>8.4.1. Credentials</h3></div></div></div><a id="idp53977208" class="indexterm"></a><p><code class="varname">struct ucred</code> is the kernel's
	internal credential structure, and is generally used as the
	basis for process-driven access control within the kernel.
	BSD-derived systems use a <span class="quote">&#8220;<span class="quote">copy-on-write</span>&#8221;</span> model
	for credential data: multiple references may exist for a
	credential structure, and when a change needs to be made, the
	structure is duplicated, modified, and then the reference
	replaced.  Due to wide-spread caching of the credential to
	implement access control on open, this results in substantial
	memory savings.  With a move to fine-grained SMP, this model
	also saves substantially on locking operations by requiring
	that modification only occur on an unshared credential,
	avoiding the need for explicit synchronization when consuming
	a known-shared credential.</p><p>Credential structures with a single reference are
	considered mutable; shared credential structures must not be
	modified or a race condition is risked.  A mutex,
	<code class="varname">cr_mtxp</code> protects the reference
	count of <code class="varname">struct ucred</code> so as to
	maintain consistency.  Any use of the structure requires a
	valid reference for the duration of the use, or the structure
	may be released out from under the illegitimate
	consumer.</p><p>The <code class="varname">struct ucred</code> mutex is a leaf
	mutex and is implemented via a mutex pool for performance
	reasons.</p><p>Usually, credentials are used in a read-only manner for access
	control decisions, and in this case
	<code class="varname">td_ucred</code> is generally preferred
	because it requires no locking.  When a process' credential is
	updated the <code class="literal">proc</code> lock must be held across
	the check and update operations thus avoid races.  The process
	credential <code class="varname">p_ucred</code> must be used for
	check and update operations to prevent time-of-check,
	time-of-use races.</p><p>If system call invocations will perform access control after
	an update to the process credential, the value of
	<code class="varname">td_ucred</code> must also be refreshed to
	the current process value.  This will prevent use of a stale
	credential following a change.  The kernel automatically
	refreshes the <code class="varname">td_ucred</code> pointer in
	the thread structure from the process
	<code class="varname">p_ucred</code> whenever a process enters
	the kernel, permitting use of a fresh credential for kernel
	access control.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53985144"></a>8.4.2. File Descriptors and File Descriptor Tables</h3></div></div></div><p>Details to follow.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53986296"></a>8.4.3. Jail Structures</h3></div></div></div><a id="idp53986936" class="indexterm"></a><p><code class="varname">struct prison</code> stores
	administrative details pertinent to the maintenance of jails
	created using the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">jail</span>(2)</span></a> API.  This includes the
	per-jail hostname, IP address, and related settings.  This
	structure is reference-counted since pointers to instances of
	the structure are shared by many credential structures.  A
	single mutex, <code class="varname">pr_mtx</code> protects read
	and write access to the reference count and all mutable
	variables inside the struct jail.  Some variables are set only
	when the jail is created, and a valid reference to the
	<code class="varname">struct prison</code> is sufficient to read
	these values.  The precise locking of each entry is documented
	via comments in <code class="filename">sys/jail.h</code>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53990520"></a>8.4.4. MAC Framework</h3></div></div></div><a id="idp53991160" class="indexterm"></a><p>The TrustedBSD MAC Framework maintains data in a variety
	of kernel objects, in the form of <code class="varname">struct
	label</code>.  In general, labels in kernel objects
	are protected by the same lock as the remainder of the kernel
	object.  For example, the <code class="varname">v_label</code>
	label in <code class="varname">struct vnode</code> is protected
	by the vnode lock on the vnode.</p><p>In addition to labels maintained in standard kernel objects,
	the MAC Framework also maintains a list of registered and
	active policies.  The policy list is protected by a global
	mutex (<code class="varname">mac_policy_list_lock</code>) and a busy
	count (also protected by the mutex).  Since many access
	control checks may occur in parallel, entry to the framework
	for a read-only access to the policy list requires holding the
	mutex while incrementing (and later decrementing) the busy
	count.  The mutex need not be held for the duration of the
	MAC entry operation--some operations, such as label operations
	on file system objects--are long-lived.  To modify the policy
	list, such as during policy registration and de-registration,
	the mutex must be held and the reference count must be zero,
	to prevent modification of the list while it is in use.</p><p>A condition variable,
	<code class="varname">mac_policy_list_not_busy</code>, is available to
	threads that need to wait for the list to become unbusy, but
	this condition variable must only be waited on if the caller is
	holding no other locks, or a lock order violation may be
	possible.  The busy count, in effect, acts as a form of
	shared/exclusive lock over access to the framework: the difference
	is that, unlike with an sx lock, consumers waiting for the list
	to become unbusy may be starved, rather than permitting lock
	order problems with regards to the busy count and other locks
	that may be held on entry to (or inside) the MAC Framework.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53995256"></a>8.4.5. Modules</h3></div></div></div><a id="idp53995896" class="indexterm"></a><p>For the module subsystem there exists a single lock that is
	used to protect the shared data.  This lock is a shared/exclusive
	(SX) lock and has a good chance of needing to be acquired (shared
	or exclusively), therefore there are a few macros that have been
	added to make access to the lock more easy.  These macros can be
	located in <code class="filename">sys/module.h</code> and are quite basic
	in terms of usage.  The main structures protected under this lock
	are the <code class="varname">module_t</code> structures (when shared)
	and the global <code class="varname">modulelist_t</code> structure,
	modules.  One should review the related source code in
	<code class="filename">kern/kern_module.c</code> to further understand the
	locking strategy.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53998712"></a>8.4.6. Newbus Device Tree</h3></div></div></div><a id="idp53999352" class="indexterm"></a><p>The newbus system will have one sx lock.  Readers will
	hold a shared (read) lock (<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sx_slock&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sx_slock</span>(9)</span></a>) and writers will hold
	an exclusive (write) lock (<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sx_xlock&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sx_xlock</span>(9)</span></a>).  Internal functions
	will not do locking at all.  Externally visible ones will lock as
	needed.
	Those items that do not matter if the race is won or lost will
	not be locked, since they tend to be read all over the place
	(e.g., <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=device_get_softc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">device_get_softc</span>(9)</span></a>).  There will be relatively few
	changes to the newbus data structures, so a single lock should
	be sufficient and not impose a performance penalty.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54006776"></a>8.4.7. Pipes</h3></div></div></div><p>...</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54007928"></a>8.4.8. Processes and Threads</h3></div></div></div><p>- process hierarchy</p><p>- proc locks, references</p><p>- thread-specific copies of proc entries to freeze during system
	calls, including td_ucred</p><p>- inter-process operations</p><p>- process groups and sessions</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54010616"></a>8.4.9. Scheduler</h3></div></div></div><a id="idp54011256" class="indexterm"></a><p>Lots of references to <code class="varname">sched_lock</code> and notes
	pointing at specific primitives and related magic elsewhere in the
	document.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54012664"></a>8.4.10. Select and Poll</h3></div></div></div><p>The <code class="function">select</code> and
	<code class="function">poll</code> functions permit threads to block
	waiting on events on file descriptors--most frequently,
	whether or not the file descriptors are readable or
	writable.</p><p>...</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54027256"></a>8.4.11. SIGIO</h3></div></div></div><p>The SIGIO service permits processes to request the delivery
	of a SIGIO signal to its process group when the read/write
	status of specified file descriptors changes.  At most one
	process or process group is permitted to register for SIGIO
	from any given kernel object, and that process or group is
	referred to as the owner.  Each object supporting SIGIO
	registration contains pointer field that is
	<code class="constant">NULL</code> if the object is not registered, or
	points to a <code class="varname">struct sigio</code> describing
	the registration.  This field is protected by a global mutex,
	<code class="varname">sigio_lock</code>.  Callers to SIGIO maintenance
	functions must pass in this field <span class="quote">&#8220;<span class="quote">by reference</span>&#8221;</span>
	so that local register copies of the field are not made when
	unprotected by the lock.</p><p>One <code class="varname">struct sigio</code> is allocated for
	each registered object associated with any process or process
	group, and contains back-pointers to the object, owner, signal
	information, a credential, and the general disposition of the
	registration.  Each process or progress group contains a list of
	registered <code class="varname">struct sigio</code> structures,
	<code class="varname">p_sigiolst</code> for processes, and
	<code class="varname">pg_sigiolst</code> for process groups.
	These lists are protected by the process or process group
	locks respectively.  Most fields in each <code class="varname">struct
	sigio</code> are constant for the duration of the
	registration, with the exception of the
	<code class="varname">sio_pgsigio</code> field which links the
	<code class="varname">struct sigio</code> into the process or
	process group list.  Developers implementing new kernel
	objects supporting SIGIO will, in general, want to avoid
	holding structure locks while invoking SIGIO supporting
	functions, such as <code class="function">fsetown</code>
	or <code class="function">funsetown</code> to avoid
	defining a lock order between structure locks and the global
	SIGIO lock.  This is generally possible through use of an
	elevated reference count on the structure, such as reliance
	on a file descriptor reference to a pipe during a pipe
	operation.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54039032"></a>8.4.12. Sysctl</h3></div></div></div><p>The <code class="function">sysctl</code> MIB service is invoked
	from both within the kernel and from userland applications
	using a system call.  At least two issues are raised in
	locking: first, the protection of the structures maintaining
	the namespace, and second, interactions with kernel variables
	and functions that are accessed by the sysctl interface.
	Since sysctl permits the direct export (and modification) of
	kernel statistics and configuration parameters, the sysctl
	mechanism must become aware of appropriate locking semantics
	for those variables.  Currently, sysctl makes use of a single
	global sx lock to serialize use of
	<code class="function">sysctl</code>; however, it is assumed to operate
	under Giant and other protections are not provided.  The
	remainder of this section speculates on locking and semantic
	changes to sysctl.</p><p>- Need to change the order of operations for sysctl's that
	update values from read old, copyin and copyout, write new to
	copyin, lock, read old and write new, unlock, copyout.  Normal
	sysctl's that just copyout the old value and set a new value
	that they copyin may still be able to follow the old model.
	However, it may be cleaner to use the second model for all of
	the sysctl handlers to avoid lock operations.</p><p>- To allow for the common case, a sysctl could embed a
	pointer to a mutex in the SYSCTL_FOO macros and in the struct.
	This would work for most sysctl's.  For values protected by sx
	locks, spin mutexes, or other locking strategies besides a
	single sleep mutex, SYSCTL_PROC nodes could be used to get the
	locking right.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54041720"></a>8.4.13. Taskqueue</h3></div></div></div><p> The taskqueue's interface has two basic locks associated
	with it in order to protect the related shared data.  The
	<code class="varname">taskqueue_queues_mutex</code> is meant to serve as a
	lock to protect the <code class="varname">taskqueue_queues</code> TAILQ.
	The other mutex lock associated with this system is the one in the
	<code class="varname">struct taskqueue</code> data structure.  The
	use of the synchronization primitive here is to protect the
	integrity of the data in the <code class="varname">struct
	taskqueue</code>.  It should be noted that there are no
	separate macros to assist the user in locking down his/her own work
	since these locks are most likely not going to be used outside of
	<code class="filename">kern/subr_taskqueue.c</code>.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-implementation-notes"></a>8.5. Implementation Notes</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54046200"></a>8.5.1. Sleep Queues</h3></div></div></div><p>A sleep queue is a structure that holds the list of
	threads asleep on a wait channel.  Each thread that is not
	asleep on a wait channel carries a sleep queue structure
	around with it.  When a thread blocks on a wait channel, it
	donates its sleep queue structure to that wait channel.  Sleep
	queues associated with a wait channel are stored in a hash
	table.</p><p>The sleep queue hash table holds sleep queues for wait
	channels that have at least one blocked thread.  Each entry in
	the hash table is called a sleepqueue chain.  The chain
	contains a linked list of sleep queues and a spin mutex.  The
	spin mutex protects the list of sleep queues as well as the
	contents of the sleep queue structures on the list.  Only one
	sleep queue is associated with a given wait channel.  If
	multiple threads block on a wait channel than the sleep queues
	associated with all but the first thread are stored on a list
	of free sleep queues in the master sleep queue.  When a thread
	is removed from the sleep queue it is given one of the sleep
	queue structures from the master queue's free list if it is
	not the only thread asleep on the queue.  The last thread is
	given the master sleep queue when it is resumed.  Since
	threads may be removed from the sleep queue in a different
	order than they are added, a thread may depart from a sleep
	queue with a different sleep queue structure than the one it
	arrived with.</p><p>The <code class="function">sleepq_lock</code> function locks the
	spin mutex of the sleep queue chain that maps to a specific
	wait channel.  The <code class="function">sleepq_lookup</code> function
	looks in the hash table for the master sleep queue associated
	with a given wait channel.  If no master sleep queue is found,
	it returns <code class="constant">NULL</code>.  The
	<code class="function">sleepq_release</code> function unlocks the spin
	mutex associated with a given wait channel.</p><p>A thread is added to a sleep queue via the
	<code class="function">sleepq_add</code>.  This function accepts the
	wait channel, a pointer to the mutex that protects the wait
	channel, a wait message description string, and a mask of
	flags.  The sleep queue chain should be locked via
	<code class="function">sleepq_lock</code> before this function is
	called.  If no mutex protects the wait channel (or it is
	protected by Giant), then the mutex pointer argument should be
	<code class="constant">NULL</code>.  The flags argument contains a type
	field that indicates the kind of sleep queue that the thread
	is being added to and a flag to indicate if the sleep is
	interruptible (<code class="constant">SLEEPQ_INTERRUPTIBLE</code>).
	Currently there are only two types of sleep queues:
	traditional sleep queues managed via the
	<code class="function">msleep</code> and <code class="function">wakeup</code>
	functions (<code class="constant">SLEEPQ_MSLEEP</code>) and condition
	variable sleep queues (<code class="constant">SLEEPQ_CONDVAR</code>).
	The sleep queue type and lock pointer argument are used solely
	for internal assertion checking.  Code that calls
	<code class="function">sleepq_add</code> should explicitly unlock any
	interlock protecting the wait channel after the associated
	sleepqueue chain has been locked via
	<code class="function">sleepq_lock</code> and before blocking on the
	sleep queue via one of the waiting functions.</p><p>A timeout for a sleep is set by invoking
	<code class="function">sleepq_set_timeout</code>.  The function accepts
	the wait channel and the timeout time as a relative tick count
	as its arguments.  If a sleep should be interrupted by
	arriving signals, the
	<code class="function">sleepq_catch_signals</code> function should be
	called as well.  This function accepts the wait channel as its
	only parameter.  If there is already a signal pending for this
	thread, then <code class="function">sleepq_catch_signals</code> will
	return a signal number; otherwise, it will return 0.</p><p>Once a thread has been added to a sleep queue, it blocks
	using one of the <code class="function">sleepq_wait</code> functions.
	There are four wait functions depending on whether or not the
	caller wishes to use a timeout or have the sleep aborted by
	caught signals or an interrupt from the userland thread
	scheduler.  The <code class="function">sleepq_wait</code> function
	simply waits until the current thread is explicitly resumed by
	one of the wakeup functions.  The
	<code class="function">sleepq_timedwait</code> function waits until
	either the thread is explicitly resumed or the timeout set by
	an earlier call to <code class="function">sleepq_set_timeout</code>
	expires.  The <code class="function">sleepq_wait_sig</code> function
	waits until either the thread is explicitly resumed or its
	sleep is aborted.  The
	<code class="function">sleepq_timedwait_sig</code> function waits until
	either the thread is explicitly resumed, the timeout set by an
	earlier call to <code class="function">sleepq_set_timeout</code>
	expires, or the thread's sleep is aborted.  All of the wait
	functions accept the wait channel as their first parameter.
	In addition, the <code class="function">sleepq_timedwait_sig</code>
	function accepts a second boolean parameter to indicate if the
	earlier call to <code class="function">sleepq_catch_signals</code>
	found a pending signal.</p><p>If the thread is explicitly resumed or is aborted by a
	signal, then a value of zero is returned by the wait function
	to indicate a successful sleep.  If the thread is resumed by
	either a timeout or an interrupt from the userland thread
	scheduler then an appropriate errno value is returned instead.
	Note that since <code class="function">sleepq_wait</code> can only
	return 0 it does not return anything and the caller should
	assume a successful sleep.  Also, if a thread's sleep times
	out and is aborted simultaneously then
	<code class="function">sleepq_timedwait_sig</code> will return an error
	indicating that a timeout occurred.  If an error value of
	0 is returned and either <code class="function">sleepq_wait_sig</code>
	or <code class="function">sleepq_timedwait_sig</code> was used to
	block, then the function
	<code class="function">sleepq_calc_signal_retval</code> should be
	called to check for any pending signals and calculate an
	appropriate return value if any are found.  The signal number
	returned by the earlier call to
	<code class="function">sleepq_catch_signals</code> should be passed as
	the sole argument to
	<code class="function">sleepq_calc_signal_retval</code>.</p><p>Threads asleep on a wait channel are explicitly resumed by
	the <code class="function">sleepq_broadcast</code> and
	<code class="function">sleepq_signal</code> functions.  Both functions
	accept the wait channel from which to resume threads, a
	priority to raise resumed threads to, and a flags argument to
	indicate which type of sleep queue is being resumed.  The
	priority argument is treated as a minimum priority.  If a
	thread being resumed already has a higher priority
	(numerically lower) than the priority argument then its
	priority is not adjusted.  The flags argument is used for
	internal assertions to ensure that sleep queues are not being
	treated as the wrong type.  For example, the condition
	variable functions should not resume threads on a traditional
	sleep queue.  The <code class="function">sleepq_broadcast</code>
	function resumes all threads that are blocked on the specified
	wait channel while <code class="function">sleepq_signal</code> only
	resumes the highest priority thread blocked on the wait
	channel.  The sleep queue chain should first be locked via the
	<code class="function">sleepq_lock</code> function before calling these
	functions.</p><p>A sleeping thread may have its sleep interrupted by
	calling the <code class="function">sleepq_abort</code> function.  This
	function must be called with <code class="varname">sched_lock</code>
	held and the thread must be queued on a sleep queue.  A thread
	may also be removed from a specific sleep queue via the
	<code class="function">sleepq_remove</code> function.  This function
	accepts both a thread and a wait channel as an argument and
	only awakens the thread if it is on the sleep queue for the
	specified wait channel.  If the thread is not on a sleep queue
	or it is on a sleep queue for a different wait channel, then
	this function does nothing.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54086904"></a>8.5.2. Turnstiles</h3></div></div></div><a id="idp54087544" class="indexterm"></a><p>- Compare/contrast with sleep queues.</p><p>- Lookup/wait/release.
        - Describe TDF_TSNOBLOCK race.</p><p>- Priority propagation.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54089336"></a>8.5.3. Details of the Mutex Implementation</h3></div></div></div><p>- Should we require mutexes to be owned for mtx_destroy()
	since we can not safely assert that they are unowned by anyone
	else otherwise?</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54090360"></a>8.5.3.1. Spin Mutexes</h4></div></div></div><a id="idp54091000" class="indexterm"></a><p>- Use a critical section...</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54092280"></a>8.5.3.2. Sleep Mutexes</h4></div></div></div><a id="idp54092920" class="indexterm"></a><p>- Describe the races with contested mutexes</p><p>- Why it is safe to read mtx_lock of a contested mutex
	  when holding the turnstile chain lock.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54115192"></a>8.5.4. Witness</h3></div></div></div><a id="idp54115832" class="indexterm"></a><p>- What does it do</p><p>- How does it work</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="smp-misc"></a>8.6. Miscellaneous Topics</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54118136"></a>8.6.1. Interrupt Source and ICU Abstractions</h3></div></div></div><p>- struct isrc</p><p>- pic drivers</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54119672"></a>8.6.2. Other Random Questions/Topics</h3></div></div></div><p>- Should we pass an interlock into
	<code class="function">sema_wait</code>?</p><p>- Should we have non-sleepable sx locks?</p><p>- Add some info about proper use of reference counts.</p></div></div><div class="glossary"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="smp-glossary"></a>Glossary</h2></div></div></div><dl><dt><a id="smp-glossary-atomic"></a><span class="glossterm">atomic</span></dt><dd class="glossdef"><p>An operation is atomic if all of its effects are visible
	  to other CPUs together when the proper access protocol is
	  followed.  In the degenerate case are atomic instructions
	  provided directly by machine architectures.  At a higher
	  level, if several members of a structure are protected by a
	  lock, then a set of operations are atomic if they are all
	  performed while holding the lock without releasing the lock
	  in between any of the operations.</p><p>See Also operation.</p></dd><dt><a id="smp-glossary-block"></a><span class="glossterm">block</span></dt><dd class="glossdef"><p>A thread is blocked when it is waiting on a lock,
	  resource, or condition.  Unfortunately this term is a bit
	  overloaded as a result.</p><p>See Also sleep.</p></dd><dt><a id="smp-glossary-critical-section"></a><span class="glossterm">critical section</span></dt><dd class="glossdef"><p>A section of code that is not allowed to be preempted.
	  A critical section is entered and exited using the
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=critical_enter&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">critical_enter</span>(9)</span></a> API.</p></dd><dt><a id="smp-glossary-MD"></a><span class="glossterm">MD</span></dt><dd class="glossdef"><p>Machine dependent.</p><p>See Also MI.</p></dd><dt><a id="smp-glossary-memory-operation"></a><span class="glossterm">memory operation</span></dt><dd class="glossdef"><p>A memory operation reads and/or writes to a memory
	  location.</p></dd><dt><a id="smp-glossary-MI"></a><span class="glossterm">MI</span></dt><dd class="glossdef"><p>Machine independent.</p><p>See Also MD.</p></dd><dt><a id="smp-glossary-operation"></a><span class="glossterm">operation</span></dt><dd><p>See memory operation.</p></dd><dt><a id="smp-glossary-primary-interrupt-context"></a><span class="glossterm">primary interrupt context</span></dt><dd class="glossdef"><p>Primary interrupt context refers to the code that runs
	  when an interrupt occurs.  This code can either run an
	  interrupt handler directly or schedule an asynchronous
	  interrupt thread to execute the interrupt handlers for a
	  given interrupt source.</p></dd><dt><span class="glossterm">realtime kernel thread</span></dt><dd class="glossdef"><p>A high priority kernel thread.  Currently, the only
	  realtime priority kernel threads are interrupt threads.</p><p>See Also thread.</p></dd><dt><a id="smp-glossary-sleep"></a><span class="glossterm">sleep</span></dt><dd class="glossdef"><p>A thread is asleep when it is blocked on a condition
	  variable or a sleep queue via <code class="function">msleep</code> or
	  <code class="function">tsleep</code>.</p><p>See Also block.</p></dd><dt><a id="smp-glossary-sleepable-lock"></a><span class="glossterm">sleepable lock</span></dt><dd class="glossdef"><p>A sleepable lock is a lock that can be held by a thread
	  which is asleep.  Lockmgr locks and sx locks are currently
	  the only sleepable locks in FreeBSD.  Eventually, some sx
	  locks such as the allproc and proctree locks may become
	  non-sleepable locks.</p><p>See Also sleep.</p></dd><dt><a id="smp-glossary-thread"></a><span class="glossterm">thread</span></dt><dd class="glossdef"><p>A kernel thread represented by a struct thread.  Threads own
	  locks and hold a single execution context.</p></dd><dt><a id="smp-glossary-wait-channel"></a><span class="glossterm">wait channel</span></dt><dd class="glossdef"><p>A kernel virtual address that threads may sleep on.</p></dd></dl></div></div></div><div class="part"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="devicedrivers"></a>Part II. Device Drivers</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="chapter"><a href="#driverbasics">9. Writing FreeBSD Device Drivers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#driverbasics-intro">9.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#driverbasics-kld">9.2. Dynamic Kernel Linker Facility - KLD</a></span></dt><dt><span class="sect1"><a href="#driverbasics-char">9.3. Character Devices</a></span></dt><dt><span class="sect1"><a href="#driverbasics-block">9.4. Block Devices (Are Gone)</a></span></dt><dt><span class="sect1"><a href="#driverbasics-net">9.5. Network Drivers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#isa-driver">10. ISA Device Drivers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#isa-driver-synopsis">10.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#isa-driver-basics">10.2. Basic Information</a></span></dt><dt><span class="sect1"><a href="#isa-driver-device-t">10.3. <code class="varname">device_t</code> Pointer</a></span></dt><dt><span class="sect1"><a href="#isa-driver-config">10.4. Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</a></span></dt><dt><span class="sect1"><a href="#isa-driver-resources">10.5. Resources</a></span></dt><dt><span class="sect1"><a href="#isa-driver-busmem">10.6. Bus Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#isa-driver-dma">10.7. DMA</a></span></dt><dt><span class="sect1"><a href="#isa-driver-probe">10.8. xxx_isa_probe</a></span></dt><dt><span class="sect1"><a href="#isa-driver-attach">10.9. xxx_isa_attach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-detach">10.10. xxx_isa_detach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-shutdown">10.11. xxx_isa_shutdown</a></span></dt><dt><span class="sect1"><a href="#isa-driver-intr">10.12. xxx_intr</a></span></dt></dl></dd><dt><span class="chapter"><a href="#pci">11. PCI Devices</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pci-probe">11.1. Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#pci-bus">11.2. Bus Resources</a></span></dt></dl></dd><dt><span class="chapter"><a href="#scsi">12. Common Access Method SCSI Controllers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#scsi-synopsis">12.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#scsi-general">12.2. General Architecture</a></span></dt><dt><span class="sect1"><a href="#scsi-polling">12.3. Polling</a></span></dt><dt><span class="sect1"><a href="#scsi-async">12.4. Asynchronous Events</a></span></dt><dt><span class="sect1"><a href="#scsi-interrupts">12.5. Interrupts</a></span></dt><dt><span class="sect1"><a href="#scsi-errors">12.6. Errors Summary</a></span></dt><dt><span class="sect1"><a href="#scsi-timeout">12.7. Timeout Handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#usb">13. USB Devices</a></span></dt><dd><dl><dt><span class="sect1"><a href="#usb-intro">13.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#usb-hc">13.2. Host Controllers</a></span></dt><dt><span class="sect1"><a href="#usb-dev">13.3. USB Device Information</a></span></dt><dt><span class="sect1"><a href="#usb-devprobe">13.4. Device Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#usb-protocol">13.5. USB Drivers Protocol Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#newbus">14. Newbus</a></span></dt><dd><dl><dt><span class="sect1"><a href="#newbus-devdrivers">14.1. Device Drivers</a></span></dt><dt><span class="sect1"><a href="#newbus-overview">14.2. Overview of Newbus</a></span></dt><dt><span class="sect1"><a href="#newbus-api">14.3. Newbus API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#oss">15. Sound Subsystem</a></span></dt><dd><dl><dt><span class="sect1"><a href="#oss-intro">15.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#oss-files">15.2. Files</a></span></dt><dt><span class="sect1"><a href="#pcm-probe-and-attach">15.3. Probing, Attaching, etc.</a></span></dt><dt><span class="sect1"><a href="#oss-interfaces">15.4. Interfaces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#pccard">16. PC Card</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pccard-adddev">16.1. Adding a Device</a></span></dt></dl></dd></dl></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="driverbasics"></a>Chapter 9. Writing FreeBSD Device Drivers</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Murray</span> <span class="surname">Stokely</span></span>. </span></div><div><span class="authorgroup">Based on intro(4) manual page by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Jörg</span> <span class="surname">Wunsch</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#driverbasics-intro">9.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#driverbasics-kld">9.2. Dynamic Kernel Linker Facility - KLD</a></span></dt><dt><span class="sect1"><a href="#driverbasics-char">9.3. Character Devices</a></span></dt><dt><span class="sect1"><a href="#driverbasics-block">9.4. Block Devices (Are Gone)</a></span></dt><dt><span class="sect1"><a href="#driverbasics-net">9.5. Network Drivers</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="driverbasics-intro"></a>9.1. Introduction</h2></div></div></div><a id="idp53795960" class="indexterm"></a><a id="idp53796472" class="indexterm"></a><p>This chapter provides a brief introduction to writing device
      drivers for FreeBSD.  A device in this context is a term used
      mostly for hardware-related stuff that belongs to the system,
      like disks, printers, or a graphics display with its keyboard.
      A device driver is the software component of the operating
      system that controls a specific device.  There are also
      so-called pseudo-devices where a device driver emulates the
      behavior of a device in software without any particular
      underlying hardware.  Device drivers can be compiled into the
      system statically or loaded on demand through the dynamic kernel
      linker facility `kld'.</p><a id="idp53797368" class="indexterm"></a><p>Most devices in a <span class="trademark">UNIX</span>®-like operating system are accessed
      through device-nodes, sometimes also called special files.
      These files are usually located under the directory
      <code class="filename">/dev</code> in the filesystem hierarchy.</p><p>Device drivers can roughly be broken down into two
      categories; character and network device drivers.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="driverbasics-kld"></a>9.2. Dynamic Kernel Linker Facility - KLD</h2></div></div></div><a id="idp53800440" class="indexterm"></a><a id="idp53801592" class="indexterm"></a><p>The kld interface allows system administrators to
      dynamically add and remove functionality from a running system.
      This allows device driver writers to load their new changes into
      a running kernel without constantly rebooting to test
      changes.</p><a id="idp53802744" class="indexterm"></a><a id="idp53807992" class="indexterm"></a><a id="idp53809144" class="indexterm"></a><p>The kld interface is used through:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="command">kldload</code> - loads a new kernel
	  module</li><li class="listitem"><code class="command">kldunload</code> - unloads a kernel
	  module</li><li class="listitem"><code class="command">kldstat</code> - lists loaded
	  modules</li></ul></div><p>Skeleton Layout of a kernel module</p><pre class="programlisting">/*
 * KLD Skeleton
 * Inspired by Andrew Reiter's Daemonnews article
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */

/*
 * Load handler that deals with the loading and unloading of a KLD.
 */

static int
skel_loader(struct module *m, int what, void *arg)
{
  int err = 0;

  switch (what) {
  case MOD_LOAD:                /* kldload */
    uprintf("Skeleton KLD loaded.\n");
    break;
  case MOD_UNLOAD:
    uprintf("Skeleton KLD unloaded.\n");
    break;
  default:
    err = EOPNOTSUPP;
    break;
  }
  return(err);
}

/* Declare this module to the rest of the kernel */

static moduledata_t skel_mod = {
  "skel",
  skel_loader,
  NULL
};

DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);</pre><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp53814520"></a>9.2.1. Makefile</h3></div></div></div><p>FreeBSD provides a system makefile to simplify compiling a
	kernel module.</p><pre class="programlisting">SRCS=skeleton.c
KMOD=skeleton

.include &lt;bsd.kmod.mk&gt;</pre><p>Running <code class="command">make</code> with this makefile
	will create a file <code class="filename">skeleton.ko</code> that can
	be loaded into the kernel by typing:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload -v ./skeleton.ko</code></strong></pre></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="driverbasics-char"></a>9.3. Character Devices</h2></div></div></div><a id="idp54183544" class="indexterm"></a><p>A character device driver is one that transfers data
      directly to and from a user process.  This is the most common
      type of device driver and there are plenty of simple examples in
      the source tree.</p><p>This simple example pseudo-device remembers whatever values
      are written to it and can then echo them back when
      read.</p><div class="example"><a id="idp54197368"></a><div class="example-title">Example 9.1. Example of a Sample Echo Pseudo-Device Driver for
	FreeBSD 10.X - 12.X</div><div class="example-contents"><pre class="programlisting">/*
 * Simple Echo pseudo-device KLD
 *
 * Murray Stokely
 * Søren (Xride) Straarup
 * Eitan Adler
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;

#define BUFFERSIZE 255

/* Function prototypes */
static d_open_t      echo_open;
static d_close_t     echo_close;
static d_read_t      echo_read;
static d_write_t     echo_write;

/* Character device entry points */
static struct cdevsw echo_cdevsw = {
	.d_version = D_VERSION,
	.d_open = echo_open,
	.d_close = echo_close,
	.d_read = echo_read,
	.d_write = echo_write,
	.d_name = "echo",
};

struct s_echo {
	char msg[BUFFERSIZE + 1];
	int len;
};

/* vars */
static struct cdev *echo_dev;
static struct s_echo *echomsg;

MALLOC_DECLARE(M_ECHOBUF);
MALLOC_DEFINE(M_ECHOBUF, "echobuffer", "buffer for echo module");

/*
 * This function is called by the kld[un]load(2) system calls to
 * determine what actions to take when a module is loaded or unloaded.
 */
static int
echo_loader(struct module *m __unused, int what, void *arg __unused)
{
	int error = 0;

	switch (what) {
	case MOD_LOAD:                /* kldload */
		error = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,
		    &amp;echo_dev,
		    &amp;echo_cdevsw,
		    0,
		    UID_ROOT,
		    GID_WHEEL,
		    0600,
		    "echo");
		if (error != 0)
			break;

		echomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |
		    M_ZERO);
		printf("Echo device loaded.\n");
		break;
	case MOD_UNLOAD:
		destroy_dev(echo_dev);
		free(echomsg, M_ECHOBUF);
		printf("Echo device unloaded.\n");
		break;
	default:
		error = EOPNOTSUPP;
		break;
	}
	return (error);
}

static int
echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,
    struct thread *td __unused)
{
	int error = 0;

	uprintf("Opened device \"echo\" successfully.\n");
	return (error);
}

static int
echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,
    struct thread *td __unused)
{

	uprintf("Closing device \"echo\".\n");
	return (0);
}

/*
 * The read function just takes the buf that was saved via
 * echo_write() and returns it to userland for accessing.
 * uio(9)
 */
static int
echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
{
	size_t amt;
	int error;

	/*
	 * How big is this read operation?  Either as big as the user wants,
	 * or as big as the remaining data.  Note that the 'len' does not
	 * include the trailing null character.
	 */
	amt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :
	    echomsg-&gt;len + 1 - uio-&gt;uio_offset);

	if ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)
		uprintf("uiomove failed!\n");

	return (error);
}

/*
 * echo_write takes in a character string and saves it
 * to buf for later accessing.
 */
static int
echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
{
	size_t amt;
	int error;

	/*
	 * We either write from the beginning or are appending -- do
	 * not allow random access.
	 */
	if (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))
		return (EINVAL);

	/* This is a new message, reset length */
	if (uio-&gt;uio_offset == 0)
		echomsg-&gt;len = 0;

	/* Copy the string in from user memory to kernel memory */
	amt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));

	error = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);

	/* Now we need to null terminate and record the length */
	echomsg-&gt;len = uio-&gt;uio_offset;
	echomsg-&gt;msg[echomsg-&gt;len] = 0;

	if (error != 0)
		uprintf("Write failed: bad address!\n");
	return (error);
}

DEV_MODULE(echo, echo_loader, NULL);</pre></div></div><br class="example-break" /><p>With this driver loaded try:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>echo -n "Test Data" &gt; /dev/echo</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cat /dev/echo</code></strong>
Opened device "echo" successfully.
Test Data
Closing device "echo".</pre><p>Real hardware devices are described in the next
      chapter.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="driverbasics-block"></a>9.4. Block Devices (Are Gone)</h2></div></div></div><a id="idp54226552" class="indexterm"></a><p>Other <span class="trademark">UNIX</span>® systems may support a second type of disk
      device known as block devices.  Block devices are disk devices
      for which the kernel provides caching.  This caching makes
      block-devices almost unusable, or at least dangerously
      unreliable.  The caching will reorder the sequence of write
      operations, depriving the application of the ability to know the
      exact disk contents at any one instant in time.</p><p>This makes predictable and reliable crash recovery of
      on-disk data structures (filesystems, databases, etc.)
      impossible.  Since writes may be delayed, there is no way
      the kernel can report to the application which particular
      write operation encountered a write error, this further
      compounds the consistency problem.</p><p>For this reason, no serious applications rely on block
      devices, and in fact, almost all applications which access
      disks directly take great pains to specify that character
      (or <span class="quote">&#8220;<span class="quote">raw</span>&#8221;</span>) devices should always be used.  Because
      the implementation of the aliasing of each disk (partition) to
      two devices with different semantics significantly complicated
      the relevant kernel code FreeBSD dropped support for cached disk
      devices as part of the modernization of the disk I/O
      infrastructure.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="driverbasics-net"></a>9.5. Network Drivers</h2></div></div></div><a id="idp54242296" class="indexterm"></a><p>Drivers for network devices do not use device nodes in order
      to be accessed.  Their selection is based on other decisions
      made inside the kernel and instead of calling open(), use of a
      network device is generally introduced by using the system call
      socket(2).</p><p>For more information see ifnet(9), the source of the
      loopback device, and Bill Paul's network drivers.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="isa-driver"></a>Chapter 10. ISA Device Drivers</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Sergey</span> <span class="surname">Babkin</span></span>. </span></div><div><span class="authorgroup">Modifications for Handbook made by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Murray</span> <span class="surname">Stokely</span></span>, <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Valentino</span> <span class="surname">Vaschetto</span></span> and <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Wylie</span> <span class="surname">Stilwell</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#isa-driver-synopsis">10.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#isa-driver-basics">10.2. Basic Information</a></span></dt><dt><span class="sect1"><a href="#isa-driver-device-t">10.3. <code class="varname">device_t</code> Pointer</a></span></dt><dt><span class="sect1"><a href="#isa-driver-config">10.4. Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</a></span></dt><dt><span class="sect1"><a href="#isa-driver-resources">10.5. Resources</a></span></dt><dt><span class="sect1"><a href="#isa-driver-busmem">10.6. Bus Memory Mapping</a></span></dt><dt><span class="sect1"><a href="#isa-driver-dma">10.7. DMA</a></span></dt><dt><span class="sect1"><a href="#isa-driver-probe">10.8. xxx_isa_probe</a></span></dt><dt><span class="sect1"><a href="#isa-driver-attach">10.9. xxx_isa_attach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-detach">10.10. xxx_isa_detach</a></span></dt><dt><span class="sect1"><a href="#isa-driver-shutdown">10.11. xxx_isa_shutdown</a></span></dt><dt><span class="sect1"><a href="#isa-driver-intr">10.12. xxx_intr</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-synopsis"></a>10.1. Synopsis</h2></div></div></div><a id="idp54251128" class="indexterm"></a><a id="idp54251640" class="indexterm"></a><p>This chapter introduces the issues relevant to writing a
      driver for an ISA device.  The pseudo-code presented here is
      rather detailed and reminiscent of the real code but is still
      only pseudo-code. It avoids the details irrelevant to the
      subject of the discussion. The real-life examples can be found
      in the source code of real drivers. In particular the drivers
      <code class="literal">ep</code> and <code class="literal">aha</code> are good sources of information.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-basics"></a>10.2. Basic Information</h2></div></div></div><p>A typical ISA driver would need the following include
      files:</p><pre class="programlisting">#include &lt;sys/module.h&gt;
#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;
#include &lt;machine/resource.h&gt;
#include &lt;sys/rman.h&gt;

#include &lt;isa/isavar.h&gt;
#include &lt;isa/pnpvar.h&gt;</pre><p>They describe the things specific to the ISA and generic
      bus subsystem.</p><a id="idp54255608" class="indexterm"></a><p>The bus subsystem is implemented in an object-oriented
      fashion, its main structures are accessed by associated method
      functions.</p><a id="idp54256504" class="indexterm"></a><p>The list of bus methods implemented by an ISA driver is like
      one for any other bus. For a hypothetical driver named <span class="quote">&#8220;<span class="quote">xxx</span>&#8221;</span>
      they would be:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">static void xxx_isa_identify (driver_t *,
          device_t);</code> Normally used for bus drivers, not
          device drivers. But for ISA devices this method may have
          special use: if the device provides some device-specific
          (non-PnP) way to auto-detect devices this routine may
          implement it.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_probe (device_t
          dev);</code> Probe for a device at a known (or PnP)
          location. This routine can also accommodate device-specific
          auto-detection of parameters for partially configured
          devices.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_attach (device_t
          dev);</code> Attach and initialize device.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_detach (device_t
          dev);</code> Detach device before unloading the driver
          module.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_shutdown (device_t
          dev);</code> Execute shutdown of the device before
          system shutdown.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_suspend (device_t
          dev);</code> Suspend the device before the system goes
          to the power-save state. May also abort transition to the
          power-save state.</p></li><li class="listitem"><p><code class="function">static int xxx_isa_resume (device_t
 	  dev);</code> Resume the device activity after return
 	  from power-save state.</p></li></ul></div><p><code class="function">xxx_isa_probe()</code> and
      <code class="function">xxx_isa_attach()</code> are mandatory, the rest of
      the routines are optional, depending on the device's
      needs.</p><p>The driver is linked to the system with the following set of
      descriptions.</p><pre class="programlisting">    /* table of supported bus methods */
    static device_method_t xxx_isa_methods[] = {
        /* list all the bus method functions supported by the driver */
        /* omit the unsupported methods */
        DEVMETHOD(device_identify,  xxx_isa_identify),
        DEVMETHOD(device_probe,     xxx_isa_probe),
        DEVMETHOD(device_attach,    xxx_isa_attach),
        DEVMETHOD(device_detach,    xxx_isa_detach),
        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),
        DEVMETHOD(device_suspend,   xxx_isa_suspend),
        DEVMETHOD(device_resume,    xxx_isa_resume),

	DEVMETHOD_END
    };

    static driver_t xxx_isa_driver = {
        "xxx",
        xxx_isa_methods,
        sizeof(struct xxx_softc),
    };


    static devclass_t xxx_devclass;

    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,
        load_function, load_argument);</pre><a id="idp54283640" class="indexterm"></a><p>Here struct <code class="varname">xxx_softc</code> is a
        device-specific structure that contains private driver data
        and descriptors for the driver's resources.  The bus code
        automatically allocates one softc descriptor per device as
        needed.</p><a id="idp54285048" class="indexterm"></a><p>If the driver is implemented as a loadable module then
        <code class="function">load_function()</code> is called to do
        driver-specific initialization or clean-up when the driver is
        loaded or unloaded and load_argument is passed as one of its
        arguments.  If the driver does not support dynamic loading (in
        other words it must always be linked into the kernel) then these
        values should be set to 0 and the last definition would look
        like:</p><pre class="programlisting"> DRIVER_MODULE(xxx, isa, xxx_isa_driver,
       xxx_devclass, 0, 0);</pre><a id="idp54286712" class="indexterm"></a><p>If the driver is for a device which supports PnP then a
        table of supported PnP IDs must be defined.  The table
        consists of a list of PnP IDs supported by this driver and
        human-readable descriptions of the hardware types and models
        having these IDs. It looks like:</p><pre class="programlisting">    static struct isa_pnp_id xxx_pnp_ids[] = {
        /* a line for each supported PnP ID */
        { 0x12345678,   "Our device model 1234A" },
        { 0x12345679,   "Our device model 1234B" },
        { 0,        NULL }, /* end of table */
    };</pre><p>If the driver does not support PnP devices it still needs
        an empty PnP ID table, like:</p><pre class="programlisting">    static struct isa_pnp_id xxx_pnp_ids[] = {
        { 0,        NULL }, /* end of table */
    };</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-device-t"></a>10.3. <code class="varname">device_t</code> Pointer</h2></div></div></div><p><code class="varname">device_t</code> is the pointer type for
	the device structure. Here we consider only the methods
	interesting from the device driver writer's standpoint.  The
	methods to manipulate values in the device structure
	are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">device_t
	  device_get_parent(dev)</code> Get the parent bus of a
	  device.</p></li><li class="listitem"><p><code class="function">driver_t
	  device_get_driver(dev)</code> Get pointer to its driver
	  structure.</p></li><li class="listitem"><p><code class="function">char
	  *device_get_name(dev)</code> Get the driver name, such
	  as <code class="literal">"xxx"</code> for our example.</p></li><li class="listitem"><p><code class="function">int device_get_unit(dev)</code>
	  Get the unit number (units are numbered from 0 for the
	  devices associated with each driver).</p></li><li class="listitem"><p><code class="function">char
	  *device_get_nameunit(dev)</code> Get the device name
	  including the unit number, such as <span class="quote">&#8220;<span class="quote">xxx0</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">xxx1</span>&#8221;</span> and so
	  on.</p></li><li class="listitem"><p><code class="function">char
	  *device_get_desc(dev)</code> Get the device
	  description. Normally it describes the exact model of device
	  in human-readable form.</p></li><li class="listitem"><p><code class="function">device_set_desc(dev,
	  desc)</code> Set the description. This makes the device
	  description point to the string desc which may not be
	  deallocated or changed after that.</p></li><li class="listitem"><p><code class="function">device_set_desc_copy(dev,
	  desc)</code> Set the description. The description is
	  copied into an internal dynamically allocated buffer, so the
	  string desc may be changed afterwards without adverse
	  effects.</p></li><li class="listitem"><p><code class="function">void
	  *device_get_softc(dev)</code> Get pointer to the device
	  descriptor (struct <code class="varname">xxx_softc</code>)
	  associated with this device.</p></li><li class="listitem"><p><code class="function">u_int32_t
	  device_get_flags(dev)</code> Get the flags specified for
	  the device in the configuration file.</p></li></ul></div><p>A convenience function <code class="function">device_printf(dev, fmt,
	...)</code> may be used to print the messages from the
	device driver. It automatically prepends the unitname and
	colon to the message.</p><p>The device_t methods are implemented in the file
        <code class="filename">kern/bus_subr.c</code>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-config"></a>10.4. Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</h2></div></div></div><a id="idp54024568" class="indexterm"></a><p>The ISA devices are described in the kernel configuration file
  	like:</p><pre class="programlisting">device xxx0 at isa? port 0x300 irq 10 drq 5
       iomem 0xd0000 flags 0x1 sensitive</pre><a id="idp54296440" class="indexterm"></a><p>The values of port, IRQ and so on are converted to the
	resource values associated with the device. They are optional,
	depending on the device's needs and abilities for
	auto-configuration. For example, some devices do not need DRQ
	at all and some allow the driver to read the IRQ setting from
	the device configuration ports. If a machine has multiple ISA
	buses the exact bus may be specified in the configuration
	line, like <code class="literal">isa0</code> or <code class="literal">isa1</code>, otherwise the device would be
	searched for on all the ISA buses.</p><p><code class="literal">sensitive</code> is a resource requesting that this device must
	be probed before all non-sensitive devices. It is supported
	but does not seem to be used in any current driver.</p><p>For legacy ISA devices in many cases the drivers are still
	able to detect the configuration parameters. But each device
	to be configured in the system must have a config line. If two
	devices of some type are installed in the system but there is
	only one configuration line for the corresponding driver, ie:
	</p><pre class="programlisting">device xxx0 at isa?</pre><p> then only
	one device will be configured.</p><p>But for the devices supporting automatic identification by
	the means of Plug-n-Play or some proprietary protocol one
	configuration line is enough to configure all the devices in
	the system, like the one above or just simply:</p><pre class="programlisting">device xxx at isa?</pre><p>If a driver supports both auto-identified and legacy
	devices and both kinds are installed at once in one machine
	then it is enough to describe in the config file the legacy
	devices only. The auto-identified devices will be added
	automatically.</p><p>When an ISA bus is auto-configured the events happen as
  	follows:</p><p>All the drivers' identify routines (including the PnP
	identify routine which identifies all the PnP devices) are
	called in random order.  As they identify the devices they add
	them to the list on the ISA bus.  Normally the drivers'
	identify routines associate their drivers with the new
	devices. The PnP identify routine does not know about the
	other drivers yet so it does not associate any with the new
	devices it adds.</p><p>The PnP devices are put to sleep using the PnP protocol to
        prevent them from being probed as legacy devices.</p><p>The probe routines of non-PnP devices marked as
        <code class="literal">sensitive</code> are called.  If probe for a device went
        successfully, the attach routine is called for it.</p><p>The probe and attach routines of all non-PNP devices are
  	called likewise.</p><p>The PnP devices are brought back from the sleep state and
        assigned the resources they request: I/O and memory address
        ranges, IRQs and DRQs, all of them not conflicting with the
        attached legacy devices.</p><p>Then for each PnP device the probe routines of all the
        present ISA drivers are called. The first one that claims the
        device gets attached.  It is possible that multiple drivers
        would claim the device with different priority; in this case, the
        highest-priority driver wins.  The probe routines must call
        <code class="function">ISA_PNP_PROBE()</code> to compare the actual PnP
        ID with the list of the IDs supported by the driver and if the
        ID is not in the table return failure. That means that
        absolutely every driver, even the ones not supporting any PnP
        devices must call <code class="function">ISA_PNP_PROBE()</code>, at
        least with an empty PnP ID table to return failure on unknown
        PnP devices.</p><p>The probe routine returns a positive value (the error
        code) on error, zero or negative value on success.</p><p>The negative return values are used when a PnP device
        supports multiple interfaces. For example, an older
        compatibility interface and a newer advanced interface which
        are supported by different drivers. Then both drivers would
        detect the device. The driver which returns a higher value in
        the probe routine takes precedence (in other words, the driver
        returning 0 has highest precedence, returning -1 is next,
        returning -2 is after it and so on). In result the devices
        which support only the old interface will be handled by the
        old driver (which should return -1 from the probe routine)
        while the devices supporting the new interface as well will be
        handled by the new driver (which should return 0 from the
        probe routine). If multiple drivers return the same value then
        the one called first wins. So if a driver returns value 0 it
        may be sure that it won the priority arbitration.</p><p>The device-specific identify routines can also assign not
        a driver but a class of drivers to the device. Then all the
        drivers in the class are probed for this device, like the case
        with PnP. This feature is not implemented in any existing
        driver and is not considered further in this document.</p><p>Because the PnP devices are disabled when probing the
        legacy devices they will not be attached twice (once as legacy
        and once as PnP).  But in case of device-dependent identify
        routines it is the responsibility of the driver to make sure
        that the same device will not be attached by the driver twice:
        once as legacy user-configured and once as
        auto-identified.</p><p>Another practical consequence for the auto-identified
        devices (both PnP and device-specific) is that the flags can
        not be passed to them from the kernel configuration file. So
        they must either not use the flags at all or use the flags
        from the device unit 0 for all the auto-identified devices or
        use the sysctl interface instead of flags.</p><p>Other unusual configurations may be accommodated by
        accessing the configuration resources directly with functions
        of families <code class="function">resource_query_*()</code> and
        <code class="function">resource_*_value()</code>. Their implementations
        are located in <code class="filename">kern/subr_bus.c</code>. The old IDE disk driver
        <code class="filename">i386/isa/wd.c</code> contains examples of such use. But the standard
        means of configuration must always be preferred. Leave parsing
        the configuration resources to the bus configuration
        code.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-resources"></a>10.5. Resources</h2></div></div></div><a id="idp54313592" class="indexterm"></a><a id="idp54314104" class="indexterm"></a><p>The information that a user enters into the kernel
        configuration file is processed and passed to the kernel as
        configuration resources. This information is parsed by the bus
        configuration code and transformed into a value of structure
        device_t and the bus resources associated with it. The drivers
        may access the configuration resources directly using
        functions <code class="function">resource_*</code> for more complex cases of
        configuration. However, generally this is neither needed nor recommended,
        so this issue is not discussed further here.</p><p>The bus resources are associated with each device. They
        are identified by type and number within the type. For the ISA
        bus the following types are defined:</p><a id="idp54316024" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>SYS_RES_IRQ</em></span> - interrupt
	    number</p></li><li class="listitem"><p><span class="emphasis"><em>SYS_RES_DRQ</em></span> - ISA DMA channel
	    number</p></li><li class="listitem"><p><span class="emphasis"><em>SYS_RES_MEMORY</em></span> - range of
	    device memory mapped into the system memory space
	  </p></li><li class="listitem"><p><span class="emphasis"><em>SYS_RES_IOPORT</em></span> - range of
	    device I/O registers</p></li></ul></div><p>The enumeration within types starts from 0, so if a device
        has two memory regions it would have resources of type
        <code class="literal">SYS_RES_MEMORY</code> numbered 0 and 1.  The resource type has
        nothing to do with the C language type, all the resource
        values have the C language type <code class="literal">unsigned long</code> and must be
        cast as necessary. The resource numbers do not have to be
        contiguous, although for ISA they normally would be. The
        permitted resource numbers for ISA devices are:</p><pre class="programlisting">          IRQ: 0-1
          DRQ: 0-1
          MEMORY: 0-3
          IOPORT: 0-7</pre><p>All the resources are represented as ranges, with a start
        value and count.  For IRQ and DRQ resources the count would
        normally be equal to 1. The values for memory refer to the
        physical addresses.</p><p>Three types of activities can be performed on
        resources:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>set/get</p></li><li class="listitem"><p>allocate/release</p></li><li class="listitem"><p>activate/deactivate</p></li></ul></div><p>Setting sets the range used by the resource. Allocation
        reserves the requested range that no other driver would be
        able to reserve it (and checking that no other driver reserved
        this range already). Activation makes the resource accessible
        to the driver by doing whatever is necessary for that (for
        example, for memory it would be mapping into the kernel
        virtual address space).</p><p>The functions to manipulate resources are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">int bus_set_resource(device_t dev, int type,
            int rid, u_long start, u_long count)</code></p><p>Set a range for a resource. Returns 0 if successful,
            error code otherwise.  Normally, this function will
            return an error only if one of <code class="literal">type</code>,
            <code class="literal">rid</code>, <code class="literal">start</code> or
            <code class="literal">count</code> has a value that falls out of the
            permitted range.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p> dev - driver's device</p></li><li class="listitem"><p> type - type of resource, SYS_RES_* </p></li><li class="listitem"><p> rid - resource number (ID) within type </p></li><li class="listitem"><p> start, count - resource range </p></li></ul></div></li><li class="listitem"><p><code class="function">int bus_get_resource(device_t dev, int type,
          int rid, u_long *startp, u_long *countp)</code></p><p>Get the range of resource. Returns 0 if successful,
            error code if the resource is not defined yet.</p></li><li class="listitem"><p><code class="function">u_long bus_get_resource_start(device_t dev,
            int type, int rid) u_long bus_get_resource_count (device_t
            dev, int type, int rid)</code></p><p>Convenience functions to get only the start or
            count. Return 0 in case of error, so if the resource start
            has 0 among the legitimate values it would be impossible
            to tell if the value is 0 or an error occurred.  Luckily,
            no ISA resources for add-on drivers may have a start value
            equal to 0.</p></li><li class="listitem"><p><code class="function">void bus_delete_resource(device_t dev, int
            type, int rid)</code></p><p> Delete a resource, make it undefined.</p></li><li class="listitem"><p><code class="function">struct resource *
            bus_alloc_resource(device_t dev, int type, int *rid,
            u_long start, u_long end, u_long count, u_int
            flags)</code></p><p>Allocate a resource as a range of count values not
            allocated by anyone else, somewhere between start and
            end. Alas, alignment is not supported.  If the resource
            was not set yet it is automatically created. The special
            values of start 0 and end ~0 (all ones) means that the
            fixed values previously set by
            <code class="function">bus_set_resource()</code> must be used
            instead: start and count as themselves and
            end=(start+count), in this case if the resource was not
            defined before then an error is returned.  Although rid is
            passed by reference it is not set anywhere by the resource
            allocation code of the ISA bus. (The other buses may use a
            different approach and modify it).</p></li></ul></div><p>Flags are a bitmap, the flags interesting for the caller
        are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>RF_ACTIVE</em></span> - causes the resource
            to be automatically activated after allocation.</p></li><li class="listitem"><p><span class="emphasis"><em>RF_SHAREABLE</em></span> - resource may be
            shared at the same time by multiple drivers.</p></li><li class="listitem"><p><span class="emphasis"><em>RF_TIMESHARE</em></span> - resource may be
            time-shared by multiple drivers, i.e., allocated at the
            same time by many but activated only by one at any given
            moment of time.</p></li><li class="listitem"><p>Returns 0 on error. The allocated values may be
            obtained from the returned handle using methods
            <code class="function">rhand_*()</code>.</p></li><li class="listitem"><p><code class="function">int bus_release_resource(device_t dev, int
            type, int rid, struct resource *r)</code></p></li><li class="listitem"><p>Release the resource, r is the handle returned by
            <code class="function">bus_alloc_resource()</code>.  Returns 0 on
            success, error code otherwise.</p></li><li class="listitem"><p><code class="function">int bus_activate_resource(device_t dev, int
            type, int rid, struct resource *r)</code>
            <code class="function">int bus_deactivate_resource(device_t dev, int
            type, int rid, struct resource *r)</code></p></li><li class="listitem"><p>Activate or deactivate resource. Return 0 on success,
            error code otherwise.  If the resource is time-shared and
            currently activated by another driver then <code class="literal">EBUSY</code> is
            returned.</p></li><li class="listitem"><p><code class="function">int bus_setup_intr(device_t dev, struct
            resource *r, int flags, driver_intr_t *handler, void *arg,
            void **cookiep)</code> <code class="function">int
            bus_teardown_intr(device_t dev, struct resource *r, void
            *cookie)</code></p></li><li class="listitem"><p>Associate or de-associate the interrupt handler with a
            device. Return 0 on success, error code otherwise.</p></li><li class="listitem"><p>r - the activated resource handler describing the
            IRQ</p><p>flags - the interrupt priority level, one of:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="function">INTR_TYPE_TTY</code> - terminals and
                other likewise character-type devices. To mask them
                use <code class="function">spltty()</code>.</p></li><li class="listitem"><p><code class="function">(INTR_TYPE_TTY |
                INTR_TYPE_FAST)</code> - terminal type devices
                with small input buffer, critical to the data loss on
                input (such as the old-fashioned serial ports). To
                mask them use <code class="function">spltty()</code>.</p></li><li class="listitem"><p><code class="function">INTR_TYPE_BIO</code> - block-type
                devices, except those on the CAM controllers. To mask
                them use <code class="function">splbio()</code>.</p></li><li class="listitem"><p><code class="function">INTR_TYPE_CAM</code> - CAM (Common
                Access Method) bus controllers. To mask them use
                <code class="function">splcam()</code>.</p></li><li class="listitem"><p><code class="function">INTR_TYPE_NET</code> - network
                interface controllers. To mask them use
                <code class="function">splimp()</code>.</p></li><li class="listitem"><p><code class="function">INTR_TYPE_MISC</code> -
                miscellaneous devices.  There is no other way to mask
                them than by <code class="function">splhigh()</code> which
                masks all interrupts.</p></li></ul></div></li></ul></div><p>When an interrupt handler executes all the other
        interrupts matching its priority level will be masked. The
        only exception is the MISC level for which no other interrupts
        are masked and which is not masked by any other
        interrupt.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>handler</em></span> - pointer to the handler
            function, the type driver_intr_t is defined as <code class="function">void
            driver_intr_t(void *)</code></p></li><li class="listitem"><p><span class="emphasis"><em>arg</em></span> - the argument passed to the
            handler to identify this particular device. It is cast
            from void* to any real type by the handler. The old
            convention for the ISA interrupt handlers was to use the
            unit number as argument, the new (recommended) convention
            is using a pointer to the device softc structure.</p></li><li class="listitem"><p><span class="emphasis"><em>cookie[p]</em></span> - the value received
            from <code class="function">setup()</code> is used to identify the
            handler when passed to
            <code class="function">teardown()</code></p></li></ul></div><p>A number of methods are defined to operate on the resource
        handlers (struct resource *). Those of interest to the device
        driver writers are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">u_long rman_get_start(r) u_long
            rman_get_end(r)</code> Get the start and end of
            allocated resource range.</p></li><li class="listitem"><p><code class="function">void *rman_get_virtual(r)</code> Get
            the virtual address of activated memory resource.</p></li></ul></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-busmem"></a>10.6. Bus Memory Mapping</h2></div></div></div><p>In many cases data is exchanged between the driver and the
        device through the memory. Two variants are possible:</p><p>(a) memory is located on the device card</p><p>(b) memory is the main memory of the computer</p><p>In case (a) the driver always copies the data back and
        forth between the on-card memory and the main memory as
        necessary. To map the on-card memory into the kernel virtual
        address space the physical address and length of the on-card
        memory must be defined as a <code class="literal">SYS_RES_MEMORY</code> resource. That
        resource can then be allocated and activated, and its virtual
        address obtained using
        <code class="function">rman_get_virtual()</code>.  The older drivers
        used the function <code class="function">pmap_mapdev()</code> for this
        purpose, which should not be used directly any more. Now it is
        one of the internal steps of resource activation.</p><p>Most of the ISA cards will have their memory configured
        for physical location somewhere in range 640KB-1MB. Some of
        the ISA cards require larger memory ranges which should be
        placed somewhere under 16MB (because of the 24-bit address
        limitation on the ISA bus). In that case if the machine has
        more memory than the start address of the device memory (in
        other words, they overlap) a memory hole must be configured at
        the address range used by devices. Many BIOSes allow
        configuration of a memory hole of 1MB starting at 14MB or
        15MB. FreeBSD can handle the memory holes properly if the BIOS
        reports them properly (this feature may be broken on old BIOSes).</p><p>In case (b) just the address of the data is sent to
        the device, and the device uses DMA to actually access the
        data in the main memory. Two limitations are present: First,
        ISA cards can only access memory below 16MB.  Second, the
        contiguous pages in virtual address space may not be
        contiguous in physical address space, so the device may have
        to do scatter/gather operations. The bus subsystem provides
        ready solutions for some of these problems, the rest has to be
        done by the drivers themselves.</p><p>Two structures are used for DMA memory allocation,
        <code class="varname">bus_dma_tag_t</code> and <code class="varname">bus_dmamap_t</code>. Tag describes the properties
        required for the DMA memory. Map represents a memory block
        allocated according to these properties. Multiple maps may be
        associated with the same tag.</p><p>Tags are organized into a tree-like hierarchy with
        inheritance of the properties. A child tag inherits all the
        requirements of its parent tag, and may make them more strict
        but never more loose.</p><p>Normally one top-level tag (with no parent) is created for
        each device unit.  If multiple memory areas with different
        requirements are needed for each device then a tag for each of
        them may be created as a child of the parent tag.</p><p>The tags can be used to create a map in two ways.</p><p>First, a chunk of contiguous memory conformant with the
        tag requirements may be allocated (and later may be
        freed). This is normally used to allocate relatively
        long-living areas of memory for communication with the
        device. Loading of such memory into a map is trivial: it is
        always considered as one chunk in the appropriate physical
        memory range.</p><p>Second, an arbitrary area of virtual memory may be loaded
        into a map. Each page of this memory will be checked for
        conformance to the map requirement.  If it conforms then it is
        left at its original location. If it is not then a fresh
        conformant <span class="quote">&#8220;<span class="quote">bounce page</span>&#8221;</span> is allocated and used as intermediate
        storage. When writing the data from the non-conformant
        original pages they will be copied to their bounce pages first
        and then transferred from the bounce pages to the device. When
        reading the data would go from the device to the bounce pages
        and then copied to their non-conformant original pages. The
        process of copying between the original and bounce pages is
        called synchronization. This is normally used on a per-transfer
        basis: buffer for each transfer would be loaded, transfer done
        and buffer unloaded.</p><p>The functions working on the DMA memory are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">int bus_dma_tag_create(bus_dma_tag_t parent,
          bus_size_t alignment, bus_size_t boundary, bus_addr_t
          lowaddr, bus_addr_t highaddr, bus_dma_filter_t *filter, void
          *filterarg, bus_size_t maxsize, int nsegments, bus_size_t
          maxsegsz, int flags, bus_dma_tag_t *dmat)</code></p><p>Create a new tag. Returns 0 on success, the error code
          otherwise.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>parent</em></span> - parent tag, or NULL to
              create a top-level tag.</p></li><li class="listitem"><p><span class="emphasis"><em>alignment</em></span> -
              required physical alignment of the memory area to be
              allocated for this tag. Use value 1 for <span class="quote">&#8220;<span class="quote">no specific
              alignment</span>&#8221;</span>. Applies only to the future
              <code class="function">bus_dmamem_alloc()</code> but not
              <code class="function">bus_dmamap_create()</code> calls.</p></li><li class="listitem"><p><span class="emphasis"><em>boundary</em></span> - physical address
              boundary that must not be crossed when allocating the
              memory. Use value 0 for <span class="quote">&#8220;<span class="quote">no boundary</span>&#8221;</span>. Applies only to
              the future <code class="function">bus_dmamem_alloc()</code> but
              not <code class="function">bus_dmamap_create()</code> calls.
              Must be power of 2. If the memory is planned to be used
              in non-cascaded DMA mode (i.e., the DMA addresses will be
              supplied not by the device itself but by the ISA DMA
              controller) then the boundary must be no larger than
              64KB (64*1024) due to the limitations of the DMA
              hardware.</p></li><li class="listitem"><p><span class="emphasis"><em>lowaddr, highaddr</em></span> - the names
              are slightly misleading; these values are used to limit
              the permitted range of physical addresses used to
              allocate the memory.  The exact meaning varies depending
              on the planned future use:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>For <code class="function">bus_dmamem_alloc()</code> all
                  the addresses from 0 to lowaddr-1 are considered
                  permitted, the higher ones are forbidden.</p></li><li class="listitem"><p>For <code class="function">bus_dmamap_create()</code> all
                  the addresses outside the inclusive range [lowaddr;
                  highaddr] are considered accessible. The addresses
                  of pages inside the range are passed to the filter
                  function which decides if they are accessible. If no
                  filter function is supplied then all the range is
                  considered unaccessible.</p></li><li class="listitem"><p>For the ISA devices the normal values (with no
                  filter function) are:</p><p>lowaddr = BUS_SPACE_MAXADDR_24BIT</p><p>highaddr = BUS_SPACE_MAXADDR</p></li></ul></div></li><li class="listitem"><p><span class="emphasis"><em>filter, filterarg</em></span> - the filter
              function and its argument. If NULL is passed for filter
              then the whole range [lowaddr, highaddr] is considered
              unaccessible when doing
              <code class="function">bus_dmamap_create()</code>.  Otherwise the
              physical address of each attempted page in range
              [lowaddr; highaddr] is passed to the filter function
              which decides if it is accessible. The prototype of the
              filter function is: <code class="function">int filterfunc(void *arg,
              bus_addr_t paddr)</code>. It must return 0 if the
              page is accessible, non-zero otherwise.</p></li><li class="listitem"><p><span class="emphasis"><em>maxsize</em></span> - the maximal size of
              memory (in bytes) that may be allocated through this
              tag. In case it is difficult to estimate or could be
              arbitrarily big, the value for ISA devices would be
              <code class="literal">BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>nsegments</em></span> - maximal number of
              scatter-gather segments supported by the device. If
              unrestricted then the value <code class="literal">BUS_SPACE_UNRESTRICTED</code>
              should be used. This value is recommended for the parent
              tags, the actual restrictions would then be specified
              for the descendant tags. Tags with nsegments equal to
              <code class="literal">BUS_SPACE_UNRESTRICTED</code> may not be used to actually load
              maps, they may be used only as parent tags. The
              practical limit for nsegments seems to be about 250-300,
              higher values will cause kernel stack overflow (the hardware
	      can not normally support that many
              scatter-gather buffers anyway).</p></li><li class="listitem"><p><span class="emphasis"><em>maxsegsz</em></span> - maximal size of a
              scatter-gather segment supported by the device. The
              maximal value for ISA device would be
              <code class="literal">BUS_SPACE_MAXSIZE_24BIT</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>flags</em></span> - a bitmap of flags. The
              only interesting flags are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p><span class="emphasis"><em>BUS_DMA_ALLOCNOW</em></span> - requests
                  to allocate all the potentially needed bounce pages
                  when creating the tag.</p></li><li class="listitem"><p><span class="emphasis"><em>BUS_DMA_ISA</em></span> - mysterious
                  flag used only on Alpha machines. It is not defined
                  for the i386 machines.  Probably it should be used
                  by all the ISA drivers for Alpha machines but it
                  looks like there are no such drivers yet.</p></li></ul></div></li><li class="listitem"><p><span class="emphasis"><em>dmat</em></span> - pointer to the storage
              for the new tag to be returned.</p></li></ul></div></li><li class="listitem"><p><code class="function">int bus_dma_tag_destroy(bus_dma_tag_t
	  dmat)</code></p><p>Destroy a tag. Returns 0 on success, the error code
	  otherwise.</p><p>dmat - the tag to be destroyed.</p></li><li class="listitem"><p><code class="function">int bus_dmamem_alloc(bus_dma_tag_t dmat,
          void** vaddr, int flags, bus_dmamap_t
          *mapp)</code></p><p>Allocate an area of contiguous memory described by the
          tag. The size of memory to be allocated is tag's maxsize.
          Returns 0 on success, the error code otherwise. The result
          still has to be loaded by
          <code class="function">bus_dmamap_load()</code> before being used to get
          the physical address of the memory.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>dmat</em></span> - the tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>vaddr</em></span> - pointer to the storage
                  for the kernel virtual address of the allocated area
                  to be returned.
                 </p></li><li class="listitem"><p>
                  flags - a bitmap of flags. The only interesting flag is:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <span class="emphasis"><em>BUS_DMA_NOWAIT</em></span> - if the
                      memory is not immediately available return the
                      error. If this flag is not set then the routine
                      is allowed to sleep until the memory
                      becomes available.
                    </p></li></ul></div></li><li class="listitem"><p>
                  <span class="emphasis"><em>mapp</em></span> - pointer to the storage
                  for the new map to be returned.
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">void bus_dmamem_free(bus_dma_tag_t dmat, void
              *vaddr, bus_dmamap_t map)</code>
            </p><p>
              Free the memory allocated by
              <code class="function">bus_dmamem_alloc()</code>. At present,
              freeing of the memory allocated with ISA restrictions is
              not implemented.  Because of this the recommended model
              of use is to keep and re-use the allocated areas for as
              long as possible. Do not lightly free some area and then
              shortly allocate it again. That does not mean that
              <code class="function">bus_dmamem_free()</code> should not be
              used at all: hopefully it will be properly implemented
              soon.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>dmat</em></span> - the tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>vaddr</em></span> - the kernel virtual
                  address of the memory
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>map</em></span> - the map of the memory (as
                  returned from
                  <code class="function">bus_dmamem_alloc()</code>)
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">int bus_dmamap_create(bus_dma_tag_t dmat, int
              flags, bus_dmamap_t *mapp)</code>
            </p><p>
              Create a map for the tag, to be used in
              <code class="function">bus_dmamap_load()</code> later.  Returns 0
              on success, the error code otherwise.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>dmat</em></span> - the tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>flags</em></span> - theoretically, a bit map
                  of flags. But no flags are defined yet, so at present
                  it will be always 0.
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>mapp</em></span> - pointer to the storage
                  for the new map to be returned
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">int bus_dmamap_destroy(bus_dma_tag_t dmat,
              bus_dmamap_t map)</code>
            </p><p>
              Destroy a map. Returns 0 on success, the error code otherwise.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  dmat - the tag to which the map is associated
                </p></li><li class="listitem"><p>
                  map - the map to be destroyed
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">int bus_dmamap_load(bus_dma_tag_t dmat,
              bus_dmamap_t map, void *buf, bus_size_t buflen,
              bus_dmamap_callback_t *callback, void *callback_arg, int
              flags)</code>
            </p><p>
              Load a buffer into the map (the map must be previously
              created by <code class="function">bus_dmamap_create()</code> or
              <code class="function">bus_dmamem_alloc()</code>).  All the pages
              of the buffer are checked for conformance to the tag
              requirements and for those not conformant the bounce
              pages are allocated. An array of physical segment
              descriptors is built and passed to the callback
              routine. This callback routine is then expected to
              handle it in some way. The number of bounce buffers in
              the system is limited, so if the bounce buffers are
              needed but not immediately available the request will be
              queued and the callback will be called when the bounce
              buffers will become available. Returns 0 if the callback
              was executed immediately or <span class="errorname">EINPROGRESS</span> if the request
              was queued for future execution. In the latter case the
              synchronization with queued callback routine is the
              responsibility of the driver.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>dmat</em></span> - the tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>map</em></span> - the map
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>buf</em></span> - kernel virtual address of
                  the buffer
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>buflen</em></span> - length of the buffer
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>callback</em></span>,<code class="function">
                  callback_arg</code> - the callback function and
                  its argument
                </p></li></ul></div><p>
              The prototype of callback function is:
            </p><p>
              <code class="function">void callback(void *arg, bus_dma_segment_t
              *seg, int nseg, int error)</code>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>arg</em></span> - the same as callback_arg
                  passed to <code class="function">bus_dmamap_load()</code>
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>seg</em></span> - array of the segment
                  descriptors
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>nseg</em></span> - number of descriptors in
                  array
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>error</em></span> - indication of the
                  segment number overflow: if it is set to <span class="errorname">EFBIG</span> then
                  the buffer did not fit into the maximal number of
                  segments permitted by the tag. In this case only the
                  permitted number of descriptors will be in the
                  array. Handling of this situation is up to the
                  driver: depending on the desired semantics it can
                  either consider this an error or split the buffer in
                  two and handle the second part separately
                </p></li></ul></div><p>
              Each entry in the segments array contains the fields:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>ds_addr</em></span> - physical bus address
                  of the segment
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>ds_len</em></span> - length of the segment
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">void bus_dmamap_unload(bus_dma_tag_t dmat,
              bus_dmamap_t map)</code>
            </p><p>unload the map.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>dmat</em></span> - tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>map</em></span> - loaded map
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="function">void bus_dmamap_sync (bus_dma_tag_t dmat,
              bus_dmamap_t map, bus_dmasync_op_t op)</code>
            </p><p>
              Synchronise a loaded buffer with its bounce pages before
              and after physical transfer to or from device. This is
              the function that does all the necessary copying of data
              between the original buffer and its mapped version. The
              buffers must be synchronized both before and after doing
              the transfer.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <span class="emphasis"><em>dmat</em></span> - tag
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>map</em></span> - loaded map
                </p></li><li class="listitem"><p>
                  <span class="emphasis"><em>op</em></span> - type of synchronization
                  operation to perform:
                </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="function">BUS_DMASYNC_PREREAD</code> - before
                  reading from device into buffer
                </p></li><li class="listitem"><p>
                  <code class="function">BUS_DMASYNC_POSTREAD</code> - after
                  reading from device into buffer
                </p></li><li class="listitem"><p>
                  <code class="function">BUS_DMASYNC_PREWRITE</code> - before
                  writing the buffer to device
                </p></li><li class="listitem"><p>
                  <code class="function">BUS_DMASYNC_POSTWRITE</code> - after
                  writing the buffer to device
                </p></li></ul></div></li></ul></div><p>
          As of now PREREAD and POSTWRITE are null operations but that
          may change in the future, so they must not be ignored in the
          driver. Synchronization is not needed for the memory
          obtained from <code class="function">bus_dmamem_alloc()</code>.
        </p><p>
          Before calling the callback function from
          <code class="function">bus_dmamap_load()</code> the segment array is
          stored in the stack. And it gets pre-allocated for the
          maximal number of segments allowed by the tag. Because of
          this the practical limit for the number of segments on i386
          architecture is about 250-300 (the kernel stack is 4KB minus
          the size of the user structure, size of a segment array
          entry is 8 bytes, and some space must be left). Because the
          array is allocated based on the maximal number this value
          must not be set higher than really needed. Fortunately, for
          most of hardware the maximal supported number of segments is
          much lower. But if the driver wants to handle buffers with a
          very large number of scatter-gather segments it should do
          that in portions: load part of the buffer, transfer it to
          the device, load next part of the buffer, and so on.
        </p><p>
          Another practical consequence is that the number of segments
          may limit the size of the buffer. If all the pages in the
          buffer happen to be physically non-contiguous then the
          maximal supported buffer size for that fragmented case would
          be (nsegments * page_size). For example, if a maximal number
          of 10 segments is supported then on i386 maximal guaranteed
          supported buffer size would be 40K. If a higher size is
          desired then special tricks should be used in the driver.
        </p><p>
          If the hardware does not support scatter-gather at all or
          the driver wants to support some buffer size even if it is
          heavily fragmented then the solution is to allocate a
          contiguous buffer in the driver and use it as intermediate
          storage if the original buffer does not fit.
        </p><p>
          Below are the typical call sequences when using a map depend
          on the use of the map.  The characters -&gt; are used to show
          the flow of time.
        </p><p>
          For a buffer which stays practically fixed during all the
          time between attachment and detachment of a device:</p><p>
          bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt;
          -&gt; bus_dmamap_unload -&gt; bus_dmamem_free
        </p><p>For a buffer that changes frequently and is passed from
        outside the driver:

	
        </p><pre class="programlisting">          bus_dmamap_create -&gt;
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          ...
          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;
          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;
          -&gt; bus_dmamap_destroy        </pre><p>

        </p><p>
          When loading a map created by
          <code class="function">bus_dmamem_alloc()</code> the passed address
          and size of the buffer must be the same as used in
          <code class="function">bus_dmamem_alloc()</code>. In this case it is
          guaranteed that the whole buffer will be mapped as one
          segment (so the callback may be based on this assumption)
          and the request will be executed immediately (EINPROGRESS
          will never be returned).  All the callback needs to do in
          this case is to save the physical address.
        </p><p>
          A typical example would be:
        </p><pre class="programlisting">          static void
        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)
        {
          *(bus_addr_t *)arg = seg[0].ds_addr;
        }

          ...
          int error;
          struct somedata {
            ....
          };
          struct somedata *vsomedata; /* virtual address */
          bus_addr_t psomedata; /* physical bus-relative address */
          bus_dma_tag_t tag_somedata;
          bus_dmamap_t map_somedata;
          ...

          error=bus_dma_tag_create(parent_tag, alignment,
           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,
           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,
           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,
           &amp;tag_somedata);
          if(error)
          return error;

          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,
             &amp;map_somedata);
          if(error)
             return error;

          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,
             sizeof (struct somedata), alloc_callback,
             (void *) &amp;psomedata, /*flags*/0);        </pre><p>
          Looks a bit long and complicated but that is the way to do
          it. The practical consequence is: if multiple memory areas
          are allocated always together it would be a really good idea
          to combine them all into one structure and allocate as one
          (if the alignment and boundary limitations permit).
        </p><p>
          When loading an arbitrary buffer into the map created by
          <code class="function">bus_dmamap_create()</code> special measures
          must be taken to synchronize with the callback in case it
          would be delayed. The code would look like:
        </p><pre class="programlisting">          {
           int s;
           int error;

           s = splsoftvm();
           error = bus_dmamap_load(
               dmat,
               dmamap,
               buffer_ptr,
               buffer_len,
               callback,
               /*callback_arg*/ buffer_descriptor,
               /*flags*/0);
           if (error == EINPROGRESS) {
               /*
                * Do whatever is needed to ensure synchronization
                * with callback. Callback is guaranteed not to be started
                * until we do splx() or tsleep().
                */
              }
           splx(s);
          }        </pre><p>
          Two possible approaches for the processing of requests are:
        </p><p>
          1. If requests are completed by marking them explicitly as
          done (such as the CAM requests) then it would be simpler to
          put all the further processing into the callback driver
          which would mark the request when it is done. Then not much
          extra synchronization is needed. For the flow control
          reasons it may be a good idea to freeze the request queue
          until this request gets completed.
        </p><p>
          2. If requests are completed when the function returns (such
          as classic read or write requests on character devices) then
          a synchronization flag should be set in the buffer
          descriptor and <code class="function">tsleep()</code> called.  Later
          when the callback gets called it will do its processing and
          check this synchronization flag. If it is set then the
          callback should issue a wakeup. In this approach the
          callback function could either do all the needed processing
          (just like the previous case) or simply save the segments
          array in the buffer descriptor. Then after callback
          completes the calling function could use this saved segments
          array and do all the processing.

        </p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-dma"></a>10.7. DMA</h2></div></div></div><a id="idp54606456" class="indexterm"></a><p>
          The Direct Memory Access (DMA) is implemented in the ISA bus
          through the DMA controller (actually, two of them but that is
          an irrelevant detail).  To make the early ISA devices simple
          and cheap the logic of the bus control and address
          generation was concentrated in the DMA controller.
          Fortunately, FreeBSD provides a set of functions that mostly
          hide the annoying details of the DMA controller from the
          device drivers.
        </p><p>
          The simplest case is for the fairly intelligent
          devices. Like the bus master devices on PCI they can
          generate the bus cycles and memory addresses all by
          themselves. The only thing they really need from the DMA
          controller is bus arbitration. So for this purpose they
          pretend to be cascaded slave DMA controllers. And the only
          thing needed from the system DMA controller is to enable the
          cascaded mode on a DMA channel by calling the following
          function when attaching the driver:
        </p><p>
          <code class="function">void isa_dmacascade(int channel_number)</code>
        </p><p>
          All the further activity is done by programming the
          device. When detaching the driver no DMA-related functions
          need to be called.
        </p><p>
          For the simpler devices things get more complicated. The
          functions used are:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="function">int isa_dma_acquire(int chanel_number)</code>
          </p><p>
                Reserve a DMA channel. Returns 0 on success or EBUSY
                if the channel was already reserved by this or a
                different driver. Most of the ISA devices are not able
                to share DMA channels anyway, so normally this
                function is called when attaching a device. This
                reservation was made redundant by the modern interface
                of bus resources but still must be used in addition to
                the latter. If not used then later, other DMA routines
                will panic.
          </p></li><li class="listitem"><p>
            <code class="function">int isa_dma_release(int chanel_number)</code>
          </p><p>
                Release a previously reserved DMA channel. No
                transfers must be in progress when the channel is
                released (in addition the device must not try to
                initiate transfer after the channel is released).
          </p></li><li class="listitem"><p>
            <code class="function">void isa_dmainit(int chan, u_int
            bouncebufsize)</code>
          </p><p>
                Allocate a bounce buffer for use with the specified
                channel. The requested size of the buffer can not exceed
                64KB. This bounce buffer will be automatically used
                later if a transfer buffer happens to be not
                physically contiguous or outside of the memory
                accessible by the ISA bus or crossing the 64KB
                boundary. If the transfers will be always done from
                buffers which conform to these conditions (such as
                those allocated by
                <code class="function">bus_dmamem_alloc()</code> with proper
                limitations) then <code class="function">isa_dmainit()</code>
                does not have to be called. But it is quite convenient
                to transfer arbitrary data using the DMA controller.
                The bounce buffer will automatically care of the
                scatter-gather issues.
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    <span class="emphasis"><em>chan</em></span> - channel number
                  </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>bouncebufsize</em></span> - size of the
                    bounce buffer in bytes
                  </p></li></ul></div></li><li class="listitem"><p>
            <code class="function">void isa_dmastart(int flags, caddr_t addr, u_int
            nbytes, int chan)</code>
          </p><p>
                Prepare to start a DMA transfer. This function must be
                called to set up the DMA controller before actually
                starting transfer on the device. It checks that the
                buffer is contiguous and falls into the ISA memory
                range, if not then the bounce buffer is automatically
                used. If bounce buffer is required but not set up by
                <code class="function">isa_dmainit()</code> or too small for
                the requested transfer size then the system will
                panic. In case of a write request with bounce buffer
                the data will be automatically copied to the bounce
                buffer.
          </p></li><li class="listitem"><p>flags - a bitmask determining the type of operation to
          be done. The direction bits B_READ and B_WRITE are mutually
          exclusive.
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                B_READ - read from the ISA bus into memory
              </p></li><li class="listitem"><p>
                B_WRITE - write from the memory to the ISA bus
              </p></li><li class="listitem"><p>
                B_RAW - if set then the DMA controller will remember
                the buffer and after the end of transfer will
                automatically re-initialize itself to repeat transfer
                of the same buffer again (of course, the driver may
                change the data in the buffer before initiating
                another transfer in the device). If not set then the
                parameters will work only for one transfer, and
                <code class="function">isa_dmastart()</code> will have to be
                called again before initiating the next
                transfer. Using B_RAW makes sense only if the bounce
                buffer is not used.
              </p></li></ul></div></li><li class="listitem"><p>
            addr - virtual address of the buffer
          </p></li><li class="listitem"><p>
            nbytes - length of the buffer. Must be less or equal to
            64KB. Length of 0 is not allowed: the DMA controller will
            understand it as 64KB while the kernel code will
            understand it as 0 and that would cause unpredictable
            effects. For channels number 4 and higher the length must
            be even because these channels transfer 2 bytes at a
            time. In case of an odd length the last byte will not be
            transferred.
          </p></li><li class="listitem"><p>
            chan - channel number
          </p></li><li class="listitem"><p>
            <code class="function">void isa_dmadone(int flags, caddr_t addr, int
            nbytes, int chan)</code>
          </p><p>
            Synchronize the memory after device reports that transfer
            is done. If that was a read operation with a bounce buffer
            then the data will be copied from the bounce buffer to the
            original buffer. Arguments are the same as for
            <code class="function">isa_dmastart()</code>. Flag B_RAW is
            permitted but it does not affect
            <code class="function">isa_dmadone()</code> in any way.
          </p></li><li class="listitem"><p>
            <code class="function">int isa_dmastatus(int channel_number)</code>
          </p><p>
            Returns the number of bytes left in the current transfer
            to be transferred.  In case the flag B_READ was set in
            <code class="function">isa_dmastart()</code> the number returned
            will never be equal to zero. At the end of transfer it
            will be automatically reset back to the length of
            buffer. The normal use is to check the number of bytes
            left after the device signals that the transfer is
            completed.  If the number of bytes is not 0 then something
            probably went wrong with that transfer.
          </p></li><li class="listitem"><p>
            <code class="function">int isa_dmastop(int channel_number)</code>
          </p><p>
            Aborts the current transfer and returns the number of
            bytes left untransferred.
          </p></li></ul></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-probe"></a>10.8. xxx_isa_probe</h2></div></div></div><p>
          This function probes if a device is present. If the driver
          supports auto-detection of some part of device configuration
          (such as interrupt vector or memory address) this
          auto-detection must be done in this routine.
        </p><p>
          As for any other bus, if the device cannot be detected or
          is detected but failed the self-test or some other problem
          happened then it returns a positive value of error. The
          value <span class="errorname">ENXIO</span> must be returned if the device is not
          present. Other error values may mean other conditions. Zero
          or negative values mean success. Most of the drivers return
          zero as success.
        </p><p>
          The negative return values are used when a PnP device
          supports multiple interfaces. For example, an older
          compatibility interface and a newer advanced interface which
          are supported by different drivers. Then both drivers would
          detect the device. The driver which returns a higher value
          in the probe routine takes precedence (in other words, the
          driver returning 0 has highest precedence, one returning -1
          is next, one returning -2 is after it and so on). In result
          the devices which support only the old interface will be
          handled by the old driver (which should return -1 from the
          probe routine) while the devices supporting the new
          interface as well will be handled by the new driver (which
          should return 0 from the probe routine).
        </p><p>
          The device descriptor struct xxx_softc is allocated by the
          system before calling the probe routine. If the probe
          routine returns an error the descriptor will be
          automatically deallocated by the system. So if a probing
          error occurs the driver must make sure that all the
          resources it used during probe are deallocated and that
          nothing keeps the descriptor from being safely
          deallocated. If the probe completes successfully the
          descriptor will be preserved by the system and later passed
          to the routine <code class="function">xxx_isa_attach()</code>. If a
          driver returns a negative value it can not be sure that it
          will have the highest priority and its attach routine will
          be called. So in this case it also must release all the
          resources before returning and if necessary allocate them
          again in the attach routine. When
          <code class="function">xxx_isa_probe()</code> returns 0 releasing the
          resources before returning is also a good idea and a
          well-behaved driver should do so. But in cases where there is
          some problem with releasing the resources the driver is
          allowed to keep resources between returning 0 from the probe
          routine and execution of the attach routine.
        </p><p>
          A typical probe routine starts with getting the device
          descriptor and unit:
        </p><pre class="programlisting">         struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int pnperror;
          int error = 0;

          sc-&gt;dev = dev; /* link it back */
          sc-&gt;unit = unit;        </pre><p>
          Then check for the PnP devices. The check is carried out by
          a table containing the list of PnP IDs supported by this
          driver and human-readable descriptions of the device models
          corresponding to these IDs.
        </p><pre class="programlisting">
        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,
        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;
        </pre><p>
          The logic of ISA_PNP_PROBE is the following: If this card
          (device unit) was not detected as PnP then ENOENT will be
          returned. If it was detected as PnP but its detected ID does
          not match any of the IDs in the table then ENXIO is
          returned. Finally, if it has PnP support and it matches on
          of the IDs in the table, 0 is returned and the appropriate
          description from the table is set by
          <code class="function">device_set_desc()</code>.
        </p><p>
          If a driver supports only PnP devices then the condition
          would look like:
        </p><pre class="programlisting">          if(pnperror != 0)
              return pnperror;        </pre><p>
          No special treatment is required for the drivers which do not
          support PnP because they pass an empty PnP ID table and will
          always get ENXIO if called on a PnP card.
        </p><p>
          The probe routine normally needs at least some minimal set
          of resources, such as I/O port number to find the card and
          probe it. Depending on the hardware the driver may be able
          to discover the other necessary resources automatically. The
          PnP devices have all the resources pre-set by the PnP
          subsystem, so the driver does not need to discover them by
          itself.
        </p><p>
          Typically the minimal information required to get access to
          the device is the I/O port number. Then some devices allow
          to get the rest of information from the device configuration
          registers (though not all devices do that).  So first we try
          to get the port start value:
        </p><pre class="programlisting"> sc-&gt;port0 = bus_get_resource_start(dev,
        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;
        </pre><p>
          The base port address is saved in the structure softc for
          future use.  If it will be used very often then calling the
          resource function each time would be prohibitively slow. If
          we do not get a port we just return an error.  Some device
          drivers can instead be clever and try to probe all the
          possible ports, like this:
        </p><pre class="programlisting">
          /* table of all possible base I/O port addresses for this device */
          static struct xxx_allports {
              u_short port; /* port address */
              short used; /* flag: if this port is already used by some unit */
          } xxx_allports = {
              { 0x300, 0 },
              { 0x320, 0 },
              { 0x340, 0 },
              { 0, 0 } /* end of table */
          };

          ...
          int port, i;
          ...

          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);
          if(port !=0 ) {
              for(i=0; xxx_allports[i].port!=0; i++) {
                  if(xxx_allports[i].used || xxx_allports[i].port != port)
                      continue;

                  /* found it */
                  xxx_allports[i].used = 1;
                  /* do probe on a known port */
                  return xxx_really_probe(dev, port);
              }
              return ENXIO; /* port is unknown or already used */
          }

          /* we get here only if we need to guess the port */
          for(i=0; xxx_allports[i].port!=0; i++) {
              if(xxx_allports[i].used)
                  continue;

              /* mark as used - even if we find nothing at this port
               * at least we won't probe it in future
               */
               xxx_allports[i].used = 1;

              error = xxx_really_probe(dev, xxx_allports[i].port);
              if(error == 0) /* found a device at that port */
                  return 0;
          }
          /* probed all possible addresses, none worked */
          return ENXIO;</pre><p>
          Of course, normally the driver's
          <code class="function">identify()</code> routine should be used for
          such things. But there may be one valid reason why it may be
          better to be done in <code class="function">probe()</code>: if this
          probe would drive some other sensitive device crazy.  The
          probe routines are ordered with consideration of the
          <code class="literal">sensitive</code> flag: the sensitive devices get probed first and
          the rest of the devices later.  But the
          <code class="function">identify()</code> routines are called before
          any probes, so they show no respect to the sensitive devices
          and may upset them.
        </p><p>
          Now, after we got the starting port we need to set the port
          count (except for PnP devices) because the kernel does not
          have this information in the configuration file.
        </p><pre class="programlisting">
         if(pnperror /* only for non-PnP devices */
         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,
         XXX_PORT_COUNT)&lt;0)
             return ENXIO;</pre><p>
          Finally allocate and activate a piece of port address space
          (special values of start and end mean <span class="quote">&#8220;<span class="quote">use those we set by
          <code class="function">bus_set_resource()</code></span>&#8221;</span>):
        </p><pre class="programlisting">
          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,
          &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
              return ENXIO;</pre><p>
          Now having access to the port-mapped registers we can poke
          the device in some way and check if it reacts like it is
          expected to. If it does not then there is probably some
          other device or no device at all at this address.
        </p><p>
          Normally drivers do not set up the interrupt handlers until
          the attach routine. Instead they do probes in the polling
          mode using the <code class="function">DELAY()</code> function for
          timeout. The probe routine must never hang forever, all the
          waits for the device must be done with timeouts. If the
          device does not respond within the time it is probably broken
          or misconfigured and the driver must return error. When
          determining the timeout interval give the device some extra
          time to be on the safe side: although
          <code class="function">DELAY()</code> is supposed to delay for the
          same amount of time on any machine it has some margin of
          error, depending on the exact CPU.
        </p><p>
          If the probe routine really wants to check that the
          interrupts really work it may configure and probe the
          interrupts too. But that is not recommended.
        </p><pre class="programlisting">
          /* implemented in some very device-specific way */
          if(error = xxx_probe_ports(sc))
              goto bad; /* will deallocate the resources before returning */
        </pre><p>
          The function <code class="function">xxx_probe_ports()</code> may also
          set the device description depending on the exact model of
          device it discovers.  But if there is only one supported
          device model this can be as well done in a hardcoded way.
          Of course, for the PnP devices the PnP support sets the
          description from the table automatically.
        </p><pre class="programlisting">          if(pnperror)
              device_set_desc(dev, "Our device model 1234");
        </pre><p>
          Then the probe routine should either discover the ranges of
          all the resources by reading the device configuration
          registers or make sure that they were set explicitly by the
          user. We will consider it with an example of on-board
          memory. The probe routine should be as non-intrusive as
          possible, so allocation and check of functionality of the
          rest of resources (besides the ports) would be better left
          to the attach routine.
        </p><p>
          The memory address may be specified in the kernel
          configuration file or on some devices it may be
          pre-configured in non-volatile configuration registers.  If
          both sources are available and different, which one should
          be used?  Probably if the user bothered to set the address
          explicitly in the kernel configuration file they know what
          they are doing and this one should take precedence. An
          example of implementation could be:
        </p><pre class="programlisting">
          /* try to find out the config address first */
          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);
          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */
              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);


          if(sc-&gt;mem0_p == 0)
                  /* can't get it from device config registers either */
                  goto bad;
          } else {
              if(xxx_set_mem0_address_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that address */
          }

          /* just like the port, set the memory size,
           * for some devices the memory size would not be constant
           * but should be read from the device configuration registers instead
           * to accommodate different models of devices. Another option would
           * be to let the user set the memory size as "msize" configuration
           * resource which will be automatically handled by the ISA bus.
           */
           if(pnperror) { /* only for non-PnP devices */
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
              if(sc-&gt;mem0_size == 0) /* not specified by user */
                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);

              if(sc-&gt;mem0_size == 0) {
                  /* suppose this is a very old model of device without
                   * auto-configuration features and the user gave no preference,
                   * so assume the minimalistic case
                   * (of course, the real value will vary with the driver)
                   */
                  sc-&gt;mem0_size = 8*1024;
              }

              if(xxx_set_mem0_size_on_device(sc) &lt; 0)
                  goto bad; /* device does not support that size */

              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,
                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)
                  goto bad;
          } else {
              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);
          }        </pre><p>
          Resources for IRQ and DRQ are easy to check by analogy.
        </p><p>
          If all went well then release all the resources and return success.
        </p><pre class="programlisting">          xxx_free_resources(sc);
          return 0;</pre><p>
          Finally, handle the troublesome situations. All the
          resources should be deallocated before returning. We make
          use of the fact that before the structure softc is passed to
          us it gets zeroed out, so we can find out if some resource
          was allocated: then its descriptor is non-zero.
        </p><pre class="programlisting">          bad:

          xxx_free_resources(sc);
          if(error)
                return error;
          else /* exact error is unknown */
              return ENXIO;</pre><p>
          That would be all for the probe routine. Freeing of
          resources is done from multiple places, so it is moved to a
          function which may look like:
        </p><pre class="programlisting">static void
           xxx_free_resources(sc)
              struct xxx_softc *sc;
          {
              /* check every resource and free if not zero */

              /* interrupt handler */
              if(sc-&gt;intr_r) {
                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);
                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,
                      sc-&gt;intr_r);
                  sc-&gt;intr_r = 0;
              }

              /* all kinds of memory maps we could have allocated */
              if(sc-&gt;data_p) {
                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);
                  sc-&gt;data_p = 0;
              }
               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */
                  /* the map will also be freed */
                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);
                  sc-&gt;data = 0;
              }
              if(sc-&gt;data_tag) {
                  bus_dma_tag_destroy(sc-&gt;data_tag);
                  sc-&gt;data_tag = 0;
              }

              ... free other maps and tags if we have them ...

              if(sc-&gt;parent_tag) {
                  bus_dma_tag_destroy(sc-&gt;parent_tag);
                  sc-&gt;parent_tag = 0;
              }

              /* release all the bus resources */
              if(sc-&gt;mem0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,
                      sc-&gt;mem0_r);
                  sc-&gt;mem0_r = 0;
              }
              ...
              if(sc-&gt;port0_r) {
                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,
                      sc-&gt;port0_r);
                  sc-&gt;port0_r = 0;
              }
          }</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-attach"></a>10.9. xxx_isa_attach</h2></div></div></div><p>The attach routine actually connects the driver to the
        system if the probe routine returned success and the system
        had chosen to attach that driver.  If the probe routine
        returned 0 then the attach routine may expect to receive the
        device structure softc intact, as it was set by the probe
        routine. Also if the probe routine returns 0 it may expect
        that the attach routine for this device shall be called at
        some point in the future. If the probe routine returns a
        negative value then the driver may make none of these
        assumptions.
        </p><p>The attach routine returns 0 if it completed successfully or
          error code otherwise.
        </p><p>The attach routine starts just like the probe routine,
          with getting some frequently used data into more accessible
          variables.
        </p><pre class="programlisting">          struct xxx_softc *sc = device_get_softc(dev);
          int unit = device_get_unit(dev);
          int error = 0;</pre><p>Then allocate and activate all the necessary
          resources. Because normally the port range will be released
          before returning from probe, it has to be allocated
          again. We expect that the probe routine had properly set all
          the resource ranges, as well as saved them in the structure
          softc. If the probe routine had left some resource allocated
          then it does not need to be allocated again (which would be
          considered an error).
        </p><pre class="programlisting">          sc-&gt;port0_rid = 0;
          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;port0_r == NULL)
               return ENXIO;

          /* on-board memory */
          sc-&gt;mem0_rid = 0;
          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,
              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;mem0_r == NULL)
                goto bad;

          /* get its virtual address */
          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);</pre><p>The DMA request channel (DRQ) is allocated likewise. To
          initialize it use functions of the
          <code class="function">isa_dma*()</code> family. For example:
        </p><p><code class="function">isa_dmacascade(sc-&gt;drq0);</code></p><p>The interrupt request line (IRQ) is a bit
          special. Besides allocation the driver's interrupt handler
          should be associated with it. Historically in the old ISA
          drivers the argument passed by the system to the interrupt
          handler was the device unit number. But in modern drivers
          the convention suggests passing the pointer to structure
          softc. The important reason is that when the structures
          softc are allocated dynamically then getting the unit number
          from softc is easy while getting softc from the unit number is
          difficult. Also this convention makes the drivers for
          different buses look more uniform and allows them to share
          the code: each bus gets its own probe, attach, detach and
          other bus-specific routines while the bulk of the driver
          code may be shared among them.
        </p><pre class="programlisting">
          sc-&gt;intr_rid = 0;
          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,
                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);

          if(sc-&gt;intr_r == NULL)
              goto bad;

          /*
           * XXX_INTR_TYPE is supposed to be defined depending on the type of
           * the driver, for example as INTR_TYPE_CAM for a CAM driver
           */
          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,
              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);
          if(error)
              goto bad;

        </pre><p>If the device needs to make DMA to the main memory then
          this memory should be allocated like described before:
        </p><pre class="programlisting">          error=bus_dma_tag_create(NULL, /*alignment*/ 4,
              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,
              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,
              /*nsegments*/ BUS_SPACE_UNRESTRICTED,
              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,
              &amp;sc-&gt;parent_tag);
          if(error)
              goto bad;

          /* many things get inherited from the parent tag
           * sc-&gt;data is supposed to point to the structure with the shared data,
           * for example for a ring buffer it could be:
           * struct {
           *   u_short rd_pos;
           *   u_short wr_pos;
           *   char    bf[XXX_RING_BUFFER_SIZE]
           * } *data;
           */
          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,
              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,
              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,
              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,
              &amp;sc-&gt;data_tag);
          if(error)
              goto bad;

          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,
              &amp;sc-&gt;data_map);
          if(error)
               goto bad;

          /* xxx_alloc_callback() just saves the physical address at
           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.
           * See details in the section on bus memory mapping.
           * It can be implemented like:
           *
           * static void
           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,
           *     int nseg, int error)
           * {
           *    *(bus_addr_t *)arg = seg[0].ds_addr;
           * }
           */
          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,
              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,
              /*flags*/0);</pre><p>After all the necessary resources are allocated the
          device should be initialized. The initialization may include
          testing that all the expected features are functional.</p><pre class="programlisting">          if(xxx_initialize(sc) &lt; 0)
               goto bad;        </pre><p>The bus subsystem will automatically print on the
          console the device description set by probe. But if the
          driver wants to print some extra information about the
          device it may do so, for example:</p><pre class="programlisting">
        device_printf(dev, "has on-card FIFO buffer of %d bytes\n", sc-&gt;fifosize);
        </pre><p>If the initialization routine experiences any problems
          then printing messages about them before returning error is
          also recommended.</p><p>The final step of the attach routine is attaching the
          device to its functional subsystem in the kernel. The exact
          way to do it depends on the type of the driver: a character
          device, a block device, a network device, a CAM SCSI bus
          device and so on.</p><p>If all went well then return success.</p><pre class="programlisting">          error = xxx_attach_subsystem(sc);
          if(error)
              goto bad;

          return 0;        </pre><p>Finally, handle the troublesome situations. All the
          resources should be deallocated before returning an
          error. We make use of the fact that before the structure
          softc is passed to us it gets zeroed out, so we can find out
          if some resource was allocated: then its descriptor is
          non-zero.</p><pre class="programlisting">          bad:

          xxx_free_resources(sc);
          if(error)
              return error;
          else /* exact error is unknown */
              return ENXIO;</pre><p>That would be all for the attach routine.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-detach"></a>10.10. xxx_isa_detach</h2></div></div></div><p>
          If this function is present in the driver and the driver is
          compiled as a loadable module then the driver gets the
          ability to be unloaded. This is an important feature if the
          hardware supports hot plug. But the ISA bus does not support
          hot plug, so this feature is not particularly important for
          the ISA devices. The ability to unload a driver may be
          useful when debugging it, but in many cases installation of
          the new version of the driver would be required only after
          the old version somehow wedges the system and a reboot will be
          needed anyway, so the efforts spent on writing the detach
          routine may not be worth it. Another argument that
          unloading would allow upgrading the drivers on a production
          machine seems to be mostly theoretical. Installing a new
          version of a driver is a dangerous operation which should
          never be performed on a production machine (and which is not
          permitted when the system is running in secure mode).  Still,
          the detach routine may be provided for the sake of
          completeness.
        </p><p>
          The detach routine returns 0 if the driver was successfully
          detached or the error code otherwise.
        </p><p>
          The logic of detach is a mirror of the attach. The first
          thing to do is to detach the driver from its kernel
          subsystem. If the device is currently open then the driver
          has two choices: refuse to be detached or forcibly close and
          proceed with detach. The choice used depends on the ability
          of the particular kernel subsystem to do a forced close and
          on the preferences of the driver's author. Generally the
          forced close seems to be the preferred alternative.
        </p><pre class="programlisting">          struct xxx_softc *sc = device_get_softc(dev);
          int error;

          error = xxx_detach_subsystem(sc);
          if(error)
              return error;</pre><p>
        </p><p>
          Next the driver may want to reset the hardware to some
          consistent state.  That includes stopping any ongoing
          transfers, disabling the DMA channels and interrupts to
          avoid memory corruption by the device. For most of the
          drivers this is exactly what the shutdown routine does, so
          if it is included in the driver we can just call it.
        </p><p><code class="function">xxx_isa_shutdown(dev);</code></p><p>
          And finally release all the resources and return success.
        </p><pre class="programlisting">          xxx_free_resources(sc);
          return 0;</pre><p>

        </p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-shutdown"></a>10.11. xxx_isa_shutdown</h2></div></div></div><p>
          This routine is called when the system is about to be shut
          down. It is expected to bring the hardware to some
          consistent state. For most of the ISA devices no special
          action is required, so the function is not really necessary
          because the device will be re-initialized on reboot
          anyway. But some devices have to be shut down with a special
          procedure, to make sure that they will be properly detected
          after soft reboot (this is especially true for many devices
          with proprietary identification protocols).  In any case
          disabling DMA and interrupts in the device registers and
          stopping any ongoing transfers is a good idea. The exact
          action depends on the hardware, so we do not consider it here
          in any detail.
        </p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="isa-driver-intr"></a>10.12. xxx_intr</h2></div></div></div><a id="idp54765176" class="indexterm"></a><p>
          The interrupt handler is called when an interrupt is
          received which may be from this particular device. The ISA
          bus does not support interrupt sharing (except in some special
          cases) so in practice if the interrupt handler is called
          then the interrupt almost for sure came from its
          device. Still, the interrupt handler must poll the device
          registers and make sure that the interrupt was generated by
          its device. If not it should just return.
        </p><p>
          The old convention for the ISA drivers was getting the
          device unit number as an argument. This is obsolete, and the
          new drivers receive whatever argument was specified for them
          in the attach routine when calling
          <code class="function">bus_setup_intr()</code>. By the new convention
          it should be the pointer to the structure softc. So the
          interrupt handler commonly starts as:
        </p><pre class="programlisting">
          static void
          xxx_intr(struct xxx_softc *sc)
          {

        </pre><p>
          It runs at the interrupt priority level specified by the
          interrupt type parameter of
          <code class="function">bus_setup_intr()</code>. That means that all
          the other interrupts of the same type as well as all the
          software interrupts are disabled.
        </p><p>
          To avoid races it is commonly written as a loop:
        </p><pre class="programlisting">
          while(xxx_interrupt_pending(sc)) {
              xxx_process_interrupt(sc);
              xxx_acknowledge_interrupt(sc);
          }        </pre><p>
          The interrupt handler has to acknowledge interrupt to the
          device only but not to the interrupt controller, the system
          takes care of the latter.
        </p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pci"></a>Chapter 11. PCI Devices</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#pci-probe">11.1. Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#pci-bus">11.2. Bus Resources</a></span></dt></dl></div><a id="idp54770680" class="indexterm"></a><p>This chapter will talk about the FreeBSD mechanisms for
    writing a device driver for a device on a PCI bus.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="pci-probe"></a>11.1. Probe and Attach</h2></div></div></div><p>Information here about how the PCI bus code iterates through
      the unattached devices and see if a newly loaded kld will attach
      to any of them.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54772728"></a>11.1.1. Sample Driver Source
	(<code class="filename">mypci.c</code>)</h3></div></div></div><pre class="programlisting">/*
 * Simple KLD to play with the PCI functions.
 *
 * Murray Stokely
 */

#include &lt;sys/param.h&gt;		/* defines used in kernel.h */
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/kernel.h&gt;		/* types used in module initialization */
#include &lt;sys/conf.h&gt;		/* cdevsw struct */
#include &lt;sys/uio.h&gt;		/* uio struct */
#include &lt;sys/malloc.h&gt;
#include &lt;sys/bus.h&gt;		/* structs, prototypes for pci bus stuff and DEVMETHOD macros! */

#include &lt;machine/bus.h&gt;
#include &lt;sys/rman.h&gt;
#include &lt;machine/resource.h&gt;

#include &lt;dev/pci/pcivar.h&gt;	/* For pci_get macros! */
#include &lt;dev/pci/pcireg.h&gt;

/* The softc holds our per-instance data. */
struct mypci_softc {
	device_t	my_dev;
	struct cdev	*my_cdev;
};

/* Function prototypes */
static d_open_t		mypci_open;
static d_close_t	mypci_close;
static d_read_t		mypci_read;
static d_write_t	mypci_write;

/* Character device entry points */

static struct cdevsw mypci_cdevsw = {
	.d_version =	D_VERSION,
	.d_open =	mypci_open,
	.d_close =	mypci_close,
	.d_read =	mypci_read,
	.d_write =	mypci_write,
	.d_name =	"mypci",
};

/*
 * In the cdevsw routines, we find our softc by using the si_drv1 member
 * of struct cdev.  We set this variable to point to our softc in our
 * attach routine when we create the /dev entry.
 */

int
mypci_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, "Opened successfully.\n");
	return (0);
}

int
mypci_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, "Closed.\n");
	return (0);
}

int
mypci_read(struct cdev *dev, struct uio *uio, int ioflag)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, "Asked to read %zd bytes.\n", uio-&gt;uio_resid);
	return (0);
}

int
mypci_write(struct cdev *dev, struct uio *uio, int ioflag)
{
	struct mypci_softc *sc;

	/* Look up our softc. */
	sc = dev-&gt;si_drv1;
	device_printf(sc-&gt;my_dev, "Asked to write %zd bytes.\n", uio-&gt;uio_resid);
	return (0);
}

/* PCI Support Functions */

/*
 * Compare the device ID of this device against the IDs that this driver
 * supports.  If there is a match, set the description and return success.
 */
static int
mypci_probe(device_t dev)
{

	device_printf(dev, "MyPCI Probe\nVendor ID : 0x%x\nDevice ID : 0x%x\n",
	    pci_get_vendor(dev), pci_get_device(dev));

	if (pci_get_vendor(dev) == 0x11c1) {
		printf("We've got the Winmodem, probe successful!\n");
		device_set_desc(dev, "WinModem");
		return (BUS_PROBE_DEFAULT);
	}
	return (ENXIO);
}

/* Attach function is only called if the probe is successful. */

static int
mypci_attach(device_t dev)
{
	struct mypci_softc *sc;

	printf("MyPCI Attach for : deviceID : 0x%x\n", pci_get_devid(dev));

	/* Look up our softc and initialize its fields. */
	sc = device_get_softc(dev);
	sc-&gt;my_dev = dev;

	/*
	 * Create a /dev entry for this device.  The kernel will assign us
	 * a major number automatically.  We use the unit number of this
	 * device as the minor number and name the character device
	 * "mypci&lt;unit&gt;".
	 */
	sc-&gt;my_cdev = make_dev(<code class="literal">&amp;</code>mypci_cdevsw, device_get_unit(dev),
	    UID_ROOT, GID_WHEEL, 0600, "mypci%u", device_get_unit(dev));
	sc-&gt;my_cdev-&gt;si_drv1 = sc;
	printf("Mypci device loaded.\n");
	return (0);
}

/* Detach device. */

static int
mypci_detach(device_t dev)
{
	struct mypci_softc *sc;

	/* Teardown the state in our softc created in our attach routine. */
	sc = device_get_softc(dev);
	destroy_dev(sc-&gt;my_cdev);
	printf("Mypci detach!\n");
	return (0);
}

/* Called during system shutdown after sync. */

static int
mypci_shutdown(device_t dev)
{

	printf("Mypci shutdown!\n");
	return (0);
}

/*
 * Device suspend routine.
 */
static int
mypci_suspend(device_t dev)
{

	printf("Mypci suspend!\n");
	return (0);
}

/*
 * Device resume routine.
 */
static int
mypci_resume(device_t dev)
{

	printf("Mypci resume!\n");
	return (0);
}

static device_method_t mypci_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		mypci_probe),
	DEVMETHOD(device_attach,	mypci_attach),
	DEVMETHOD(device_detach,	mypci_detach),
	DEVMETHOD(device_shutdown,	mypci_shutdown),
	DEVMETHOD(device_suspend,	mypci_suspend),
	DEVMETHOD(device_resume,	mypci_resume),

	DEVMETHOD_END
};

static devclass_t mypci_devclass;

DEFINE_CLASS_0(mypci, mypci_driver, mypci_methods, sizeof(struct mypci_softc));
DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54774648"></a>11.1.2. <code class="filename">Makefile</code> for Sample Driver</h3></div></div></div><pre class="programlisting"># Makefile for mypci driver

KMOD=	mypci
SRCS=	mypci.c
SRCS+=	device_if.h bus_if.h pci_if.h

.include &lt;bsd.kmod.mk&gt;</pre><p>If you place the above source file and
	<code class="filename">Makefile</code> into a directory, you may run
	<code class="command">make</code> to compile the sample driver.
	Additionally, you may run <code class="command">make load</code> to load
	the driver into the currently running kernel and <code class="command">make
	unload</code> to unload the driver after it is
	loaded.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54777976"></a>11.1.3. Additional Resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="http://www.pcisig.org/" target="_top">PCI
	    Special Interest Group</a></li><li class="listitem">PCI System Architecture, Fourth Edition by
	    Tom Shanley, et al.</li></ul></div></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="pci-bus"></a>11.2. Bus Resources</h2></div></div></div><a id="idp54798072" class="indexterm"></a><p>FreeBSD provides an object-oriented mechanism for requesting
      resources from a parent bus.  Almost all devices will be a child
      member of some sort of bus (PCI, ISA, USB, SCSI, etc) and these
      devices need to acquire resources from their parent bus (such as
      memory segments, interrupt lines, or DMA channels).</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54799224"></a>11.2.1. Base Address Registers</h3></div></div></div><a id="idp54799864" class="indexterm"></a><p>To do anything particularly useful with a PCI device you
	will need to obtain the <span class="emphasis"><em>Base Address
	  Registers</em></span> (BARs) from the PCI Configuration
	    space.  The PCI-specific details of obtaining the BAR are
	abstracted in the <code class="function">bus_alloc_resource()</code>
	function.</p><p>For example, a typical driver might have something similar
	to this in the <code class="function">attach()</code> function:</p><pre class="programlisting">    sc-&gt;bar0id = PCIR_BAR(0);
    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar0res == NULL) {
        printf("Memory allocation of PCI base register 0 failed!\n");
        error = ENXIO;
        goto fail1;
    }

    sc-&gt;bar1id = PCIR_BAR(1);
    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,
				  0, ~0, 1, RF_ACTIVE);
    if (sc-&gt;bar1res == NULL) {
        printf("Memory allocation of PCI base register 1 failed!\n");
        error =  ENXIO;
        goto fail2;
    }
    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);
    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);
    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);
    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);</pre><p>Handles for each base address register are kept in the
	<code class="varname">softc</code> structure so that
	they can be used to write to the device later.</p><p>These handles can then be used to read or write from the
	device registers with the <code class="function">bus_space_*</code>
	functions.  For example, a driver might contain a shorthand
	function to read from a board specific register like
	this:</p><pre class="programlisting">uint16_t
board_read(struct ni_softc *sc, uint16_t address)
{
    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);
}</pre><p>Similarly, one could write to the registers with:</p><pre class="programlisting">void
board_write(struct ni_softc *sc, uint16_t address, uint16_t value)
{
    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);
}</pre><p>These functions exist in 8bit, 16bit, and 32bit versions
	and you should use
	<code class="function">bus_space_{read|write}_{1|2|4}</code>
	accordingly.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">In FreeBSD 7.0 and later, you can use the
	  <code class="function">bus_*</code> functions instead of
	  <code class="function">bus_space_*</code>.  The
	  <code class="function">bus_*</code> functions take a <span class="type">struct
	  resource *</span> pointer instead of a bus tag and handle.
	  Thus, you could drop the bus tag and bus handle members from
	  the <code class="varname">softc</code> and rewrite
	  the <code class="function">board_read()</code> function as:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">uint16_t
board_read(struct ni_softc *sc, uint16_t address)
{
	return (bus_read(sc-&gt;bar1res, address));
}</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54822904"></a>11.2.2. Interrupts</h3></div></div></div><a id="idp54823544" class="indexterm"></a><p>Interrupts are allocated from the object-oriented bus code
	in a way similar to the memory resources.  First an IRQ
	resource must be allocated from the parent bus, and then the
	interrupt handler must be set up to deal with this IRQ.</p><p>Again, a sample from a device
	<code class="function">attach()</code> function says more than
	words.</p><pre class="programlisting">/* Get the IRQ resource */

    sc-&gt;irqid = 0x0;
    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),
				  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);
    if (sc-&gt;irqres == NULL) {
	printf("IRQ allocation failed!\n");
	error = ENXIO;
	goto fail3;
    }

    /* Now we should set up the interrupt handler */

    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,
			   my_handler, sc, &amp;(sc-&gt;handler));
    if (error) {
	printf("Couldn't set up irq\n");
	goto fail4;
    }</pre><p>Some care must be taken in the detach routine of the
	driver.  You must quiesce the device's interrupt stream, and
	remove the interrupt handler.  Once
	<code class="function">bus_teardown_intr()</code> has returned, you
	know that your interrupt handler will no longer be called and
	that all threads that might have been executing this interrupt
	handler have returned.  Since this function can sleep, you
	must not hold any mutexes when calling this function.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54826744"></a>11.2.3. DMA</h3></div></div></div><a id="idp54827384" class="indexterm"></a><p>This section is obsolete, and present only for historical
	reasons.  The proper methods for dealing with these issues is
	to use the <code class="function">bus_space_dma*()</code> functions
	instead.  This paragraph can be removed when this section is
	updated to reflect that usage.  However, at the moment, the
	API is in a bit of flux, so once that settles down, it would
	be good to update this section to reflect that.</p><p>On the PC, peripherals that want to do bus-mastering DMA
	must deal with physical addresses.  This is a problem since
	FreeBSD uses virtual memory and deals almost exclusively with
	virtual addresses.  Fortunately, there is a function,
	<code class="function">vtophys()</code> to help.</p><pre class="programlisting">#include &lt;vm/vm.h&gt;
#include &lt;vm/pmap.h&gt;

#define vtophys(virtual_address) (...)</pre><p>The solution is a bit different on the alpha however, and
	what we really want is a function called
	<code class="function">vtobus()</code>.</p><pre class="programlisting">#if defined(__alpha__)
#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)
#else
#define vtobus(va)      vtophys(va)
#endif</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54831352"></a>11.2.4. Deallocating Resources</h3></div></div></div><p>It is very important to deallocate all of the resources
	that were allocated during <code class="function">attach()</code>.
	Care must be taken to deallocate the correct stuff even on a
	failure condition so that the system will remain usable while
	your driver dies.</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="scsi"></a>Chapter 12. Common Access Method SCSI Controllers</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Sergey</span> <span class="surname">Babkin</span></span>. </span></div><div><span class="authorgroup">Modifications for Handbook made by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Murray</span> <span class="surname">Stokely</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#scsi-synopsis">12.1. Synopsis</a></span></dt><dt><span class="sect1"><a href="#scsi-general">12.2. General Architecture</a></span></dt><dt><span class="sect1"><a href="#scsi-polling">12.3. Polling</a></span></dt><dt><span class="sect1"><a href="#scsi-async">12.4. Asynchronous Events</a></span></dt><dt><span class="sect1"><a href="#scsi-interrupts">12.5. Interrupts</a></span></dt><dt><span class="sect1"><a href="#scsi-errors">12.6. Errors Summary</a></span></dt><dt><span class="sect1"><a href="#scsi-timeout">12.7. Timeout Handling</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-synopsis"></a>12.1. Synopsis</h2></div></div></div><a id="idp54838392" class="indexterm"></a><p>This document assumes that the reader has a general
      understanding of device drivers in FreeBSD and of the SCSI
      protocol.  Much of the information in this document was
      extracted from the drivers:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ncr (<code class="filename">/sys/pci/ncr.c</code>) by
	Wolfgang Stanglmeier and Stefan Esser</p></li><li class="listitem"><p>sym (<code class="filename">/sys/dev/sym/sym_hipd.c</code>) by
	  Gerard Roudier</p></li><li class="listitem"><p>aic7xxx
	  (<code class="filename">/sys/dev/aic7xxx/aic7xxx.c</code>) by Justin
	  T. Gibbs</p></li></ul></div><p>and from the CAM code itself (by Justin T. Gibbs, see
      <code class="filename">/sys/cam/*</code>).  When some solution looked the
      most logical and was essentially verbatim extracted from the
      code by Justin T. Gibbs, I marked it as
      <span class="quote">&#8220;<span class="quote">recommended</span>&#8221;</span>.</p><p>The document is illustrated with examples in
      pseudo-code.  Although sometimes the examples have many details
      and look like real code, it is still pseudo-code.  It was
      written to demonstrate the concepts in an understandable way.
      For a real driver other approaches may be more modular and
      efficient.  It also abstracts from the hardware details, as well
      as issues that would cloud the demonstrated concepts or that are
      supposed to be described in the other chapters of the developers
      handbook.  Such details are commonly shown as calls to functions
      with descriptive names, comments or pseudo-statements.
      Fortunately real life full-size examples with all the details
      can be found in the real drivers.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-general"></a>12.2. General Architecture</h2></div></div></div><a id="idp54849400" class="indexterm"></a><p>CAM stands for Common Access Method.  It is a generic way to
      address the I/O buses in a SCSI-like way.  This allows a
      separation of the generic device drivers from the drivers
      controlling the I/O bus: for example the disk driver becomes
      able to control disks on both SCSI, IDE, and/or any other bus so
      the disk driver portion does not have to be rewritten (or copied
      and modified) for every new I/O bus.  Thus the two most
      important active entities are:</p><a id="idp54850552" class="indexterm"></a><a id="idp54851064" class="indexterm"></a><a id="idp54851576" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Peripheral Modules</em></span> - a
	  driver for peripheral devices (disk, tape, CD-ROM,
	  etc.)</p></li><li class="listitem"><p><span class="emphasis"><em>SCSI Interface Modules </em></span>(SIM) - a
	  Host Bus Adapter drivers for connecting to an I/O bus such
	  as SCSI or IDE.</p></li></ul></div><p>A peripheral driver receives requests from the OS, converts
      them to a sequence of SCSI commands and passes these SCSI
      commands to a SCSI Interface Module.  The SCSI Interface Module
      is responsible for passing these commands to the actual hardware
      (or if the actual hardware is not SCSI but, for example, IDE
      then also converting the SCSI commands to the native commands of
      the hardware).</p><p>Because we are interested in writing a SCSI adapter driver
      here, from this point on we will consider everything from the
      SIM standpoint.</p><p>A typical SIM driver needs to include the following
      CAM-related header files:</p><pre class="programlisting">#include &lt;cam/cam.h&gt;
#include &lt;cam/cam_ccb.h&gt;
#include &lt;cam/cam_sim.h&gt;
#include &lt;cam/cam_xpt_sim.h&gt;
#include &lt;cam/cam_debug.h&gt;
#include &lt;cam/scsi/scsi_all.h&gt;</pre><p>The first thing each SIM driver must do is register itself
      with the CAM subsystem.  This is done during the driver's
      <code class="function">xxx_attach()</code> function (here and further
      xxx_ is used to denote the unique driver name prefix).  The
      <code class="function">xxx_attach()</code> function itself is called by
      the system bus auto-configuration code which we do not describe
      here.</p><p>This is achieved in multiple steps: first it is necessary to
      allocate the queue of requests associated with this SIM:</p><pre class="programlisting">    struct cam_devq *devq;

    if(( devq = cam_simq_alloc(SIZE) )==NULL) {
        error; /* some code to handle the error */
    }</pre><p>Here <code class="literal">SIZE</code> is the size of the queue to be
      allocated, maximal number of requests it could contain.  It is
      the number of requests that the SIM driver can handle in
      parallel on one SCSI card.  Commonly it can be calculated
      as:</p><pre class="programlisting">SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET</pre><p>Next we create a descriptor of our SIM:</p><pre class="programlisting">    struct cam_sim *sim;

    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,
            softc, unit, mtx, max_dev_transactions,
            max_tagged_dev_transactions, devq) )==NULL) {
        cam_simq_free(devq);
        error; /* some code to handle the error */
    }</pre><p>Note that if we are not able to create a SIM descriptor we
      free the <code class="varname">devq</code> also because we can do
      nothing else with it and we want to conserve memory.</p><p>If a SCSI card has multiple SCSI
      buses<a id="idp54889848" class="indexterm"></a>
      on it then each bus requires its own
      <code class="varname">cam_sim</code> structure.</p><p>An interesting question is what to do if a SCSI card has
      more than one SCSI bus, do we need one
      <code class="varname">devq</code> structure per card or per SCSI
      bus?  The answer given in the comments to the CAM code is:
      either way, as the driver's author prefers.</p><p>The arguments are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">action_func</code> - pointer to
	  the driver's <code class="function">xxx_action</code> function.
	  </p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">static void
		<strong class="fsfunc">xxx_action</strong>
	      (</code></td><td><var class="pdparam">struct cam_sim *sim</var><var class="pdparam">union ccb *ccb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>
		<var class="pdparam">struct cam_sim *sim</var>,
		<var class="pdparam">union ccb *ccb</var>
	      </code>;</div><div class="funcprototype-spacer"> </div></div></li><li class="listitem"><p><code class="function">poll_func</code> - pointer to
	  the driver's <code class="function">xxx_poll()</code>
	  </p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">static void
		<strong class="fsfunc">xxx_poll</strong>
	      (</code></td><td><var class="pdparam">struct cam_sim *sim</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>
		<var class="pdparam">struct cam_sim *sim</var>
	      </code>;</div><div class="funcprototype-spacer"> </div></div></li><li class="listitem"><p>driver_name - the name of the actual driver,
	  such as <span class="quote">&#8220;<span class="quote">ncr</span>&#8221;</span> or
	  <span class="quote">&#8220;<span class="quote">wds</span>&#8221;</span>.</p></li><li class="listitem"><p><code class="varname">softc</code> - pointer to the driver's
	  internal descriptor for this SCSI card.  This pointer will
	  be used by the driver in future to get private
	  data.</p></li><li class="listitem"><p>unit - the controller unit number, for example
	  for controller <span class="quote">&#8220;<span class="quote">mps0</span>&#8221;</span> this number will be
	  0</p></li><li class="listitem"><p>mtx - Lock associated with this SIM. For SIMs that don't
	know about locking, pass in Giant. For SIMs that do, pass in
	the lock used to guard this SIM's data structures. This lock
	will be held when xxx_action and xxx_poll are called.</p></li><li class="listitem"><p>max_dev_transactions - maximal number of simultaneous
	  transactions per SCSI target in the non-tagged mode.  This
	  value will be almost universally equal to 1, with possible
	  exceptions only for the non-SCSI cards.  Also the drivers
	  that hope to take advantage by preparing one transaction
	  while another one is executed may set it to 2 but this does
	  not seem to be worth the complexity.</p></li><li class="listitem"><p>max_tagged_dev_transactions - the same thing, but in the
	  tagged mode.  Tags are the SCSI way to initiate multiple
	  transactions on a device: each transaction is assigned a
	  unique tag and the transaction is sent to the device.  When
	  the device completes some transaction it sends back the
	  result together with the tag so that the SCSI adapter (and
	  the driver) can tell which transaction was completed.  This
	  argument is also known as the maximal tag depth.  It depends
	  on the abilities of the SCSI adapter.</p></li></ul></div><p>Finally we register the SCSI buses associated with our SCSI
      adapter<a id="idp54915064" class="indexterm"></a>:</p><pre class="programlisting">    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {
        cam_sim_free(sim, /*free_devq*/ TRUE);
        error; /* some code to handle the error */
    }</pre><p>If there is one <code class="varname">devq</code> structure per
      SCSI bus (i.e., we consider a card with multiple buses as
      multiple cards with one bus each) then the bus number will
      always be 0, otherwise each bus on the SCSI card should be get a
      distinct number.  Each bus needs its own separate structure
      cam_sim.</p><p>After that our controller is completely hooked to the CAM
      system.  The value of <code class="varname">devq</code> can be
      discarded now: sim will be passed as an argument in all further
      calls from CAM and devq can be derived from it.</p><p>CAM provides the framework for such asynchronous events.
      Some events originate from the lower levels (the SIM drivers),
      some events originate from the peripheral drivers, some events
      originate from the CAM subsystem itself.  Any driver can
      register callbacks for some types of the asynchronous events, so
      that it would be notified if these events occur.</p><p>A typical example of such an event is a device reset.  Each
      transaction and event identifies the devices to which it applies
      by the means of <span class="quote">&#8220;<span class="quote">path</span>&#8221;</span>.  The target-specific events
      normally occur during a transaction with this device.  So the
      path from that transaction may be re-used to report this event
      (this is safe because the event path is copied in the event
      reporting routine but not deallocated nor passed anywhere
      further).  Also it is safe to allocate paths dynamically at any
      time including the interrupt routines, although that incurs
      certain overhead, and a possible problem with this approach is
      that there may be no free memory at that time.  For a bus reset
      event we need to define a wildcard path including all devices on
      the bus.  So we can create the path for the future bus reset
      events in advance and avoid problems with the future memory
      shortage:</p><pre class="programlisting">    struct cam_path *path;

    if(xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), CAM_TARGET_WILDCARD,
                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {
        xpt_bus_deregister(cam_sim_path(sim));
        cam_sim_free(sim, /*free_devq*/TRUE);
        error; /* some code to handle the error */
    }

    softc-&gt;wpath = path;
    softc-&gt;sim = sim;</pre><p>As you can see the path includes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ID of the peripheral driver (NULL here because we have
	  none)</p></li><li class="listitem"><p>ID of the SIM driver
	  (<code class="function">cam_sim_path(sim)</code>)</p></li><li class="listitem"><p>SCSI target number of the device (CAM_TARGET_WILDCARD
	  means <span class="quote">&#8220;<span class="quote">all devices</span>&#8221;</span>)</p></li><li class="listitem"><p>SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means
	  <span class="quote">&#8220;<span class="quote">all LUNs</span>&#8221;</span>)</p></li></ul></div><p>If the driver can not allocate this path it will not be able
      to work normally, so in that case we dismantle that SCSI
      bus.</p><p>And we save the path pointer in the
      <code class="varname">softc</code> structure for future use.  After
      that we save the value of sim (or we can also discard it on the
      exit from <code class="function">xxx_probe()</code> if we wish).</p><p>That is all for a minimalistic initialization.  To do things
      right there is one more issue left.</p><p>For a SIM driver there is one particularly interesting
      event: when a target device is considered lost.  In this case
      resetting the SCSI negotiations with this device may be a good
      idea.  So we register a callback for this event with CAM.  The
      request is passed to CAM by requesting CAM action on a CAM
      control block for this type of request:</p><pre class="programlisting">    struct ccb_setasync csa;

    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);
    csa.ccb_h.func_code = XPT_SASYNC_CB;
    csa.event_enable = AC_LOST_DEVICE;
    csa.callback = xxx_async;
    csa.callback_arg = sim;
    xpt_action((union ccb *)&amp;csa);</pre><p>Now we take a look at the <code class="function">xxx_action()</code>
      and <code class="function">xxx_poll()</code> driver entry points.</p><p>
      </p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">static void
	    <strong class="fsfunc">xxx_action</strong>
	  (</code></td><td><var class="pdparam">struct cam_sim *sim</var><var class="pdparam">union ccb *ccb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>
	    <var class="pdparam">struct cam_sim *sim</var>,
	    <var class="pdparam">union ccb *ccb</var>
	  </code>;</div><div class="funcprototype-spacer"> </div></div><p>Do some action on request of the CAM subsystem.  Sim
      describes the SIM for the request, CCB is the request itself.
      CCB stands for <span class="quote">&#8220;<span class="quote">CAM Control Block</span>&#8221;</span>.  It is a union
      of many specific instances, each describing arguments for some
      type of transactions.  All of these instances share the CCB
      header where the common part of arguments is stored.</p><p>CAM supports the SCSI controllers working in both initiator
      (<span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span>) mode and target (simulating a SCSI
      device) mode.  Here we only consider the part relevant to the
      initiator mode.</p><p>There are a few function and macros (in other words,
      methods) defined to access the public data in the struct
      sim:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">cam_sim_path(sim)</code> - the path ID
	  (see above)</p></li><li class="listitem"><p><code class="function">cam_sim_name(sim)</code> - the name of the
	  sim</p></li><li class="listitem"><p><code class="function">cam_sim_softc(sim)</code> - the pointer to
	  the softc (driver private data) structure</p></li><li class="listitem"><p><code class="function"> cam_sim_unit(sim)</code> - the unit
	  number</p></li><li class="listitem"><p><code class="function"> cam_sim_bus(sim)</code> - the bus
	  ID</p></li></ul></div><p>To identify the device, <code class="function">xxx_action()</code>
      can get the unit number and pointer to its structure softc using
      these functions.</p><p>The type of request is stored in
      <code class="varname">ccb-&gt;ccb_h.func_code</code>.  So
      generally <code class="function">xxx_action()</code> consists of a big
      switch:</p><pre class="programlisting">    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);
    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;
    int unit = cam_sim_unit(sim);
    int bus = cam_sim_bus(sim);

    switch(ccb_h-&gt;func_code) {
    case ...:
        ...
    default:
        ccb_h-&gt;status = CAM_REQ_INVALID;
        xpt_done(ccb);
        break;
    }</pre><p>As can be seen from the default case (if an unknown command
      was received) the return code of the command is set into
      <code class="varname">ccb-&gt;ccb_h.status</code> and the
      completed CCB is returned back to CAM by calling
      <code class="function">xpt_done(ccb)</code>.</p><p><code class="function">xpt_done()</code> does not have to be called
      from <code class="function">xxx_action()</code>: For example an I/O
      request may be enqueued inside the SIM driver and/or its SCSI
      controller.  Then when the device would post an interrupt
      signaling that the processing of this request is complete
      <code class="function">xpt_done()</code> may be called from the interrupt
      handling routine.</p><p>Actually, the CCB status is not only assigned as a return
      code but a CCB has some status all the time.  Before CCB is
      passed to the <code class="function">xxx_action()</code> routine it gets
      the status CCB_REQ_INPROG meaning that it is in progress.  There
      are a surprising number of status values defined in
      <code class="filename">/sys/cam/cam.h</code> which should be able to
      represent the status of a request in great detail.  More
      interesting yet, the status is in fact a <span class="quote">&#8220;<span class="quote">bitwise
      or</span>&#8221;</span> of an enumerated status value (the lower 6 bits) and
      possible additional flag-like bits (the upper bits).  The
      enumerated values will be discussed later in more detail.  The
      summary of them can be found in the Errors Summary section.  The
      possible status flags are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>CAM_DEV_QFRZN</em></span> - if the SIM driver
	  gets a serious error (for example, the device does not
	  respond to the selection or breaks the SCSI protocol) when
	  processing a CCB it should freeze the request queue by
	  calling <code class="function">xpt_freeze_simq()</code>, return the
	  other enqueued but not processed yet CCBs for this device
	  back to the CAM queue, then set this flag for the
	  troublesome CCB and call <code class="function">xpt_done()</code>.
	  This flag causes the CAM subsystem to unfreeze the queue
	  after it handles the error.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_AUTOSNS_VALID</em></span> - if the
	  device returned an error condition and the flag
	  CAM_DIS_AUTOSENSE is not set in CCB the SIM driver must
	  execute the REQUEST SENSE command automatically to extract
	  the sense (extended error information) data from the device.
	  If this attempt was successful the sense data should be
	  saved in the CCB and this flag set.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_RELEASE_SIMQ</em></span> - like
	  CAM_DEV_QFRZN but used in case there is some problem (or
	  resource shortage) with the SCSI controller itself.  Then
	  all the future requests to the controller should be stopped
	  by <code class="function">xpt_freeze_simq()</code>.  The controller
	  queue will be restarted after the SIM driver overcomes the
	  shortage and informs CAM by returning some CCB with this
	  flag set.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_SIM_QUEUED</em></span> - when SIM puts a
	  CCB into its request queue this flag should be set (and
	  removed when this CCB gets dequeued before being returned
	  back to CAM).  This flag is not used anywhere in the CAM
	  code now, so its purpose is purely diagnostic.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_QOS_VALID</em></span> - The QOS data
	  is now valid.</p></li></ul></div><p>The function <code class="function">xxx_action()</code> is not
      allowed to sleep, so all the synchronization for resource access
      must be done using SIM or device queue freezing.  Besides the
      aforementioned flags the CAM subsystem provides functions
      <code class="function">xpt_release_simq()</code> and
      <code class="function">xpt_release_devq()</code> to unfreeze the queues
      directly, without passing a CCB to CAM.</p><p>The CCB header contains the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>path</em></span> - path ID for the
	  request</p></li><li class="listitem"><p><span class="emphasis"><em>target_id</em></span> - target device ID for
	  the request</p></li><li class="listitem"><p><span class="emphasis"><em>target_lun</em></span> - LUN ID of the target
	  device</p></li><li class="listitem"><p><span class="emphasis"><em>timeout</em></span> - timeout interval for this
	  command, in milliseconds</p></li><li class="listitem"><p><span class="emphasis"><em>timeout_ch</em></span> - a convenience place
	  for the SIM driver to store the timeout handle (the CAM
	  subsystem itself does not make any assumptions about
	  it)</p></li><li class="listitem"><p><span class="emphasis"><em>flags</em></span> - various bits of information
	  about the request spriv_ptr0, spriv_ptr1 - fields reserved
	  for private use by the SIM driver (such as linking to the
	  SIM queues or SIM private control blocks); actually, they
	  exist as unions: spriv_ptr0 and spriv_ptr1 have the type
	  (void *), spriv_field0 and spriv_field1 have the type
	  unsigned long, sim_priv.entries[0].bytes and
	  sim_priv.entries[1].bytes are byte arrays of the size
	  consistent with the other incarnations of the union and
	  sim_priv.bytes is one array, twice bigger.</p></li></ul></div><p>The recommended way of using the SIM private fields of CCB
      is to define some meaningful names for them and use these
      meaningful names in the driver, like:</p><pre class="programlisting">#define ccb_some_meaningful_name    sim_priv.entries[0].bytes
#define ccb_hcb spriv_ptr1 /* for hardware control block */</pre><p>The most common initiator mode requests are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>XPT_SCSI_IO</em></span> - execute an I/O
	  transaction</p><p>The instance <span class="quote">&#8220;<span class="quote">struct ccb_scsiio csio</span>&#8221;</span> of
	  the union ccb is used to transfer the arguments.  They
	  are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>cdb_io</em></span> - pointer to the SCSI
	      command buffer or the buffer itself</p></li><li class="listitem"><p><span class="emphasis"><em>cdb_len</em></span> - SCSI command
	      length</p></li><li class="listitem"><p><span class="emphasis"><em>data_ptr</em></span> - pointer to the data
	      buffer (gets a bit complicated if scatter/gather is
	      used)</p></li><li class="listitem"><p><span class="emphasis"><em>dxfer_len</em></span> - length of the data
	      to transfer</p></li><li class="listitem"><p><span class="emphasis"><em>sglist_cnt</em></span> - counter of the
	      scatter/gather segments</p></li><li class="listitem"><p><span class="emphasis"><em>scsi_status</em></span> - place to return
	      the SCSI status</p></li><li class="listitem"><p><span class="emphasis"><em>sense_data</em></span> - buffer for the
	      SCSI sense information if the command returns an error
	      (the SIM driver is supposed to run the REQUEST SENSE
	      command automatically in this case if the CCB flag
	      CAM_DIS_AUTOSENSE is not set)</p></li><li class="listitem"><p><span class="emphasis"><em>sense_len</em></span> - the length of that
	      buffer (if it happens to be higher than size of
	      sense_data the SIM driver must silently assume the
	      smaller value) resid, sense_resid - if the transfer of
	      data or SCSI sense returned an error these are the
	      returned counters of the residual (not transferred)
	      data.  They do not seem to be especially meaningful, so
	      in a case when they are difficult to compute (say,
	      counting bytes in the SCSI controller's FIFO buffer) an
	      approximate value will do as well.  For a successfully
	      completed transfer they must be set to
	      zero.</p></li><li class="listitem"><p><span class="emphasis"><em>tag_action</em></span> - the kind of tag to
	      use:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>CAM_TAG_ACTION_NONE - do not use tags for this
		  transaction</p></li><li class="listitem"><p>MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG,
		  MSG_ORDERED_Q_TAG - value equal to the appropriate
		  tag message (see /sys/cam/scsi/scsi_message.h); this
		  gives only the tag type, the SIM driver must assign
		  the tag value itself</p></li></ul></div></li></ul></div><p>The general logic of handling this request is the
	  following:</p><p>The first thing to do is to check for possible races, to
	  make sure that the command did not get aborted when it was
	  sitting in the queue:</p><pre class="programlisting">    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;

    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {
        xpt_done(ccb);
        return;
    }</pre><p>Also we check that the device is supported at all by our
	  controller:</p><pre class="programlisting">    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID
    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {
        ccb_h-&gt;status = CAM_TID_INVALID;
        xpt_done(ccb);
        return;
    }
    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {
        ccb_h-&gt;status = CAM_LUN_INVALID;
        xpt_done(ccb);
        return;
    }</pre><p>Then allocate whatever data structures (such as
	  card-dependent hardware control
	  block<a id="idp54998520" class="indexterm"></a>) we need to process this
	  request.  If we can not then freeze the SIM queue and
	  remember that we have a pending operation, return the CCB
	  back and ask CAM to re-queue it.  Later when the resources
	  become available the SIM queue must be unfrozen by returning
	  a ccb with the <code class="literal">CAM_SIMQ_RELEASE</code> bit set
	  in its status.  Otherwise, if all went well, link the CCB
	  with the hardware control block (HCB) and mark it as
	  queued.</p><pre class="programlisting">    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);

    if(hcb == NULL) {
        softc-&gt;flags |= RESOURCE_SHORTAGE;
        xpt_freeze_simq(sim, /*count*/1);
        ccb_h-&gt;status = CAM_REQUEUE_REQ;
        xpt_done(ccb);
        return;
    }

    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;
    ccb_h-&gt;status |= CAM_SIM_QUEUED;</pre><p>Extract the target data from CCB into the hardware
	  control block.  Check if we are asked to assign a tag and if
	  yes then generate an unique tag and build the SCSI tag
	  messages.  The SIM driver is also responsible for
	  negotiations with the devices to set the maximal mutually
	  supported bus width, synchronous rate and offset.</p><pre class="programlisting">    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;
    generate_identify_message(hcb);
    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )
        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);
    if( !target_negotiated(hcb) )
        generate_negotiation_messages(hcb);</pre><p>Then set up the SCSI command.  The command storage may
	  be specified in the CCB in many interesting ways, specified
	  by the CCB flags.  The command buffer can be contained in
	  CCB or pointed to, in the latter case the pointer may be
	  physical or virtual.  Since the hardware commonly needs
	  physical address we always convert the address to the
	  physical one, typically using the busdma API.</p><p>In case if a physical address is
	  requested it is OK to return the CCB with the status
	  <span class="errorname">CAM_REQ_INVALID</span>, the current drivers
	  do that.  If necessary a physical address can be also
	  converted or mapped back to a virtual address but with
	  big pain, so we do not do that.</p><pre class="programlisting">    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {
        /* CDB is a pointer */
        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {
            /* CDB pointer is virtual */
            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);
        } else {
            /* CDB pointer is physical */
            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;
        }
    } else {
        /* CDB is in the ccb (buffer) */
        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);
    }
    hcb-&gt;cmdlen = csio-&gt;cdb_len;</pre><p>Now it is time to set up the data.  Again, the data
	  storage may be specified in the CCB in many interesting
	  ways, specified by the CCB flags.  First we get the
	  direction of the data transfer.  The simplest case is if
	  there is no data to transfer:</p><pre class="programlisting">    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);

    if (dir == CAM_DIR_NONE)
        goto end_data;</pre><p>Then we check if the data is in one chunk or in a
	  scatter-gather list, and the addresses are physical or
	  virtual.  The SCSI controller may be able to handle only a
	  limited number of chunks of limited length.  If the request
	  hits this limitation we return an error.  We use a special
	  function to return the CCB to handle in one place the HCB
	  resource shortages.  The functions to add chunks are
	  driver-dependent, and here we leave them without detailed
	  implementation.  See description of the SCSI command (CDB)
	  handling for the details on the address-translation issues.
	  If some variation is too difficult or impossible to
	  implement with a particular card it is OK to return the
	  status <span class="errorname">CAM_REQ_INVALID</span>.  Actually, it
	  seems like the scatter-gather ability is not used anywhere
	  in the CAM code now.  But at least the case for a single
	  non-scattered virtual buffer must be implemented, it is
	  actively used by CAM.</p><pre class="programlisting">    int rv;

    initialize_hcb_for_data(hcb);

    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {
        /* single buffer */
        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
            }
        } else {
            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);
        }
    } else {
        int i;
        struct bus_dma_segment *segs;
        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;

        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {
            /* The SG list pointer is physical */
            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);
        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {
            /* SG buffer pointers are virtual */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_virtual_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        } else {
            /* SG buffer pointers are physical */
            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {
                rv = add_physical_chunk(hcb, segs[i].ds_addr,
                    segs[i].ds_len, dir);
                if (rv != CAM_REQ_CMP)
                    break;
            }
        }
    }
    if(rv != CAM_REQ_CMP) {
        /* we expect that add_*_chunk() functions return CAM_REQ_CMP
         * if they added a chunk successfully, CAM_REQ_TOO_BIG if
         * the request is too big (too many bytes or too many chunks),
         * CAM_REQ_INVALID in case of other troubles
         */
        free_hcb_and_ccb_done(hcb, ccb, rv);
        return;
    }
    end_data:</pre><p>If disconnection is disabled for this CCB we pass this
	  information to the hcb:</p><pre class="programlisting">    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)
        hcb_disable_disconnect(hcb);</pre><p>If the controller is able to run REQUEST SENSE command
	  all by itself then the value of the flag CAM_DIS_AUTOSENSE
	  should also be passed to it, to prevent automatic REQUEST
	  SENSE if the CAM subsystem does not want it.</p><p>The only thing left is to set up the timeout, pass our
	  hcb to the hardware and return, the rest will be done by the
	  interrupt handler (or timeout handler).</p><pre class="programlisting">    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,
        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */
    put_hcb_into_hardware_queue(hcb);
    return;</pre><p>And here is a possible implementation of the function
	  returning CCB:</p><pre class="programlisting">    static void
    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)
    {
        struct xxx_softc *softc = hcb-&gt;softc;

        ccb-&gt;ccb_h.ccb_hcb = 0;
        if(hcb != NULL) {
            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);
            /* we're about to free a hcb, so the shortage has ended */
            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {
                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;
                status |= CAM_RELEASE_SIMQ;
            }
            free_hcb(hcb); /* also removes hcb from any internal lists */
        }
        ccb-&gt;ccb_h.status = status |
            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));
        xpt_done(ccb);
    }</pre></li><li class="listitem"><p><span class="emphasis"><em>XPT_RESET_DEV</em></span> - send the SCSI
	  <span class="quote">&#8220;<span class="quote">BUS DEVICE RESET</span>&#8221;</span> message to a device</p><p>There is no data transferred in CCB except the header
	  and the most interesting argument of it is target_id.
	  Depending on the controller hardware a hardware control
	  block just like for the XPT_SCSI_IO request may be
	  constructed (see XPT_SCSI_IO request description) and sent
	  to the controller or the SCSI controller may be immediately
	  programmed to send this RESET message to the device or this
	  request may be just not supported (and return the status
	  <span class="errorname">CAM_REQ_INVALID</span>).  Also on completion
	  of the request all the disconnected transactions for this
	  target must be aborted (probably in the interrupt
	  routine).</p><p>Also all the current negotiations for the target are
	  lost on reset, so they might be cleaned too.  Or they
	  clearing may be deferred, because anyway the target would
	  request re-negotiation on the next
	  transaction.</p></li><li class="listitem"><p><span class="emphasis"><em>XPT_RESET_BUS</em></span> - send the RESET
	  signal to the SCSI bus</p><p>No arguments are passed in the CCB, the only interesting
	  argument is the SCSI bus indicated by the struct sim
	  pointer.</p><p>A minimalistic implementation would forget the SCSI
	  negotiations for all the devices on the bus and return the
	  status CAM_REQ_CMP.</p><p>The proper implementation would in addition actually
	  reset the SCSI bus (possible also reset the SCSI controller)
	  and mark all the CCBs being processed, both those in the
	  hardware queue and those being disconnected, as done with
	  the status CAM_SCSI_BUS_RESET. Like:</p><pre class="programlisting">    int targ, lun;
    struct xxx_hcb *h, *hh;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    /* The SCSI bus reset may take a long time, in this case its completion
     * should be checked by interrupt or timeout. But for simplicity
     * we assume here that it is really fast.
     */
    reset_scsi_bus(softc);

    /* drop all enqueued CCBs */
    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
        hh = h-&gt;next;
        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
    }

    /* the clean values of negotiations to report */
    neg.bus_width = 8;
    neg.sync_period = neg.sync_offset = 0;
    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

    /* drop all disconnected CCBs and clean negotiations  */
    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
        clean_negotiations(softc, targ);

        /* report the event if possible */
        if(xpt_create_path(&amp;path, /*periph*/NULL,
                cam_sim_path(sim), targ,
                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
            xpt_free_path(path);
        }

        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
            }
    }

    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);

    /* report the event */
    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);
    return;</pre><p>Implementing the SCSI bus reset as a function may be a
	  good idea because it would be re-used by the timeout
	  function as a last resort if the things go
	  wrong.</p></li><li class="listitem"><p><span class="emphasis"><em>XPT_ABORT</em></span> - abort the specified
	  CCB</p><p>The arguments are transferred in the instance
	  <span class="quote">&#8220;<span class="quote">struct ccb_abort cab</span>&#8221;</span> of the union ccb.  The
	  only argument field in it is:</p><p><span class="emphasis"><em>abort_ccb</em></span> - pointer to the CCB to
	  be aborted</p><p>If the abort is not supported just return the status
	  CAM_UA_ABORT.  This is also the easy way to minimally
	  implement this call, return CAM_UA_ABORT in any case.</p><p>The hard way is to implement this request honestly.
	  First check that abort applies to a SCSI transaction:</p><pre class="programlisting">    struct ccb *abort_ccb;
    abort_ccb = ccb-&gt;cab.abort_ccb;

    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
        ccb-&gt;ccb_h.status = CAM_UA_ABORT;
        xpt_done(ccb);
        return;
    }</pre><p>Then it is necessary to find this CCB in our queue.
	  This can be done by walking the list of all our hardware
	  control blocks in search for one associated with this
	  CCB:</p><pre class="programlisting">    struct xxx_hcb *hcb, *h;

    hcb = NULL;

    /* We assume that softc-&gt;first_hcb is the head of the list of all
     * HCBs associated with this bus, including those enqueued for
     * processing, being processed by hardware and disconnected ones.
     */
    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {
        if(h-&gt;ccb == abort_ccb) {
            hcb = h;
            break;
        }
    }

    if(hcb == NULL) {
        /* no such CCB in our queue */
        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        xpt_done(ccb);
        return;
    }

    hcb=found_hcb;</pre><p>Now we look at the current processing status of the HCB.
	  It may be either sitting in the queue waiting to be sent to
	  the SCSI bus, being transferred right now, or disconnected
	  and waiting for the result of the command, or actually
	  completed by hardware but not yet marked as done by
	  software.  To make sure that we do not get in any races with
	  hardware we mark the HCB as being aborted, so that if this
	  HCB is about to be sent to the SCSI bus the SCSI controller
	  will see this flag and skip it.</p><pre class="programlisting">    int hstatus;

    /* shown as a function, in case special action is needed to make
     * this flag visible to hardware
     */
    set_hcb_flags(hcb, HCB_BEING_ABORTED);

    abort_again:

    hstatus = get_hcb_status(hcb);
    switch(hstatus) {
    case HCB_SITTING_IN_QUEUE:
        remove_hcb_from_hardware_queue(hcb);
        /* FALLTHROUGH */
    case HCB_COMPLETED:
        /* this is an easy case */
        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);
        break;</pre><p>If the CCB is being transferred right now we would like
	  to signal to the SCSI controller in some hardware-dependent
	  way that we want to abort the current transfer.  The SCSI
	  controller would set the SCSI ATTENTION signal and when the
	  target responds to it send an ABORT message.  We also reset
	  the timeout to make sure that the target is not sleeping
	  forever.  If the command would not get aborted in some
	  reasonable time like 10 seconds the timeout routine would go
	  ahead and reset the whole SCSI bus.  Because the command
	  will be aborted in some reasonable time we can just return
	  the abort request now as successfully completed, and mark
	  the aborted CCB as aborted (but not mark it as done
	  yet).</p><pre class="programlisting">    case HCB_BEING_TRANSFERRED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;
        /* ask the controller to abort that HCB, then generate
         * an interrupt and stop
         */
        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {
            /* oops, we missed the race with hardware, this transaction
             * got off the bus before we aborted it, try again */
            goto abort_again;
        }

        break;</pre><p>If the CCB is in the list of disconnected then set it up
	  as an abort request and re-queue it at the front of hardware
	  queue.  Reset the timeout and report the abort request to be
	  completed.</p><pre class="programlisting">    case HCB_DISCONNECTED:
        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);
        abort_ccb-&gt;ccb_h.timeout_ch =
            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);
        put_abort_message_into_hcb(hcb);
        put_hcb_at_the_front_of_hardware_queue(hcb);
        break;
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre><p>That is all for the ABORT request, although there is one
	  more issue.  Because the ABORT message cleans all the
	  ongoing transactions on a LUN we have to mark all the other
	  active transactions on this LUN as aborted.  That should be
	  done in the interrupt routine, after the transaction gets
	  aborted.</p><p>Implementing the CCB abort as a function may be quite a
	  good idea, this function can be re-used if an I/O
	  transaction times out.  The only difference would be that
	  the timed out transaction would return the status
	  CAM_CMD_TIMEOUT for the timed out request.  Then the case
	  XPT_ABORT would be small, like that:</p><pre class="programlisting">    case XPT_ABORT:
        struct ccb *abort_ccb;
        abort_ccb = ccb-&gt;cab.abort_ccb;

        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {
            ccb-&gt;ccb_h.status = CAM_UA_ABORT;
            xpt_done(ccb);
            return;
        }
        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)
            /* no such CCB in our queue */
            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;
        else
            ccb-&gt;ccb_h.status = CAM_REQ_CMP;
        xpt_done(ccb);
        return;</pre></li><li class="listitem"><p><span class="emphasis"><em>XPT_SET_TRAN_SETTINGS</em></span> - explicitly
	  set values of SCSI transfer settings</p><p>The arguments are transferred in the instance
	  <span class="quote">&#8220;<span class="quote">struct ccb_trans_setting cts</span>&#8221;</span> of the union
	  ccb:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>valid</em></span> - a bitmask showing which
	      settings should be updated:</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_SYNC_RATE_VALID</em></span> -
	      synchronous transfer rate</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_SYNC_OFFSET_VALID</em></span> -
	      synchronous offset</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_BUS_WIDTH_VALID</em></span> - bus
	      width</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_DISC_VALID</em></span> - set
	      enable/disable disconnection</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_TQ_VALID</em></span> - set
	      enable/disable tagged queuing</p></li><li class="listitem"><p><span class="emphasis"><em>flags</em></span> - consists of two parts,
	      binary arguments and identification of sub-operations.
	      The binary arguments are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_DISC_ENB</em></span> - enable
		  disconnection</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_TAG_ENB</em></span> - enable
		  tagged queuing</p></li></ul></div></li><li class="listitem"><p>the sub-operations are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_CURRENT_SETTINGS</em></span>
		  - change the current negotiations</p></li><li class="listitem"><p><span class="emphasis"><em>CCB_TRANS_USER_SETTINGS</em></span> -
		  remember the desired user values sync_period,
		  sync_offset - self-explanatory, if sync_offset==0
		  then the asynchronous mode is requested bus_width -
		  bus width, in bits (not bytes)</p></li></ul></div></li></ul></div><p>Two sets of negotiated parameters are supported, the
	  user settings and the current settings.  The user settings
	  are not really used much in the SIM drivers, this is mostly
	  just a piece of memory where the upper levels can store (and
	  later recall) its ideas about the parameters.  Setting the
	  user parameters does not cause re-negotiation of the
	  transfer rates.  But when the SCSI controller does a
	  negotiation it must never set the values higher than the
	  user parameters, so it is essentially the top
	  boundary.</p><p>The current settings are, as the name says, current.
	  Changing them means that the parameters must be
	  re-negotiated on the next transfer.  Again, these
	  <span class="quote">&#8220;<span class="quote">new current settings</span>&#8221;</span> are not supposed to be
	  forced on the device, just they are used as the initial step
	  of negotiations.  Also they must be limited by actual
	  capabilities of the SCSI controller: for example, if the
	  SCSI controller has 8-bit bus and the request asks to set
	  16-bit wide transfers this parameter must be silently
	  truncated to 8-bit transfers before sending it to the
	  device.</p><p>One caveat is that the bus width and synchronous
	  parameters are per target while the disconnection and tag
	  enabling parameters are per lun.</p><p>The recommended implementation is to keep 3 sets of
	  negotiated (bus width and synchronous transfer)
	  parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>user</em></span> - the user set, as
	      above</p></li><li class="listitem"><p><span class="emphasis"><em>current</em></span> - those actually in
	      effect</p></li><li class="listitem"><p><span class="emphasis"><em>goal</em></span> - those requested by
	      setting of the <span class="quote">&#8220;<span class="quote">current</span>&#8221;</span>
	      parameters</p></li></ul></div><p>The code looks like:</p><pre class="programlisting">    struct ccb_trans_settings *cts;
    int targ, lun;
    int flags;

    cts = &amp;ccb-&gt;cts;
    targ = ccb_h-&gt;target_id;
    lun = ccb_h-&gt;target_lun;
    flags = cts-&gt;flags;
    if(flags &amp; CCB_TRANS_USER_SETTINGS) {
        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;
        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;
        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;

        if(flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if(flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {
        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)
            softc-&gt;goal_sync_period[targ] =
                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);
        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)
            softc-&gt;goal_sync_offset[targ] =
                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);
        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)
            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);

        if(flags &amp; CCB_TRANS_DISC_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;
        }
        if(flags &amp; CCB_TRANS_TQ_VALID) {
            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;
            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;
        }
    }
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre><p>Then when the next I/O request will be processed it will
	  check if it has to re-negotiate, for example by calling the
	  function target_negotiated(hcb).  It can be implemented like
	  this:</p><pre class="programlisting">    int
    target_negotiated(struct xxx_hcb *hcb)
    {
        struct softc *softc = hcb-&gt;softc;
        int targ = hcb-&gt;targ;

        if( softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]
        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]
        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ] )
            return 0; /* FALSE */
        else
            return 1; /* TRUE */
    }</pre><p>After the values are re-negotiated the resulting values
	  must be assigned to both current and goal parameters, so for
	  future I/O transactions the current and goal parameters
	  would be the same and
	  <code class="function">target_negotiated()</code> would return TRUE.
	  When the card is initialized (in
	  <code class="function">xxx_attach()</code>) the current negotiation
	  values must be initialized to narrow asynchronous mode, the
	  goal and current values must be initialized to the maximal
	  values supported by controller.</p><p><span class="emphasis"><em>XPT_GET_TRAN_SETTINGS</em></span> - get values
	  of SCSI transfer settings</p><p>This operations is the reverse of XPT_SET_TRAN_SETTINGS.
	  Fill up the CCB instance
	  <span class="quote">&#8220;<span class="quote">struct ccb_trans_setting cts</span>&#8221;</span> with data as
	  requested by the flags CCB_TRANS_CURRENT_SETTINGS or
	  CCB_TRANS_USER_SETTINGS (if both are set then the existing
	  drivers return the current settings).  Set all the bits in
	  the valid field.</p><p><span class="emphasis"><em>XPT_CALC_GEOMETRY</em></span> - calculate
	  logical (BIOS)<a id="idp55099128" class="indexterm"></a>
	  geometry of the disk</p><p>The arguments are transferred in the instance
	  <span class="quote">&#8220;<span class="quote">struct ccb_calc_geometry ccg</span>&#8221;</span> of the union
	  ccb:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="emphasis"><em>block_size</em></span> - input, block
	      (A.K.A sector) size in bytes</p></li><li class="listitem"><p><span class="emphasis"><em>volume_size</em></span> - input, volume
	      size in bytes</p></li><li class="listitem"><p><span class="emphasis"><em>cylinders</em></span> - output, logical
	      cylinders</p></li><li class="listitem"><p><span class="emphasis"><em>heads</em></span> - output, logical
	      heads</p></li><li class="listitem"><p><span class="emphasis"><em>secs_per_track</em></span> - output,
	      logical sectors per track</p></li></ul></div><p>If the returned geometry differs much enough from what
	  the SCSI controller BIOS<a id="idp55106296" class="indexterm"></a> thinks and a disk on
	  this SCSI controller is used as bootable the system may not
	  be able to boot.  The typical calculation example taken from
	  the aic7xxx driver is:</p><pre class="programlisting">    struct    ccb_calc_geometry *ccg;
    u_int32_t size_mb;
    u_int32_t secs_per_cylinder;
    int   extended;

    ccg = &amp;ccb-&gt;ccg;
    size_mb = ccg-&gt;volume_size
        / ((1024L * 1024L) / ccg-&gt;block_size);
    extended = check_cards_EEPROM_for_extended_geometry(softc);

    if (size_mb &gt; 1024 &amp;&amp; extended) {
        ccg-&gt;heads = 255;
        ccg-&gt;secs_per_track = 63;
    } else {
        ccg-&gt;heads = 64;
        ccg-&gt;secs_per_track = 32;
    }
    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;
    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;
    ccb-&gt;ccb_h.status = CAM_REQ_CMP;
    xpt_done(ccb);
    return;</pre><p>This gives the general idea, the exact calculation
	  depends on the quirks of the particular BIOS.  If BIOS
	  provides no way set the <span class="quote">&#8220;<span class="quote">extended translation</span>&#8221;</span>
	  flag in EEPROM this flag should normally be assumed equal to
	  1. Other popular geometries are:</p><pre class="programlisting">    128 heads, 63 sectors - Symbios controllers
    16 heads, 63 sectors - old controllers</pre><p>Some system BIOSes and SCSI BIOSes fight with each other
	  with variable success, for example a combination of Symbios
	  875/895 SCSI and Phoenix BIOS can give geometry 128/63 after
	  power up and 255/63 after a hard reset or soft
	  reboot.</p></li><li class="listitem"><p><span class="emphasis"><em>XPT_PATH_INQ</em></span> - path inquiry, in
	  other words get the SIM driver and SCSI controller (also
	  known as HBA - Host Bus Adapter) properties</p><p>The properties are returned in the instance
	  <span class="quote">&#8220;<span class="quote">struct ccb_pathinq cpi</span>&#8221;</span> of the union
	  ccb:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>version_num - the SIM driver version number, now all
	      drivers use 1</p></li><li class="listitem"><p>hba_inquiry - bitmask of features supported by the
	      controller:</p></li><li class="listitem"><p>PI_MDP_ABLE - supports MDP message (something from
	      SCSI3?)</p></li><li class="listitem"><p>PI_WIDE_32 - supports 32 bit wide
	      SCSI</p></li><li class="listitem"><p>PI_WIDE_16 - supports 16 bit wide
	      SCSI</p></li><li class="listitem"><p>PI_SDTR_ABLE - can negotiate synchronous transfer
	      rate</p></li><li class="listitem"><p>PI_LINKED_CDB - supports linked
	      commands</p></li><li class="listitem"><p>PI_TAG_ABLE - supports tagged
	      commands</p></li><li class="listitem"><p>PI_SOFT_RST - supports soft reset alternative (hard
	      reset and soft reset are mutually exclusive within a
	      SCSI bus)</p></li><li class="listitem"><p>target_sprt - flags for target mode support, 0 if
	      unsupported</p></li><li class="listitem"><p>hba_misc - miscellaneous controller
	      features:</p></li><li class="listitem"><p>PIM_SCANHILO - bus scans from high ID to low
	      ID</p></li><li class="listitem"><p>PIM_NOREMOVE - removable devices not included in
	      scan</p></li><li class="listitem"><p>PIM_NOINITIATOR - initiator role not
	      supported</p></li><li class="listitem"><p>PIM_NOBUSRESET - user has disabled initial BUS
	      RESET</p></li><li class="listitem"><p>hba_eng_cnt - mysterious HBA engine count, something
	      related to compression, now is always set to 0</p></li><li class="listitem"><p>vuhba_flags - vendor-unique flags, unused now</p></li><li class="listitem"><p>max_target - maximal supported target ID (7 for
	      8-bit bus, 15 for 16-bit bus, 127 for Fibre
	      Channel)</p></li><li class="listitem"><p>max_lun - maximal supported LUN ID (7 for older SCSI
	      controllers, 63 for newer ones)</p></li><li class="listitem"><p>async_flags - bitmask of installed Async handler,
	      unused now</p></li><li class="listitem"><p>hpath_id - highest Path ID in the subsystem, unused
	      now</p></li><li class="listitem"><p>unit_number - the controller unit number,
	      cam_sim_unit(sim)</p></li><li class="listitem"><p>bus_id - the bus number, cam_sim_bus(sim)</p></li><li class="listitem"><p>initiator_id - the SCSI ID of the controller
	      itself</p></li><li class="listitem"><p>base_transfer_speed - nominal transfer speed in KB/s
	      for asynchronous narrow transfers, equals to 3300 for
	      SCSI</p></li><li class="listitem"><p>sim_vid - SIM driver's vendor id, a zero-terminated
	      string of maximal length SIM_IDLEN including the
	      terminating zero</p></li><li class="listitem"><p>hba_vid - SCSI controller's vendor id, a
	      zero-terminated string of maximal length HBA_IDLEN
	      including the terminating zero</p></li><li class="listitem"><p>dev_name - device driver name, a zero-terminated
	      string of maximal length DEV_IDLEN including the
	      terminating zero, equal to cam_sim_name(sim)</p></li></ul></div><p>The recommended way of setting the string fields is
	  using strncpy, like:</p><pre class="programlisting">    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);</pre><p>After setting the values set the status to CAM_REQ_CMP
	  and mark the CCB as done.</p></li></ul></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-polling"></a>12.3. Polling</h2></div></div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">static void
	  <strong class="fsfunc">xxx_poll</strong>
	(</code></td><td><var class="pdparam">struct cam_sim *sim</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>
	  <var class="pdparam">struct cam_sim *sim</var>
	</code>;</div><div class="funcprototype-spacer"> </div></div><p>The poll function is used to simulate the interrupts when
      the interrupt subsystem is not functioning (for example, when
      the system has crashed and is creating the system dump).  The
      CAM subsystem sets the proper interrupt level before calling the
      poll routine.  So all it needs to do is to call the interrupt
      routine (or the other way around, the poll routine may be doing
      the real action and the interrupt routine would just call the
      poll routine).  Why bother about a separate function then?
      Because of different calling conventions.  The
      <code class="function">xxx_poll</code> routine gets the struct cam_sim
      pointer as its argument when the PCI interrupt routine by common
      convention gets pointer to the struct
      <code class="varname">xxx_softc</code> and the ISA interrupt routine
      gets just the device unit number.  So the poll routine would
      normally look as:</p><pre class="programlisting">static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */
}</pre><p>or</p><pre class="programlisting">static void
xxx_poll(struct cam_sim *sim)
{
    xxx_intr(cam_sim_unit(sim)); /* for ISA device */
}</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-async"></a>12.4. Asynchronous Events</h2></div></div></div><p>If an asynchronous event callback has been set up then the
      callback function should be defined.</p><pre class="programlisting">static void
ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>callback_arg - the value supplied when registering the
	  callback</p></li><li class="listitem"><p>code - identifies the type of event</p></li><li class="listitem"><p>path - identifies the devices to which the event
	  applies</p></li><li class="listitem"><p>arg - event-specific argument</p></li></ul></div><p>Implementation for a single type of event, AC_LOST_DEVICE,
      looks like:</p><pre class="programlisting">    struct xxx_softc *softc;
    struct cam_sim *sim;
    int targ;
    struct ccb_trans_settings neg;

    sim = (struct cam_sim *)callback_arg;
    softc = (struct xxx_softc *)cam_sim_softc(sim);
    switch (code) {
    case AC_LOST_DEVICE:
        targ = xpt_path_target_id(path);
        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {
            clean_negotiations(softc, targ);
            /* send indication to CAM */
            neg.bus_width = 8;
            neg.sync_period = neg.sync_offset = 0;
            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);
            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
        }
        break;
    default:
        break;
    }</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-interrupts"></a>12.5. Interrupts</h2></div></div></div><a id="idp55196536" class="indexterm"></a><p>The exact type of the interrupt routine depends on the type
      of the peripheral bus (PCI, ISA and so on) to which the SCSI
      controller is connected.</p><p>The interrupt routines of the SIM drivers run at the
      interrupt level splcam.  So <code class="function">splcam()</code> should
      be used in the driver to synchronize activity between the
      interrupt routine and the rest of the driver (for a
      multiprocessor-aware driver things get yet more interesting but
      we ignore this case here).  The pseudo-code in this document
      happily ignores the problems of synchronization.  The real code
      must not ignore them.  A simple-minded approach is to set
      <code class="function">splcam()</code> on the entry to the other routines
      and reset it on return thus protecting them by one big critical
      section.  To make sure that the interrupt level will be always
      restored a wrapper function can be defined, like:</p><pre class="programlisting">    static void
    xxx_action(struct cam_sim *sim, union ccb *ccb)
    {
        int s;
        s = splcam();
        xxx_action1(sim, ccb);
        splx(s);
    }

    static void
    xxx_action1(struct cam_sim *sim, union ccb *ccb)
    {
        ... process the request ...
    }</pre><p>This approach is simple and robust but the problem with it
      is that interrupts may get blocked for a relatively long time
      and this would negatively affect the system's performance.  On
      the other hand the functions of the <code class="function">spl()</code>
      family have rather high overhead, so vast amount of tiny
      critical sections may not be good either.</p><p>The conditions handled by the interrupt routine and the
      details depend very much on the hardware.  We consider the set
      of <span class="quote">&#8220;<span class="quote">typical</span>&#8221;</span> conditions.</p><p>First, we check if a SCSI reset was encountered on the bus
      (probably caused by another SCSI controller on the same SCSI
      bus).  If so we drop all the enqueued and disconnected requests,
      report the events and re-initialize our SCSI controller.  It is
      important that during this initialization the controller will
      not issue another reset or else two controllers on the same SCSI
      bus could ping-pong resets forever.  The case of fatal
      controller error/hang could be handled in the same place, but it
      will probably need also sending RESET signal to the SCSI bus to
      reset the status of the connections with the SCSI
      devices.</p><pre class="programlisting">    int fatal=0;
    struct ccb_trans_settings neg;
    struct cam_path *path;

    if( detected_scsi_reset(softc)
    || (fatal = detected_fatal_controller_error(softc)) ) {
        int targ, lun;
        struct xxx_hcb *h, *hh;

        /* drop all enqueued CCBs */
        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;
            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
        }

        /* the clean values of negotiations to report */
        neg.bus_width = 8;
        neg.sync_period = neg.sync_offset = 0;
        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID
            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);

        /* drop all disconnected CCBs and clean negotiations  */
        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {
            clean_negotiations(softc, targ);

            /* report the event if possible */
            if(xpt_create_path(&amp;path, /*periph*/NULL,
                    cam_sim_path(sim), targ,
                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {
                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);
                xpt_free_path(path);
            }

            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {
                    hh=h-&gt;next;
                    if(fatal)
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);
                    else
                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }
        }

        /* report the event */
        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);

        /* re-initialization may take a lot of time, in such case
         * its completion should be signaled by another interrupt or
         * checked on timeout - but for simplicity we assume here that
         * it is really fast
         */
        if(!fatal) {
            reinitialize_controller_without_scsi_reset(softc);
        } else {
            reinitialize_controller_with_scsi_reset(softc);
        }
        schedule_next_hcb(softc);
        return;
    }</pre><p>If interrupt is not caused by a controller-wide condition
      then probably something has happened to the current hardware
      control block.  Depending on the hardware there may be other
      non-HCB-related events, we just do not consider them here.  Then
      we analyze what happened to this HCB:</p><pre class="programlisting">    struct xxx_hcb *hcb, *h, *hh;
    int hcb_status, scsi_status;
    int ccb_status;
    int targ;
    int lun_to_freeze;

    hcb = get_current_hcb(softc);
    if(hcb == NULL) {
        /* either stray interrupt or something went very wrong
         * or this is something hardware-dependent
         */
        handle as necessary;
        return;
    }

    targ = hcb-&gt;target;
    hcb_status = get_status_of_current_hcb(softc);</pre><p>First we check if the HCB has completed and if so we check
      the returned SCSI status.</p><pre class="programlisting">    if(hcb_status == COMPLETED) {
        scsi_status = get_completion_status(hcb);</pre><p>Then look if this status is related to the REQUEST SENSE
      command and if so handle it in a simple way.</p><pre class="programlisting">        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {
            if(scsi_status == GOOD) { /* autosense was successful */
                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
            } else {
        autosense_failed:
                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);
            }
            schedule_next_hcb(softc);
            return;
        }</pre><p>Else the command itself has completed, pay more attention to
      details.  If auto-sense is not disabled for this CCB and the
      command has failed with sense data then run REQUEST SENSE
      command to receive that data.</p><pre class="programlisting">        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;
        calculate_residue(hcb);

        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0
        &amp;&amp; ( scsi_status == CHECK_CONDITION
                || scsi_status == COMMAND_TERMINATED) ) {
            /* start auto-SENSE */
            hcb-&gt;flags |= DOING_AUTOSENSE;
            setup_autosense_command_in_hcb(hcb);
            restart_current_hcb(softc);
            return;
        }
        if(scsi_status == GOOD)
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);
        else
            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);
        schedule_next_hcb(softc);
        return;
    }</pre><p>One typical thing would be negotiation events: negotiation
      messages received from a SCSI target (in answer to our
      negotiation attempt or by target's initiative) or the target is
      unable to negotiate (rejects our negotiation messages or does
      not answer them).</p><pre class="programlisting">    switch(hcb_status) {
    case TARGET_REJECTED_WIDE_NEG:
        /* revert to 8-bit bus */
        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;
        /* report the event */
        neg.bus_width = 8;
        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
        continue_current_hcb(softc);
        return;
    case TARGET_ANSWERED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {
                /* answer is acceptable */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            } else {
                prepare_reject_message(hcb);
            }
        }
        continue_current_hcb(softc);
        return;
    case TARGET_REQUESTED_WIDE_NEG:
        {
            int wd;

            wd = get_target_bus_width_request(softc);
            wd = min (wd, OUR_BUS_WIDTH);
            wd = min (wd, softc-&gt;user_bus_width[targ]);

            if(wd != softc-&gt;current_bus_width[targ]) {
                /* the bus width has changed */
                softc-&gt;current_bus_width[targ] =
                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;

                /* report the event */
                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;
                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);
            }
            prepare_width_nego_rsponse(hcb, wd);
        }
        continue_current_hcb(softc);
        return;
    }</pre><p>Then we handle any errors that could have happened during
      auto-sense in the same simple-minded way as before.  Otherwise
      we look closer at the details again.</p><pre class="programlisting">    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)
        goto autosense_failed;

    switch(hcb_status) {</pre><p>The next event we consider is unexpected disconnect.  Which
      is considered normal after an ABORT or BUS DEVICE RESET message
      and abnormal in other cases.</p><pre class="programlisting">    case UNEXPECTED_DISCONNECT:
        if(requested_abort(hcb)) {
            /* abort affects all commands on that target+LUN, so
             * mark all disconnected HCBs on that target+LUN as aborted too
             */
            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];
                    h != NULL; h = hh) {
                hh=h-&gt;next;
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);
            }
            ccb_status = CAM_REQ_ABORTED;
        } else if(requested_bus_device_reset(hcb)) {
            int lun;

            /* reset affects all commands on that target, so
             * mark all disconnected HCBs on that target+LUN as reset
             */

            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)
                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];
                        h != NULL; h = hh) {
                    hh=h-&gt;next;
                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);
                }

            /* send event */
            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);

            /* this was the CAM_RESET_DEV request itself, it is completed */
            ccb_status = CAM_REQ_CMP;
        } else {
            calculate_residue(hcb);
            ccb_status = CAM_UNEXP_BUSFREE;
            /* request the further code to freeze the queue */
            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
            lun_to_freeze = hcb-&gt;lun;
        }
        break;</pre><p>If the target refuses to accept tags we notify CAM about
      that and return back all commands for this LUN:</p><pre class="programlisting">    case TAGS_REJECTED:
        /* report the event */
        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;
        neg.valid = CCB_TRANS_TQ_VALID;
        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);

        ccb_status = CAM_MSG_REJECT_REC;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = hcb-&gt;lun;
        break;</pre><p>Then we check a number of other conditions, with processing
      basically limited to setting the CCB status:</p><pre class="programlisting">    case SELECTION_TIMEOUT:
        ccb_status = CAM_SEL_TIMEOUT;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    case PARITY_ERROR:
        ccb_status = CAM_UNCOR_PARITY;
        break;
    case DATA_OVERRUN:
    case ODD_WIDE_TRANSFER:
        ccb_status = CAM_DATA_RUN_ERR;
        break;
    default:
        /* all other errors are handled in a generic way */
        ccb_status = CAM_REQ_CMP_ERR;
        /* request the further code to freeze the queue */
        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;
        lun_to_freeze = CAM_LUN_WILDCARD;
        break;
    }</pre><p>Then we check if the error was serious enough to freeze the
      input queue until it gets proceeded and do so if it is:</p><pre class="programlisting">    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {
        /* freeze the queue */
        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);

        /* re-queue all commands for this target/LUN back to CAM */

        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {
            hh = h-&gt;next;

            if(targ == h-&gt;targ
            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun) )
                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);
        }
    }
    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);
    schedule_next_hcb(softc);
    return;</pre><p>This concludes the generic interrupt handling although
      specific controllers may require some additions.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-errors"></a>12.6. Errors Summary</h2></div></div></div><a id="idp55247480" class="indexterm"></a><p>When executing an I/O request many things may go wrong.  The
      reason of error can be reported in the CCB status with great
      detail.  Examples of use are spread throughout this document.
      For completeness here is the summary of recommended responses
      for the typical error conditions:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>CAM_RESRC_UNAVAIL</em></span> - some resource
	  is temporarily unavailable and the SIM driver cannot
	  generate an event when it will become available.  An example
	  of this resource would be some intra-controller hardware
	  resource for which the controller does not generate an
	  interrupt when it becomes available.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_UNCOR_PARITY</em></span> - unrecovered
	  parity error occurred</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_DATA_RUN_ERR</em></span> - data overrun or
	  unexpected data phase (going in other direction than
	  specified in CAM_DIR_MASK) or odd transfer length for wide
	  transfer</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_SEL_TIMEOUT</em></span> - selection timeout
	  occurred (target does not respond)</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_CMD_TIMEOUT</em></span> - command timeout
	  occurred (the timeout function ran)</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_SCSI_STATUS_ERROR</em></span> - the device
	  returned error</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_AUTOSENSE_FAIL</em></span> - the device
	  returned error and the REQUEST SENSE COMMAND failed</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_MSG_REJECT_REC</em></span> - MESSAGE REJECT
	  message was received</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_SCSI_BUS_RESET</em></span> - received SCSI
	  bus reset</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_REQ_CMP_ERR</em></span> -
	  <span class="quote">&#8220;<span class="quote">impossible</span>&#8221;</span> SCSI phase occurred or something
	  else as weird or just a generic error if further detail is
	  not available</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_UNEXP_BUSFREE</em></span> - unexpected
	  disconnect occurred</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_BDR_SENT</em></span> - BUS DEVICE RESET
	  message was sent to the target</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_UNREC_HBA_ERROR</em></span> - unrecoverable
	  Host Bus Adapter Error</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_REQ_TOO_BIG</em></span> - the request was
	  too large for this controller</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_REQUEUE_REQ</em></span> - this request
	  should be re-queued to preserve transaction ordering.  This
	  typically occurs when the SIM recognizes an error that
	  should freeze the queue and must place other queued requests
	  for the target at the sim level back into the XPT queue.
	  Typical cases of such errors are selection timeouts, command
	  timeouts and other like conditions.  In such cases the
	  troublesome command returns the status indicating the error,
	  the and the other commands which have not be sent to the bus
	  yet get re-queued.</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_LUN_INVALID</em></span> - the LUN ID in the
	  request is not supported by the SCSI controller</p></li><li class="listitem"><p><span class="emphasis"><em>CAM_TID_INVALID</em></span> - the target ID in
	  the request is not supported by the SCSI controller</p></li></ul></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="scsi-timeout"></a>12.7. Timeout Handling</h2></div></div></div><p>When the timeout for an HCB expires that request should be
      aborted, just like with an XPT_ABORT request.  The only
      difference is that the returned status of aborted request should
      be CAM_CMD_TIMEOUT instead of CAM_REQ_ABORTED (that is why
      implementation of the abort better be done as a function).  But
      there is one more possible problem: what if the abort request
      itself will get stuck? In this case the SCSI bus should be
      reset, just like with an XPT_RESET_BUS request (and the idea
      about implementing it as a function called from both places
      applies here too).  Also we should reset the whole SCSI bus if a
      device reset request got stuck.  So after all the timeout
      function would look like:</p><pre class="programlisting">static void
xxx_timeout(void *arg)
{
    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;
    struct xxx_softc *softc;
    struct ccb_hdr *ccb_h;

    softc = hcb-&gt;softc;
    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;

    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED
    || ccb_h-&gt;func_code == XPT_RESET_DEV) {
        xxx_reset_bus(softc);
    } else {
        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);
    }
}</pre><p>When we abort a request all the other disconnected requests
      to the same target/LUN get aborted too.  So there appears a
      question, should we return them with status CAM_REQ_ABORTED or
      CAM_CMD_TIMEOUT?  The current drivers use CAM_CMD_TIMEOUT. This
      seems logical because if one request got timed out then probably
      something really bad is happening to the device, so if they
      would not be disturbed they would time out by themselves.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="usb"></a>Chapter 13. USB Devices</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Nick</span> <span class="surname">Hibma</span></span>. </span></div><div><span class="authorgroup">Modifications for Handbook made by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Murray</span> <span class="surname">Stokely</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#usb-intro">13.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#usb-hc">13.2. Host Controllers</a></span></dt><dt><span class="sect1"><a href="#usb-dev">13.3. USB Device Information</a></span></dt><dt><span class="sect1"><a href="#usb-devprobe">13.4. Device Probe and Attach</a></span></dt><dt><span class="sect1"><a href="#usb-protocol">13.5. USB Drivers Protocol Information</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="usb-intro"></a>13.1. Introduction</h2></div></div></div><a id="idp55288440" class="indexterm"></a><a id="idp55288952" class="indexterm"></a><p>The Universal Serial Bus (USB) is a new way of attaching
      devices to personal computers.  The bus architecture features
      two-way communication and has been developed as a response to
      devices becoming smarter and requiring more interaction with the
      host.  USB support is included in all current PC chipsets and is
      therefore available in all recently built PCs.  Apple's
      introduction of the USB-only iMac has been a major incentive for
      hardware manufacturers to produce USB versions of their devices.
      The future PC specifications specify that all legacy connectors
      on PCs should be replaced by one or more USB connectors,
      providing generic plug and play capabilities.  Support for USB
      hardware was available at a very early stage in NetBSD and was
      developed by Lennart Augustsson for the NetBSD project.  The
      code has been ported to FreeBSD and we are currently maintaining
      a shared code base.  For the implementation of the USB subsystem
      a number of features of USB are important.</p><p><span class="emphasis"><em>Lennart Augustsson has done most of the
	implementation of the USB support for the NetBSD project.
	Many thanks for this incredible amount of work.  Many thanks
	also to Ardy and Dirk for their comments and proofreading of
	this paper.</em></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Devices connect to ports on the computer directly or on
	  devices called hubs, forming a treelike device
	  structure.</p></li><li class="listitem"><p>The devices can be connected and disconnected at run
	  time.</p></li><li class="listitem"><p>Devices can suspend themselves and trigger resumes of
	  the host system</p></li><li class="listitem"><p>As the devices can be powered from the bus, the host
	  software has to keep track of power budgets for each
	  hub.</p></li><li class="listitem"><p>Different quality of service requirements by the
	  different device types together with the maximum of 126
	  devices that can be connected to the same bus, require
	  proper scheduling of transfers on the shared bus to take
	  full advantage of the 12Mbps bandwidth available.  (over
	  400Mbps with USB 2.0)</p></li><li class="listitem"><p>Devices are intelligent and contain easily accessible
	  information about themselves</p></li></ul></div><p>The development of drivers for the USB subsystem and devices
      connected to it is supported by the specifications that have
      been developed and will be developed.  These specifications are
      publicly available from the USB home pages.  Apple has been very
      strong in pushing for standards based drivers, by making drivers
      for the generic classes available in their operating system
      MacOS and discouraging the use of separate drivers for each new
      device.  This chapter tries to collate essential information for
      a basic understanding of the USB 2.0 implementation stack in
      FreeBSD/NetBSD.  It is recommended however to read it together
      with the relevant 2.0 specifications and other developer
      resources:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>USB 2.0 Specification (<a class="link" href="http://www.usb.org/developers/docs/usb20_docs/" target="_top">http://www.usb.org/developers/docs/usb20_docs/</a>)</p></li><li class="listitem"><p>Universal Host Controller Interface
	  (<acronym class="acronym">UHCI</acronym>) Specification (<a class="link" href="ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf" target="_top">ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</a></p></li><li class="listitem"><p>Open Host Controller Interface (<acronym class="acronym">OHCI</acronym>)
	  Specification(<a class="link" href="ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf" target="_top">ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</a>)</p></li><li class="listitem"><p>Developer section of <acronym class="acronym">USB</acronym> home page
	  (<a class="link" href="http://www.usb.org/developers/" target="_top">http://www.usb.org/developers/</a>)</p></li></ul></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55318904"></a>13.1.1. Structure of the USB Stack</h3></div></div></div><p>The USB support in FreeBSD can be split into three layers.
	The lowest layer contains the host controller driver,
	providing a generic interface to the hardware and its
	scheduling facilities.  It supports initialisation of the
	hardware, scheduling of transfers and handling of completed
	and/or failed transfers.  Each host controller driver
	implements a virtual hub providing hardware independent access
	to the registers controlling the root ports on the back of the
	machine.</p><p>The middle layer handles the device connection and
	disconnection, basic initialisation of the device, driver
	selection, the communication channels (pipes) and does
	resource management.  This services layer also controls the
	default pipes and the device requests transferred over
	them.</p><p>The top layer contains the individual drivers supporting
	specific (classes of) devices.  These drivers implement the
	protocol that is used over the pipes other than the default
	pipe.  They also implement additional functionality to make
	the device available to other parts of the kernel or userland.
	They use the USB driver interface (USBDI) exposed by the
	services layer.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="usb-hc"></a>13.2. Host Controllers</h2></div></div></div><a id="idp55321720" class="indexterm"></a><p>The host controller (HC) controls the transmission of
      packets on the bus.  Frames of 1 millisecond are used.  At the
      start of each frame the host controller generates a Start of
      Frame (SOF) packet.</p><p>The SOF packet is used to synchronise to the start of the
      frame and to keep track of the frame number.  Within each frame
      packets are transferred, either from host to device (out) or
      from device to host (in).  Transfers are always initiated by the
      host (polled transfers).  Therefore there can only be one host
      per USB bus.  Each transfer of a packet has a status stage in
      which the recipient of the data can return either ACK
      (acknowledge reception), NAK (retry), STALL (error condition) or
      nothing (garbled data stage, device not available or
      disconnected).  Section 8.5 of the USB 2.0 Specification
      explains the details of packets in more detail.  Four different
      types of transfers can occur on a USB bus: control, bulk,
      interrupt and isochronous.  The types of transfers and their
      characteristics are described below.</p><p>Large transfers between the device on the USB bus and the
      device driver are split up into multiple packets by the host
      controller or the HC driver.</p><p>Device requests (control transfers) to the default endpoints
      are special.  They consist of two or three phases: SETUP, DATA
      (optional) and STATUS. The set-up packet is sent to the device.
      If there is a data phase, the direction of the data packet(s) is
      given in the set-up packet.  The direction in the status phase
      is the opposite of the direction during the data phase, or IN if
      there was no data phase.  The host controller hardware also
      provides registers with the current status of the root ports and
      the changes that have occurred since the last reset of the
      status change register.  Access to these registers is provided
      through a virtualised hub as suggested in the USB specification.
      The virtual hub must comply with the hub device class given in
      chapter 11 of that specification.  It must provide a default
      pipe through which device requests can be sent to it.  It
      returns the standard andhub class specific set of descriptors.
      It should also provide an interrupt pipe that reports changes
      happening at its ports.  There are currently two specifications
      for host controllers available: Universal Host Controller
      Interface (<acronym class="acronym">UHCI</acronym>) from Intel and Open Host
      Controller Interface (<acronym class="acronym">OHCI</acronym>) from Compaq,
      Microsoft, and National Semiconductor.  The
      <acronym class="acronym">UHCI</acronym> specification has been designed to
      reduce hardware complexity by requiring the host controller
      driver to supply a complete schedule of the transfers for each
      frame.  OHCI type controllers are much more independent by
      providing a more abstract interface doing a lot of work
      themselves.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55325176"></a>13.2.1. UHCI</h3></div></div></div><a id="idp55325816" class="indexterm"></a><p>The UHCI host controller maintains a framelist with 1024
	pointers to per frame data structures.  It understands two
	different data types: transfer descriptors (TD) and queue
	heads (QH).  Each TD represents a packet to be communicated to
	or from a device endpoint.  QHs are a means to groupTDs (and
	QHs) together.</p><p>Each transfer consists of one or more packets.  The UHCI
	driver splits large transfers into multiple packets.  For
	every transfer, apart from isochronous transfers, a QH is
	allocated.  For every type of transfer these QHs are collected
	at a QH for that type.  Isochronous transfers have to be
	executed first because of the fixed latency requirement and
	are directly referred to by the pointer in the framelist.  The
	last isochronous TD refers to the QH for interrupt transfers
	for that frame.  All QHs for interrupt transfers point at the
	QH for control transfers, which in turn points at the QH for
	bulk transfers.  The following diagram gives a graphical
	overview of this:</p><p>This results in the following schedule being run in each
	frame.  After fetching the pointer for the current frame from
	the framelist the controller first executes the TDs for all
	the isochronous packets in that frame.  The last of these TDs
	refers to the QH for the interrupt transfers for thatframe.
	The host controller will then descend from that QH to the QHs
	for the individual interrupt transfers.  After finishing that
	queue, the QH for the interrupt transfers will refer the
	controller to the QH for all control transfers.  It will
	execute all the subqueues scheduled there, followed by all the
	transfers queued at the bulk QH.  To facilitate the handling
	of finished or failed transfers different types of interrupts
	are generated by the hardware at the end of each frame.  In
	the last TD for a transfer the Interrupt-On Completion bit is
	set by the HC driver to flag an interrupt when the transfer
	has completed.  An error interrupt is flagged if a TD reaches
	its maximum error count.  If the short packet detect bit is
	set in a TD and less than the set packet length is transferred
	this interrupt is flagged to notify the controller driver of
	the completed transfer.  It is the host controller driver's
	task to find out which transfer has completed or produced an
	error.  When called the interrupt service routine will locate
	all the finished transfers and call their callbacks.</p><p>Refer to the <acronym class="acronym">UHCI</acronym> Specification for a
	more elaborate description.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55042296"></a>13.2.2. OHCI</h3></div></div></div><a id="idp55042936" class="indexterm"></a><p>Programming an OHCI host controller is much simpler.  The
	controller assumes that a set of endpoints is available, and
	is aware of scheduling priorities and the ordering of the
	types of transfers in a frame.  The main data structure used
	by the host controller is the endpoint descriptor (ED) to
	which a queue of transfer descriptors (TDs) is attached.  The
	ED contains the maximum packet size allowed for an endpoint
	and the controller hardware does the splitting into packets.
	The pointers to the data buffers are updated after each
	transfer and when the start and end pointer are equal, the TD
	is retired to the done-queue.  The four types of endpoints
	(interrupt, isochronous, control, and bulk) have their own
	queues.  Control and bulk endpoints are queued each at their
	own queue.  Interrupt EDs are queued in a tree, with the level
	in the tree defining the frequency at which they run.</p><p>The schedule being run by the host controller in each
	frame looks as follows.  The controller will first run the
	non-periodic control and bulk queues, up to a time limit set
	by the HC driver.  Then the interrupt transfers for that frame
	number are run, by using the lower five bits of the frame
	number as an index into level 0 of the tree of interrupts EDs.
	At the end of this tree the isochronous EDs are connected and
	these are traversed subsequently.  The isochronous TDs contain
	the frame number of the first frame the transfer should be run
	in.  After all the periodic transfers have been run, the
	control and bulk queues are traversed again.  Periodically the
	interrupt service routine is called to process the done queue
	and call the callbacks for each transfer and reschedule
	interrupt and isochronous endpoints.</p><p>See the <acronym class="acronym">UHCI</acronym> Specification for a more
	elaborate description.  The middle layer provides access to
	the device in a controlled way and maintains resources in use
	by the different drivers and the services layer.  The layer
	takes care of the following aspects:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The device configuration information</p></li><li class="listitem"><p>The pipes to communicate with a device</p></li><li class="listitem"><p>Probing and attaching and detaching form a
	    device.</p></li></ul></div></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="usb-dev"></a>13.3. USB Device Information</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55037048"></a>13.3.1. Device Configuration Information</h3></div></div></div><p>Each device provides different levels of configuration
	information.  Each device has one or more configurations, of
	which one is selected during probe/attach.  A configuration
	provides power and bandwidth requirements.  Within each
	configuration there can be multiple interfaces.  A device
	interface is a collection of endpoints.  For example USB
	speakers can have an interface for the audio data (Audio
	Class) and an interface for the knobs, dials and buttons (HID
	Class).  All interfaces in a configuration are active at the
	same time and can be attached to by different drivers.  Each
	interface can have alternates, providing different quality of
	service parameters.  In for example cameras this is used to
	provide different frame sizes and numbers of frames per
	second.</p><p>Within each interface, 0 or more endpoints can be
	specified.  Endpoints are the unidirectional access points for
	communicating with a device.  They provide buffers to
	temporarily store incoming or outgoing data from the device.
	Each endpoint has a unique address within a configuration, the
	endpoint's number plus its direction.  The default endpoint,
	endpoint 0, is not part of any interface and available in all
	configurations.  It is managed by the services layer and not
	directly available to device drivers.</p><p>This hierarchical configuration information is described
	in the device by a standard set of descriptors (see section
	9.6 of the USB specification).  They can be requested through
	the Get Descriptor Request.  The services layer caches these
	descriptors to avoid unnecessary transfers on the USB bus.
	Access to the descriptors is provided through function
	calls.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Device descriptors: General information about the
	    device, like Vendor, Product and Revision Id, supported
	    device class, subclass and protocol if applicable, maximum
	    packet size for the default endpoint, etc.</p></li><li class="listitem"><p>Configuration descriptors: The number of interfaces in
	    this configuration, suspend and resume functionality
	    supported and power requirements.</p></li><li class="listitem"><p>Interface descriptors: interface class, subclass and
	    protocol if applicable, number of alternate settings for
	    the interface and the number of endpoints.</p></li><li class="listitem"><p>Endpoint descriptors: Endpoint address, direction and
	    type, maximum packet size supported and polling frequency
	    if type is interrupt endpoint.  There is no descriptor for
	    the default endpoint (endpoint 0) and it is never counted
	    in an interface descriptor.</p></li><li class="listitem"><p>String descriptors: In the other descriptors string
	    indices are supplied for some fields.These can be used to
	    retrieve descriptive strings, possibly in multiple
	    languages.</p></li></ul></div><p>Class specifications can add their own descriptor types
	that are available through the GetDescriptor Request.</p><p>Pipes Communication to end points on a device flows
	through so-called pipes.  Drivers submit transfers to
	endpoints to a pipe and provide a callback to be called on
	completion or failure of the transfer (asynchronous transfers)
	or wait for completion (synchronous transfer).  Transfers to
	an endpoint are serialised in the pipe.  A transfer can either
	complete, fail or time-out (if a time-out has been set).
	There are two types of time-outs for transfers.  Time-outs can
	happen due to time-out on the USBbus (milliseconds).  These
	time-outs are seen as failures and can be due to disconnection
	of the device.  A second form of time-out is implemented in
	software and is triggered when a transfer does not complete
	within a specified amount of time (seconds).  These are caused
	by a device acknowledging negatively (NAK) the transferred
	packets.  The cause for this is the device not being ready to
	receive data, buffer under- or overrun or protocol
	errors.</p><p>If a transfer over a pipe is larger than the maximum
	packet size specified in the associated endpoint descriptor,
	the host controller (OHCI) or the HC driver (UHCI) will split
	the transfer into packets of maximum packet size, with the
	last packet possibly smaller than the maximum packet
	size.</p><p>Sometimes it is not a problem for a device to return less
	data than requested.  For example abulk-in-transfer to a modem
	might request 200 bytes of data, but the modem has only 5
	bytes available at that time.  The driver can set the short
	packet (SPD) flag.  It allows the host controller to accept a
	packet even if the amount of data transferred is less than
	requested.  This flag is only valid for in-transfers, as the
	amount of data to be sent to a device is always known
	beforehand.  If an unrecoverable error occurs in a device
	during a transfer the pipe is stalled.  Before any more data
	is accepted or sent the driver needs to resolve the cause of
	the stall and clear the endpoint stall condition through send
	the clear endpoint halt device request over the default pipe.
	The default endpoint should never stall.</p><p>There are four different types of endpoints and
	corresponding pipes: - Control pipe / default pipe: There is
	one control pipe per device, connected to the default endpoint
	(endpoint 0).  The pipe carries the device requests and
	associated data.  The difference between transfers over the
	default pipe and other pipes is that the protocol for the
	transfers is described in the USB specification.  These
	requests are used to reset and configure the device.  A basic
	set of commands that must be supported by each device is
	provided in chapter 9 of the USB specification.  The commands
	supported on this pipe can be extended by a device class
	specification to support additional functionality.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Bulk pipe: This is the USB equivalent to a raw
	    transmission medium.</p></li><li class="listitem"><p>Interrupt pipe: The host sends a request for data to
	    the device and if the device has nothing to send, it will
	    NAK the data packet.  Interrupt transfers are scheduled at
	    a frequency specified when creating the
	    pipe.</p></li><li class="listitem"><p>Isochronous pipe: These pipes are intended for
	    isochronous data, for example video or audio streams, with
	    fixed latency, but no guaranteed delivery.  Some support
	    for pipes of this type is available in the current
	    implementation.  Packets in control, bulk and interrupt
	    transfers are retried if an error occurs during
	    transmission or the device acknowledges the packet
	    negatively (NAK) due to for example lack of buffer space
	    to store the incoming data.  Isochronous packets are
	    however not retried in case of failed delivery or NAK of a
	    packet as this might violate the timing
	    constraints.</p></li></ul></div><p>The availability of the necessary bandwidth is calculated
	during the creation of the pipe.  Transfers are scheduled
	within frames of 1 millisecond.  The bandwidth allocation
	within a frame is prescribed by the USB specification, section
	5.6 [ 2].  Isochronous and interrupt transfers are allowed to
	consume up to 90% of the bandwidth within a frame.  Packets
	for control and bulk transfers are scheduled after all
	isochronous and interrupt packets and will consume all the
	remaining bandwidth.</p><p>More information on scheduling of transfers and bandwidth
	reclamation can be found in chapter 5 of the USB
	specification, section 1.3 of the UHCI specification, and
	section 3.4.2 of the OHCI specification.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="usb-devprobe"></a>13.4. Device Probe and Attach</h2></div></div></div><a id="idp54865400" class="indexterm"></a><p>After the notification by the hub that a new device has been
      connected, the service layer switches on the port, providing the
      device with 100 mA of current.  At this point the device is in
      its default state and listening to device address 0.  The
      services layer will proceed to retrieve the various descriptors
      through the default pipe.  After that it will send a Set Address
      request to move the device away from the default device address
      (address 0).  Multiple device drivers might be able to support
      the device.  For example a modem driver might be able to support
      an ISDN TA through the AT compatibility interface.  A driver for
      that specific model of the ISDN adapter might however be able to
      provide much better support for this device.  To support this
      flexibility, the probes return priorities indicating their level
      of support.  Support for a specific revision of a product ranks
      the highest and the generic driver the lowest priority.  It
      might also be that multiple drivers could attach to one device
      if there are multiple interfaces within one configuration.  Each
      driver only needs to support a subset of the interfaces.</p><p>The probing for a driver for a newly attached device checks
      first for device specific drivers.  If not found, the probe code
      iterates over all supported configurations until a driver
      attaches in a configuration.  To support devices with multiple
      drivers on different interfaces, the probe iterates over all
      interfaces in a configuration that have not yet been claimed by
      a driver.  Configurations that exceed the power budget for the
      hub are ignored.  During attach the driver should initialise the
      device to its proper state, but not reset it, as this will make
      the device disconnect itself from the bus and restart the
      probing process for it.  To avoid consuming unnecessary
      bandwidth should not claim the interrupt pipe at attach time,
      but should postpone allocating the pipe until the file is opened
      and the data is actually used.  When the file is closed the pipe
      should be closed again, even though the device might still be
      attached.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp54867320"></a>13.4.1. Device Disconnect and Detach</h3></div></div></div><a id="idp54867960" class="indexterm"></a><p>A device driver should expect to receive errors during any
	transaction with the device.  The design of USB supports and
	encourages the disconnection of devices at any point in time.
	Drivers should make sure that they do the right thing when the
	device disappears.</p><p>Furthermore a device that has been disconnected and
	reconnected will not be reattached at the same device
	instance.  This might change in the future when more devices
	support serial numbers (see the device descriptor) or other
	means of defining an identity for a device have been
	developed.</p><p>The disconnection of a device is signaled by a hub in the
	interrupt packet delivered to the hub driver.  The status
	change information indicates which port has seen a connection
	change.  The device detach method for all device drivers for
	the device connected on that port are called and the
	structures cleaned up.  If the port status indicates that in
	the mean time a device has been connected to that port, the
	procedure for probing and attaching the device will be
	started.  A device reset will produce a disconnect-connect
	sequence on the hub and will be handled as described
	above.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="usb-protocol"></a>13.5. USB Drivers Protocol Information</h2></div></div></div><p>The protocol used over pipes other than the default pipe is
      undefined by the USB specification.  Information on this can be
      found from various sources.  The most accurate source is the
      developer's section on the USB home pages.  From these pages, a
      growing number of deviceclass specifications are available.
      These specifications specify what a compliant device should look
      like from a driver perspective, basic functionality it needs to
      provide and the protocol that is to be used over the
      communication channels.  The USB specification includes the
      description of the Hub Class.  A class specification for Human
      Interface Devices (HID) has been created to cater for keyboards,
      tablets, bar-code readers, buttons, knobs, switches, etc.  A
      third example is the class specification for mass storage
      devices.  For a full list of device classes see the developers
      section on the USB home pages.</p><p>For many devices the protocol information has not yet been
      published however.  Information on the protocol being used might
      be available from the company making the device.  Some companies
      will require you to sign a Non -Disclosure Agreement (NDA)
      before giving you the specifications.  This in most cases
      precludes making the driver open source.</p><p>Another good source of information is the Linux driver
      sources, as a number of companies have started to provide
      drivers for Linux for their devices.  It is always a good idea
      to contact the authors of those drivers for their source of
      information.</p><p>Example: Human Interface Devices The specification for the
      Human Interface Devices like keyboards, mice, tablets, buttons,
      dials,etc. is referred to in other device class specifications
      and is used in many devices.</p><p>For example audio speakers provide endpoints to the digital
      to analogue converters and possibly an extra pipe for a
      microphone.  They also provide a HID endpoint in a separate
      interface for the buttons and dials on the front of the device.
      The same is true for the monitor control class.  It is
      straightforward to build support for these interfaces through
      the available kernel and userland libraries together with the
      HID class driver or the generic driver.  Another device that
      serves as an example for interfaces within one configuration
      driven by different device drivers is a cheap keyboard with
      built-in legacy mouse port.  To avoid having the cost of
      including the hardware for a USB hub in the device,
      manufacturers combined the mouse data received from the PS/2
      port on the back of the keyboard and the key presses from the
      keyboard into two separate interfaces in the same configuration.
      The mouse and keyboard drivers each attach to the appropriate
      interface and allocate the pipes to the two independent
      endpoints.</p><a id="idp55336056" class="indexterm"></a><p>Example: Firmware download Many devices that have been
      developed are based on a general purpose processor with an
      additional USB core added to it.  Because the development of
      drivers and firmware for USB devices is still very new, many
      devices require the downloading of the firmware after they have
      been connected.</p><p>The procedure followed is straightforward.  The device
      identifies itself through a vendor and product Id.  The first
      driver probes and attaches to it and downloads the firmware into
      it.  After that the device soft resets itself and the driver is
      detached.  After a short pause the device announces its presence
      on the bus.  The device will have changed its
      vendor/product/revision Id to reflect the fact that it has been
      supplied with firmware and as a consequence a second driver will
      probe it and attach to it.</p><p>An example of these types of devices is the ActiveWire I/O
      board, based on the EZ-USB chip.  For this chip a generic
      firmware downloader is available.  The firmware downloaded into
      the ActiveWire board changes the revision Id.  It will then
      perform a soft reset of the USB part of the EZ-USB chip to
      disconnect from the USB bus and again reconnect.</p><p>Example: Mass Storage Devices Support for mass storage
      devices is mainly built around existing protocols.  The Iomega
      USB Zipdrive is based on the SCSI version of their drive.  The
      SCSI commands and status messages are wrapped in blocks and
      transferred over the bulk pipes to and from the device,
      emulating a SCSI controller over the USB wire.  ATAPI and UFI
      commands are supported in a similar fashion.</p><a id="idp55338744" class="indexterm"></a><p>The Mass Storage Specification supports 2 different types of
      wrapping of the command block.The initial attempt was based on
      sending the command and status through the default pipe and
      using bulk transfers for the data to be moved between the host
      and the device.  Based on experience a second approach was
      designed that was based on wrapping the command and status
      blocks and sending them over the bulk out and in endpoint.  The
      specification specifies exactly what has to happen when and what
      has to be done in case an error condition is encountered.  The
      biggest challenge when writing drivers for these devices is to
      fit USB based protocol into the existing support for mass
      storage devices.  CAM provides hooks to do this in a fairly
      straight forward way.  ATAPI is less simple as historically the
      IDE interface has never had many different appearances.</p><p>The support for the USB floppy from Y-E Data is again less
      straightforward as a new command set has been designed.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="newbus"></a>Chapter 14. Newbus</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Jeroen</span> <span class="surname">Ruigrok van der Werven (asmodai)</span></span> and <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Hiten</span> <span class="surname">Pandya</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#newbus-devdrivers">14.1. Device Drivers</a></span></dt><dt><span class="sect1"><a href="#newbus-overview">14.2. Overview of Newbus</a></span></dt><dt><span class="sect1"><a href="#newbus-api">14.3. Newbus API</a></span></dt></dl></div><p><span class="emphasis"><em>Special thanks to Matthew N. Dodd, Warner Losh, Bill
      Paul, Doug Rabson, Mike Smith, Peter Wemm and Scott
      Long</em></span>.</p><p>This chapter explains the Newbus device framework in
    detail.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="newbus-devdrivers"></a>14.1. Device Drivers</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55399160"></a>14.1.1. Purpose of a Device Driver</h3></div></div></div><a id="idp55399800" class="indexterm"></a><a id="idp55400312" class="indexterm"></a><p>A device driver is a software component which provides the
	interface between the kernel's generic view of a peripheral
	(e.g., disk, network adapter) and the actual implementation of
	the peripheral.  The <span class="emphasis"><em>device driver interface
	(DDI)</em></span> is the defined interface between the kernel
	and the device driver component.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55401976"></a>14.1.2. Types of Device Drivers</h3></div></div></div><p>There used to be days in <span class="trademark">UNIX</span>®, and thus FreeBSD, in
	which there were four types of devices defined:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>block device drivers</p></li><li class="listitem"><p>character device drivers</p></li><li class="listitem"><p>network device drivers</p></li><li class="listitem"><p>pseudo-device drivers</p></li></ul></div><a id="idp55410040" class="indexterm"></a><p><span class="emphasis"><em>Block devices</em></span> performed in a way that
	used fixed size blocks [of data].  This type of driver
	depended on the so-called <span class="emphasis"><em>buffer cache</em></span>,
	which had cached accessed blocks of data in a dedicated part
	of memory.  Often this buffer cache was based on write-behind,
	which meant that when data was modified in memory it got
	synced to disk whenever the system did its periodical disk
	flushing, thus optimizing writes.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55411704"></a>14.1.3. Character Devices</h3></div></div></div><a id="idp55412344" class="indexterm"></a><p>However, in the versions of FreeBSD 4.0 and onward the
	distinction between block and character devices became
	non-existent.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="newbus-overview"></a>14.2. Overview of Newbus</h2></div></div></div><a id="idp55418744" class="indexterm"></a><p><span class="emphasis"><em>Newbus</em></span> is the implementation of a new
      bus architecture based on abstraction layers which saw its
      introduction in FreeBSD 3.0 when the Alpha port was imported
      into the source tree.  It was not until 4.0 before it became the
      default system to use for device drivers.  Its goals are to
      provide a more object-oriented means of interconnecting the
      various busses and devices which a host system provides to the
      <span class="emphasis"><em>Operating System</em></span>.</p><p>Its main features include amongst others:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>dynamic attaching</p></li><li class="listitem"><p>easy modularization of drivers</p></li><li class="listitem"><p>pseudo-busses</p></li></ul></div><p>One of the most prominent changes is the migration from the
      flat and ad-hoc system to a device tree layout.</p><p>At the top level resides the
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">root</span>&#8221;</span></em></span> device which is the
      parent to hang all other devices on.  For each architecture,
      there is typically a single child of <span class="quote">&#8220;<span class="quote">root</span>&#8221;</span> which
      has such things as <span class="emphasis"><em>host-to-PCI bridges</em></span>,
      etc. attached to it.  For x86, this <span class="quote">&#8220;<span class="quote">root</span>&#8221;</span> device
      is the <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">nexus</span>&#8221;</span></em></span> device.  For
      Alpha, various different models of Alpha have
      different top-level devices corresponding to the different
      hardware chipsets, including <span class="emphasis"><em>lca</em></span>,
      <span class="emphasis"><em>apecs</em></span>, <span class="emphasis"><em>cia</em></span> and
      <span class="emphasis"><em>tsunami</em></span>.</p><p>A device in the Newbus context represents a single hardware
      entity in the system.  For instance each PCI device is
      represented by a Newbus device.  Any device in the system can
      have children; a device which has children is often called a
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">bus</span>&#8221;</span></em></span>.  Examples of common
      busses in the system are ISA and PCI, which manage lists of
      devices attached to ISA and PCI busses respectively.</p><p>Often, a connection between different kinds of bus is
      represented by a <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">bridge</span>&#8221;</span></em></span>
      device, which normally has one child for the attached bus.  An
      example of this is a <span class="emphasis"><em>PCI-to-PCI bridge</em></span>
      which is represented by a device
      <span class="emphasis"><em><code class="filename">pcibN</code></em></span> on the
      parent PCI bus and has a child
      <span class="emphasis"><em><code class="filename">pciN</code></em></span> for the
      attached bus.  This layout simplifies the implementation of the
      PCI bus tree, allowing common code to be used for both top-level
      and bridged busses.</p><p>Each device in the Newbus architecture asks its parent to
      map its resources.  The parent then asks its own parent until
      the nexus is reached.  So, basically the nexus is the only part
      of the Newbus system which knows about all resources.</p><div xmlns="" class="tip"><h3 class="admontitle">Tip: </h3><p xmlns="http://www.w3.org/1999/xhtml">An ISA device might want to map its IO port at
      <code class="literal">0x230</code>, so it asks its parent, in this case
      the ISA bus.  The ISA bus hands it over to the PCI-to-ISA bridge
      which in its turn asks the PCI bus, which reaches the
      host-to-PCI bridge and finally the nexus.  The beauty of this
      transition upwards is that there is room to translate the
      requests.  For example, the <code class="literal">0x230</code> IO port
      request might become memory-mapped at
      <code class="literal">0xb0000230</code> on a <acronym class="acronym">MIPS</acronym> box
      by the PCI bridge.</p></div><p>Resource allocation can be controlled at any place in the
      device tree.  For instance on many Alpha platforms, ISA
      interrupts are managed separately from PCI interrupts and
      resource allocations for ISA interrupts are managed by the
      Alpha's ISA bus device.  On IA-32, ISA and PCI interrupts are
      both managed by the top-level nexus device.  For both ports,
      memory and port address space is managed by a single entity -
      nexus for IA-32 and the relevant chipset driver on Alpha (e.g.,
      CIA or tsunami).</p><p>In order to normalize access to memory and port mapped
      resources, Newbus integrates the <code class="literal">bus_space</code>
      APIs from NetBSD. These provide a single API to replace inb/outb
      and direct memory reads/writes.  The advantage of this is that a
      single driver can easily use either memory-mapped registers or
      port-mapped registers (some hardware supports both).</p><p>This support is integrated into the resource allocation
      mechanism.  When a resource is allocated, a driver can retrieve
      the associated <code class="varname">bus_space_tag_t</code> and <code class="varname">bus_space_handle_t</code> from the
      resource.</p><p>Newbus also allows for definitions of interface methods in
      files dedicated to this purpose.  These are the
      <code class="filename">.m</code> files that are found under the
      <code class="filename">src/sys</code> hierarchy.</p><p>The core of the Newbus system is an extensible
      <span class="quote">&#8220;<span class="quote">object-based programming</span>&#8221;</span> model.  Each device in
      the system has a table of methods which it supports.  The system
      and other devices uses those methods to control the device and
      request services.  The different methods supported by a device
      are defined by a number of <span class="quote">&#8220;<span class="quote">interfaces</span>&#8221;</span>.  An
      <span class="quote">&#8220;<span class="quote">interface</span>&#8221;</span> is simply a group of related methods
      which can be implemented by a device.</p><p>In the Newbus system, the methods for a device are provided
      by the various device drivers in the system.  When a device is
      attached to a driver during
      <span class="emphasis"><em>auto-configuration</em></span>, it uses the method
      table declared by the driver.  A device can later
      <span class="emphasis"><em>detach</em></span> from its driver and
      <span class="emphasis"><em>re-attach</em></span> to a new driver with a new method
      table.  This allows dynamic replacement of drivers which can be
      useful for driver development.</p><p>The interfaces are described by an interface definition
      language similar to the language used to define vnode operations
      for file systems.  The interface would be stored in a methods
      file (which would normally be named
      <code class="filename">foo_if.m</code>).</p><div class="example"><a id="idp55477368"></a><div class="example-title">Example 14.1. Newbus Methods</div><div class="example-contents"><pre class="programlisting">      # Foo subsystem/driver (a comment...)

	  INTERFACE foo

	METHOD int doit {
		device_t dev;
	};

	# DEFAULT is the method that will be used, if a method was not
	# provided via: DEVMETHOD()

	METHOD void doit_to_child {
		device_t dev;
		driver_t child;
	} DEFAULT doit_generic_to_child;</pre></div></div><br class="example-break" /><p>When this interface is compiled, it generates a header file
      <span class="quote">&#8220;<span class="quote"><code class="filename">foo_if.h</code></span>&#8221;</span> which contains
      function declarations:</p><pre class="programlisting">      int FOO_DOIT(device_t dev);
      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);</pre><p>A source file, <span class="quote">&#8220;<span class="quote"><code class="filename">foo_if.c</code></span>&#8221;</span>
      is also created to accompany the automatically generated header
      file; it contains implementations of those functions which look
      up the location of the relevant functions in the object's method
      table and call that function.</p><p>The system defines two main interfaces.  The first
      fundamental interface is called
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">device</span>&#8221;</span></em></span> and includes methods
      which are relevant to all devices.  Methods in the
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">device</span>&#8221;</span></em></span> interface include
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">probe</span>&#8221;</span></em></span>,
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">attach</span>&#8221;</span></em></span> and
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">detach</span>&#8221;</span></em></span> to control detection
      of hardware and <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">shutdown</span>&#8221;</span></em></span>,
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">suspend</span>&#8221;</span></em></span> and
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">resume</span>&#8221;</span></em></span> for critical event
      notification.</p><p>The second, more complex interface is
      <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">bus</span>&#8221;</span></em></span>.  This interface
      contains methods suitable for devices which have children,
      including methods to access bus specific per-device information
      <a href="#ftn.idp55490040" class="footnote" id="idp55490040"><sup class="footnote">[10]</sup></a>, event
      notification
      (<span class="emphasis"><em><code class="literal">child_detached</code></em></span>,
      <span class="emphasis"><em><code class="literal">driver_added</code></em></span>) and
      resource management
      (<span class="emphasis"><em><code class="literal">alloc_resource</code></em></span>,
      <span class="emphasis"><em><code class="literal">activate_resource</code></em></span>,
      <span class="emphasis"><em><code class="literal">deactivate_resource</code></em></span>,
      <span class="emphasis"><em><code class="literal">release_resource</code></em></span>).</p><p>Many methods in the <span class="quote">&#8220;<span class="quote">bus</span>&#8221;</span> interface are
      performing services for some child of the bus device.  These
      methods would normally use the first two arguments to specify
      the bus providing the service and the child device which is
      requesting the service.  To simplify driver code, many of these
      methods have accessor functions which lookup the parent and call
      a method on the parent.  For instance the method
      <code class="literal">BUS_TEARDOWN_INTR(device_t dev, device_t child,
	...)</code> can be called using the function
      <code class="literal">bus_teardown_intr(device_t child,
	...)</code>.</p><p>Some bus types in the system define additional interfaces to
      provide access to bus-specific functionality.  For instance, the
      PCI bus driver defines the <span class="quote">&#8220;<span class="quote">pci</span>&#8221;</span> interface which
      has two methods
      <span class="emphasis"><em><code class="literal">read_config</code></em></span> and
      <span class="emphasis"><em><code class="literal">write_config</code></em></span> for
      accessing the configuration registers of a PCI device.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="newbus-api"></a>14.3. Newbus API</h2></div></div></div><p>As the Newbus API is huge, this section makes some effort at
      documenting it.  More information to come in the next revision
      of this document.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55516024"></a>14.3.1. Important Locations in the Source Hierarchy</h3></div></div></div><p><code class="filename">src/sys/[arch]/[arch]</code> - Kernel code
	for a specific machine architecture resides in this directory.
	For example, the <code class="literal">i386</code> architecture, or the
	<code class="literal">SPARC64</code> architecture.</p><p><code class="filename">src/sys/dev/[bus]</code> - device support
	for a specific <code class="literal">[bus]</code> resides in this
	directory.</p><p><code class="filename">src/sys/dev/pci</code> - PCI bus support
	code resides in this directory.</p><p><code class="filename">src/sys/[isa|pci]</code> - PCI/ISA device
	drivers reside in this directory.  The PCI/ISA bus support
	code used to exist in this directory in FreeBSD version
	<code class="literal">4.0</code>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55520888"></a>14.3.2. Important Structures and Type Definitions</h3></div></div></div><p><code class="literal">devclass_t</code> - This is a type definition
	of a pointer to a <code class="literal">struct devclass</code>.</p><p><code class="literal">device_method_t</code> - This is the same as
	<code class="literal">kobj_method_t</code> (see
	<code class="filename">src/sys/kobj.h</code>).</p><p><code class="literal">device_t</code> - This is a type definition of
	a pointer to a <code class="literal">struct device</code>.
	<code class="literal">device_t</code> represents a device in the system.
	It is a kernel object.  See
	<code class="filename">src/sys/sys/bus_private.h</code> for
	implementation details.</p><p><code class="literal">driver_t</code> - This is a type definition
	which references <code class="literal">struct driver</code>.  The
	<code class="literal">driver</code> struct is a class of the
	<code class="literal">device</code> kernel object; it also holds data
	private to the driver.</p><div class="figure"><a id="idp55527544"></a><div class="figure-title">Figure 14.1. <span class="emphasis"><em>driver_t</em></span> Implementation</div><div class="figure-contents"><pre class="programlisting">	  struct driver {
		KOBJ_CLASS_FIELDS;
		void	*priv;			/* driver private data */
	  };</pre></div></div><br class="figure-break" /><p>A <code class="literal">device_state_t</code> type, which is
	an enumeration, <code class="literal">device_state</code>.  It contains
	the possible states of a Newbus device before and after the
	autoconfiguration process.</p><div class="figure"><a id="idp55530104"></a><div class="figure-title">Figure 14.2. Device
	  States <span class="emphasis"><em>device_state_t</em></span></div><div class="figure-contents"><pre class="programlisting">	  /*
	   * src/sys/sys/bus.h
	   */
	  typedef enum device_state {
		DS_NOTPRESENT,	/* not probed or probe failed */
		DS_ALIVE,		/* probe succeeded */
		DS_ATTACHED,	/* attach method called */
		DS_BUSY			/* device is open */
	  } device_state_t;</pre></div></div><br class="figure-break" /></div></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp55490040" class="footnote"><p><a href="#idp55490040" class="para"><sup class="para">[10] </sup></a><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bus_generic_read_ivar&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bus_generic_read_ivar</span>(9)</span></a> and
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bus_generic_write_ivar&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bus_generic_write_ivar</span>(9)</span></a></p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="oss"></a>Chapter 15. Sound Subsystem</h2></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Jean-Francois</span> <span class="surname">Dockes</span></span>. </span></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#oss-intro">15.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#oss-files">15.2. Files</a></span></dt><dt><span class="sect1"><a href="#pcm-probe-and-attach">15.3. Probing, Attaching, etc.</a></span></dt><dt><span class="sect1"><a href="#oss-interfaces">15.4. Interfaces</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="oss-intro"></a>15.1. Introduction</h2></div></div></div><a id="idp55536504" class="indexterm"></a><p>The FreeBSD sound subsystem cleanly separates generic sound
      handling issues from device-specific ones.  This makes it easier
      to add support for new hardware.</p><p>The <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pcm</span>(4)</span></a> framework is the central piece of the sound
      subsystem.  It mainly implements the following elements:</p><a id="idp55538552" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A system call interface (read, write, ioctls) to
	  digitized sound and mixer functions.  The ioctl command set
	  is compatible with the legacy <span class="emphasis"><em>OSS</em></span> or
	  <span class="emphasis"><em>Voxware</em></span> interface, allowing common
	  multimedia applications to be ported without
	  modification.</p></li><li class="listitem"><p>Common code for processing sound data (format
	  conversions, virtual channels).</p></li><li class="listitem"><p>A uniform software interface to hardware-specific audio
	  interface modules.</p></li><li class="listitem"><p>Additional support for some common hardware interfaces
	  (ac97), or shared hardware-specific code (ex: ISA DMA
	  routines).</p></li></ul></div><p>The support for specific sound cards is implemented by
      hardware-specific drivers, which provide channel and mixer
      interfaces to plug into the generic <code class="filename">pcm</code>
      code.</p><p>In this chapter, the term <code class="filename">pcm</code> will
      refer to the central, common part of the sound driver, as
      opposed to the hardware-specific modules.</p><p>The prospective driver writer will of course want to start
      from an existing module and use the code as the ultimate
      reference.  But, while the sound code is nice and clean, it is
      also mostly devoid of comments.  This document tries to give an
      overview of the framework interface and answer some questions
      that may arise while adapting the existing code.</p><p>As an alternative, or in addition to starting from a working
      example, you can find a commented driver template at
      <a class="link" href="https://people.FreeBSD.org/~cg/template.c" target="_top">
	https://people.FreeBSD.org/~cg/template.c</a></p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="oss-files"></a>15.2. Files</h2></div></div></div><p>All the relevant code lives in
      <code class="filename">/usr/src/sys/dev/sound/</code>, except for the
      public ioctl interface definitions, found in
      <code class="filename">/usr/src/sys/sys/soundcard.h</code></p><p>Under <code class="filename">/usr/src/sys/dev/sound/</code>, the
      <code class="filename">pcm/</code> directory holds the central code,
      while the <code class="filename">pci/</code>, <code class="filename">isa/</code>
      and <code class="filename">usb/</code> directories have the drivers
      for PCI and ISA boards, and for USB audio devices.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="pcm-probe-and-attach"></a>15.3. Probing, Attaching, etc.</h2></div></div></div><p>Sound drivers probe and attach in almost the same way as any
      hardware driver module.  You might want to look at the <a class="link" href="#isa-driver" title="Chapter 10. ISA Device Drivers">ISA</a> or <a class="link" href="#pci" title="Chapter 11. PCI Devices">PCI</a> specific sections of the handbook for
      more information.</p><p>However, sound drivers differ in some ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>They declare themselves as <code class="filename">pcm</code>
	  class devices, with a <code class="varname">struct snddev_info</code> device
	  private structure:</p><pre class="programlisting">          static driver_t xxx_driver = {
              "pcm",
              xxx_methods,
              sizeof(struct snddev_info)
          };

          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);
          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);</pre><p>Most sound drivers
	  <a id="idp55576312" class="indexterm"></a>
	  need to store additional private information about their
	  device.  A private data structure is usually allocated in
	  the attach routine.  Its address is passed to
	  <code class="filename">pcm</code> by the calls to
	  <code class="function">pcm_register()</code> and
	  <code class="function">mixer_init()</code>.
	  <code class="filename">pcm</code> later passes back this address
	  as a parameter in calls to the sound driver
	  interfaces.</p></li><li class="listitem"><p>The sound driver attach routine should declare its MIXER
	  or AC97 interface to <code class="filename">pcm</code> by calling
	  <code class="function">mixer_init()</code>.  For a MIXER interface,
	  this causes in turn a call to <a class="link" href="#xxxmixer-init" title="15.4.2.1. mixer_init"><code class="function">xxxmixer_init()</code></a>.</p></li><li class="listitem"><p>The sound driver attach routine declares its general
	  CHANNEL configuration to <code class="filename">pcm</code> by
	  calling <code class="function">pcm_register(dev, sc, nplay,
	  nrec)</code>, where <code class="varname">sc</code> is the address
	  for the device data structure, used in further calls from
	  <code class="filename">pcm</code>, and <code class="varname">nplay</code>
	  and <code class="varname">nrec</code> are the number of play and
	  record channels.</p></li><li class="listitem"><p>The sound driver attach routine declares each of its
	  channel objects by calls to
	  <code class="function">pcm_addchan()</code>.  This sets up the
	  channel glue in <code class="filename">pcm</code> and causes in
	  turn a call to
	    <a class="link" href="#xxxchannel-init" title="15.4.1.3. channel_init">
	    <code class="function">xxxchannel_init()</code></a>.</p></li><li class="listitem"><p>The sound driver detach routine should call
	  <code class="function">pcm_unregister()</code> before releasing its
	  resources.</p></li></ul></div><p>There are two possible methods to handle non-PnP
      devices:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use a <code class="function">device_identify()</code> method
	  (example: <code class="filename">sound/isa/es1888.c</code>).  The
	  <code class="function">device_identify()</code> method probes for the
	  hardware at known addresses and, if it finds a supported
	  device, creates a new pcm device which is then passed to
	  probe/attach.</p></li><li class="listitem"><p>Use a custom kernel configuration with appropriate hints
	  for pcm devices (example:
	  <code class="filename">sound/isa/mss.c</code>).</p></li></ul></div><p><code class="filename">pcm</code> drivers should implement
      <code class="function">device_suspend</code>,
      <code class="function">device_resume</code> and
      <code class="function">device_shutdown</code> routines, so that power
      management and module unloading function correctly.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="oss-interfaces"></a>15.4. Interfaces</h2></div></div></div><p>The interface between the <code class="filename">pcm</code> core
      and the sound drivers is defined in terms of <a class="link" href="#kernel-objects" title="Chapter 3. Kernel Objects">kernel objects</a>.</p><p>There are two main interfaces that a sound driver will
      usually provide: <span class="emphasis"><em>CHANNEL</em></span> and either
      <span class="emphasis"><em>MIXER</em></span> or <span class="emphasis"><em>AC97</em></span>.</p><p>The <span class="emphasis"><em>AC97</em></span> interface is a very small
      hardware access (register read/write) interface, implemented by
      drivers for hardware with an AC97 codec.  In this case, the
      actual MIXER interface is provided by the shared AC97 code in
      <code class="filename">pcm</code>.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55619064"></a>15.4.1. The CHANNEL Interface</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55619704"></a>15.4.1.1. Common Notes for Function Parameters</h4></div></div></div><p>Sound drivers usually have a private data structure to
	  describe their device, and one structure for each play and
	  record data channel that it supports.</p><p>For all CHANNEL interface functions, the first parameter
	  is an opaque pointer.</p><p>The second parameter is a pointer to the private
	  channel data structure, except for
	  <code class="function">channel_init()</code> which has a pointer to
	  the private device structure (and returns the channel
	  pointer for further use by
	  <code class="filename">pcm</code>).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55622520"></a>15.4.1.2. Overview of Data Transfer Operations</h4></div></div></div><p>For sound data transfers, the
	  <code class="filename">pcm</code> core and the sound drivers
	  communicate through a shared memory area, described by a
	  <code class="varname">struct
	    snd_dbuf</code>.</p><p><code class="varname">struct snd_dbuf</code> is
	  private to <code class="filename">pcm</code>, and sound drivers
	  obtain values of interest by calls to accessor functions
	  (<code class="function">sndbuf_getxxx()</code>).</p><p>The shared memory area has a size of
	  <code class="function">sndbuf_getsize()</code> and is divided into
	  fixed size blocks of <code class="function">sndbuf_getblksz()</code>
	  bytes.</p><p>When playing, the general transfer mechanism is as
	  follows (reverse the idea for recording):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">pcm</code> initially fills up the
	      buffer, then calls the sound driver's <a class="link" href="#channel-trigger" title="15.4.1.7. channel_trigger">
	      <code class="function">xxxchannel_trigger()</code></a>
	      function with a parameter of PCMTRIG_START.</p></li><li class="listitem"><p>The sound driver then arranges to repeatedly
	      transfer the whole memory area
	      (<code class="function">sndbuf_getbuf()</code>,
	      <code class="function">sndbuf_getsize()</code>) to the device, in
	      blocks of <code class="function">sndbuf_getblksz()</code> bytes.
	      It calls back the <code class="function">chn_intr()</code>
	      <code class="filename">pcm</code> function for each
	      transferred block (this will typically happen at
	      interrupt time).</p></li><li class="listitem"><p><code class="function">chn_intr()</code> arranges to copy new
	      data to the area that was transferred to the device (now
	      free), and make appropriate updates to the <code class="varname">snd_dbuf</code>
	      structure.</p></li></ul></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="xxxchannel-init"></a>15.4.1.3. channel_init</h4></div></div></div><p><code class="function">xxxchannel_init()</code> is called to
	  initialize each of the play or record channels.  The calls
	  are initiated from the sound driver attach routine.  (See
	  the <a class="link" href="#pcm-probe-and-attach" title="15.3. Probing, Attaching, etc.">probe and attach
	    section</a>).</p><pre class="programlisting">          static void *
          xxxchannel_init(kobj_t obj, void *data,
             struct snd_dbuf *b, struct pcm_channel *c, int dir)<a id="co-chinit-params"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
          {
              struct xxx_info *sc = data;
              struct xxx_chinfo *ch;
               ...
              return ch;<a id="co-chinit-return"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-chinit-params"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p><code class="varname">b</code> is the address for the channel
	      <code class="varname">struct snd_dbuf</code>.
	      It should be initialized in the function by calling
	      <code class="function">sndbuf_alloc()</code>.  The buffer size to
	      use is normally a small multiple of the 'typical' unit
	      transfer size for your device.</p><p><code class="varname">c</code> is the
	      <code class="filename">pcm</code> channel control structure
	      pointer.  This is an opaque object.  The function should
	      store it in the local channel structure, to be used in
	      later calls to <code class="filename">pcm</code> (ie:
	      <code class="function">chn_intr(c)</code>).</p><p><code class="varname">dir</code> indicates the channel
	      direction (<code class="literal">PCMDIR_PLAY</code> or
	      <code class="literal">PCMDIR_REC</code>).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-chinit-return"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The function should return a pointer to the private
	      area used to control this channel.  This will be passed
	      as a parameter to other channel interface calls.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55373560"></a>15.4.1.4. channel_setformat</h4></div></div></div><p><code class="function">xxxchannel_setformat()</code> should set
	  up the hardware for the specified channel for the specified
	  sound format.</p><pre class="programlisting">          static int
          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<a id="co-chsetformat-params"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-chsetformat-params"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p><code class="varname">format</code> is specified as an
	      <code class="literal">AFMT_XXX value</code>
	      (<code class="filename">soundcard.h</code>).</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55378168"></a>15.4.1.5. channel_setspeed</h4></div></div></div><p><code class="function">xxxchannel_setspeed()</code> sets up the
	  channel hardware for the specified sampling speed, and
	  returns the possibly adjusted speed.</p><pre class="programlisting">          static int
          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)
          {
              struct xxx_chinfo *ch = data;
               ...
              return speed;
           }</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55379960"></a>15.4.1.6. channel_setblocksize</h4></div></div></div><p><code class="function">xxxchannel_setblocksize()</code> sets the
	  block size, which is the size of unit transactions between
	  <code class="filename">pcm</code> and the sound driver, and
	  between the sound driver and the device.  Typically, this
	  would be the number of bytes transferred before an interrupt
	  occurs.  During a transfer, the sound driver should call
	  <code class="filename">pcm</code>'s
	  <code class="function">chn_intr()</code> every time this size has
	  been transferred.</p><p>Most sound drivers only take note of the block size
	  here, to be used when an actual transfer will be
	  started.</p><pre class="programlisting">          static int
          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)
          {
              struct xxx_chinfo *ch = data;
                ...
              return blocksize;<a id="co-chsetblocksize-return"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-chsetblocksize-return"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The function returns the possibly adjusted block
	      size.  In case the block size is indeed changed,
	      <code class="function">sndbuf_resize()</code> should be called to
	      adjust the buffer.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="channel-trigger"></a>15.4.1.7. channel_trigger</h4></div></div></div><p><code class="function">xxxchannel_trigger()</code> is called by
	  <code class="filename">pcm</code> to control data transfer
	  operations in the driver.</p><pre class="programlisting">          static int
          xxxchannel_trigger(kobj_t obj, void *data, int go)<a id="co-chtrigger-params"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
          {
              struct xxx_chinfo *ch = data;
               ...
              return 0;
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-chtrigger-params"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p><code class="varname">go</code> defines the action for the
	      current call.  The possible values are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">PCMTRIG_START</code>: the driver
		  should start a data transfer from or to the channel
		  buffer.  If needed, the buffer base and size can be
		  retrieved through
		  <code class="function">sndbuf_getbuf()</code> and
		  <code class="function">sndbuf_getsize()</code>.</p></li><li class="listitem"><p><code class="literal">PCMTRIG_EMLDMAWR</code> /
		  <code class="literal">PCMTRIG_EMLDMARD</code>: this tells the
		  driver that the input or output buffer may have been
		  updated.  Most drivers just ignore these
		  calls.</p></li><li class="listitem"><p><code class="literal">PCMTRIG_STOP</code> /
		  <code class="literal">PCMTRIG_ABORT</code>: the driver should
		  stop the current transfer.</p></li></ul></div></td></tr></table></div><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">If the driver uses ISA DMA,
	    <code class="function">sndbuf_isadma()</code> should be called
	    before performing actions on the device, and will take
	    care of the DMA chip side of things.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55658360"></a>15.4.1.8. channel_getptr</h4></div></div></div><p><code class="function">xxxchannel_getptr()</code> returns the
	  current offset in the transfer buffer.  This will typically
	  be called by <code class="function">chn_intr()</code>, and this is
	  how <code class="filename">pcm</code> knows where it can transfer
	  new data.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55660536"></a>15.4.1.9. channel_free</h4></div></div></div><p><code class="function">xxxchannel_free()</code> is called to free
	  up channel resources, for example when the driver is
	  unloaded, and should be implemented if the channel data
	  structures are dynamically allocated or if
	  <code class="function">sndbuf_alloc()</code> was not used for buffer
	  allocation.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55662328"></a>15.4.1.10. channel_getcaps</h4></div></div></div><pre class="programlisting">          struct pcmchan_caps *
          xxxchannel_getcaps(kobj_t obj, void *data)
          {
              return &amp;xxx_caps;<a id="co-chgetcaps-return"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-chgetcaps-return"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The routine returns a pointer to a (usually
	      statically-defined) <code class="varname">pcmchan_caps</code> structure
	      (defined in <code class="filename">sound/pcm/channel.h</code>.
	      The structure holds the minimum and maximum sampling
	      frequencies, and the accepted sound formats.  Look at
	      any sound driver for an example.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55666040"></a>15.4.1.11. More Functions</h4></div></div></div><p><code class="function">channel_reset()</code>,
	  <code class="function">channel_resetdone()</code>, and
	  <code class="function">channel_notify()</code> are for special
	  purposes and should not be implemented in a driver without
	  discussing it on the <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia" target="_top">FreeBSD multimedia mailing list</a>.</p><p><code class="function">channel_setdir()</code> is
	  deprecated.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55685880"></a>15.4.2. The MIXER Interface</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="xxxmixer-init"></a>15.4.2.1. mixer_init</h4></div></div></div><p><code class="function">xxxmixer_init()</code> initializes the
	  hardware and tells <code class="filename">pcm</code> what mixer
	  devices are available for playing and recording</p><pre class="programlisting">          static int
          xxxmixer_init(struct snd_mixer *m)
          {
              struct xxx_info   *sc = mix_getdevinfo(m);
              u_int32_t v;

              [Initialize hardware]

              [Set appropriate bits in v for play mixers]<a id="co-mxini-sd"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
              mix_setdevs(m, v);
              [Set appropriate bits in v for record mixers]
              mix_setrecdevs(m, v)

              return 0;
          }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-mxini-sd"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>Set bits in an integer value and call
	      <code class="function">mix_setdevs()</code> and
	      <code class="function">mix_setrecdevs()</code> to tell
	      <code class="filename">pcm</code> what devices exist.</p></td></tr></table></div><p>Mixer bits definitions can be found in
	  <code class="filename">soundcard.h</code>
	  (<code class="literal">SOUND_MASK_XXX</code> values and
	  <code class="literal">SOUND_MIXER_XXX</code> bit shifts).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55697272"></a>15.4.2.2. mixer_set</h4></div></div></div><p><code class="function">xxxmixer_set()</code> sets the volume
	  level for one mixer device.</p><pre class="programlisting">          static int
          xxxmixer_set(struct snd_mixer *m, unsigned dev,
                           unsigned left, unsigned right)<a id="co-mxset-params"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
          {
              struct sc_info *sc = mix_getdevinfo(m);
              [set volume level]
              return left | (right &lt;&lt; 8);<a id="co-mxset-return"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
          }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-mxset-params"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The device is specified as a
	      <code class="literal">SOUND_MIXER_XXX</code> value</p><p>The volume values are specified in range [0-100].
	      A value of zero should mute the device.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-mxset-return"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>As the hardware levels probably will not match the
	      input scale, and some rounding will occur, the routine
	      returns the actual level values (in range 0-100) as
	      shown.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55702776"></a>15.4.2.3. mixer_setrecsrc</h4></div></div></div><p><code class="function">xxxmixer_setrecsrc()</code> sets the
	  recording source device.</p><pre class="programlisting">          static int
          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<a id="co-mxsr-params"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
          {
              struct xxx_info *sc = mix_getdevinfo(m);

              [look for non zero bit(s) in src, set up hardware]

              [update src to reflect actual action]
              return src;<a id="co-mxsr-return"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
           }</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-mxsr-params"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The desired recording devices are specified as a
	      bit field</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-mxsr-return"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The actual devices set for recording are returned.
	      Some drivers can only set one device for recording.  The
	      function should return -1 if an error occurs.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55707512"></a>15.4.2.4. mixer_uninit, mixer_reinit</h4></div></div></div><p><code class="function">xxxmixer_uninit()</code> should ensure
	  that all sound is muted and if possible mixer hardware
	  should be powered down.</p><p><code class="function">xxxmixer_reinit()</code> should ensure
	  that the mixer hardware is powered up and any settings not
	  controlled by <code class="function">mixer_set()</code> or
	  <code class="function">mixer_setrecsrc()</code> are restored.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55714552"></a>15.4.3. The AC97 Interface</h3></div></div></div><a id="idp55715192" class="indexterm"></a><p>The <span class="emphasis"><em>AC97</em></span> interface is implemented
	by drivers with an AC97 codec.  It only has three
	methods:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">xxxac97_init()</code> returns the number
	    of ac97 codecs found.</p></li><li class="listitem"><p><code class="function">ac97_read()</code> and
	    <code class="function">ac97_write()</code> read or write a
	    specified register.</p></li></ul></div><p>The <span class="emphasis"><em>AC97</em></span> interface is used by the
	AC97 code in <code class="filename">pcm</code> to perform higher
	level operations.  Look at
	<code class="filename">sound/pci/maestro3.c</code> or many others under
	<code class="filename">sound/pci/</code> for an example.</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard"></a>Chapter 16. PC Card</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#pccard-adddev">16.1. Adding a Device</a></span></dt></dl></div><a id="idp55722744" class="indexterm"></a><a id="idp55723256" class="indexterm"></a><p>This chapter will talk about the FreeBSD mechanisms for
    writing a device driver for a PC Card or CardBus device.  However,
    at present it just documents how to add a new device to an
    existing pccard driver.</p><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="pccard-adddev"></a>16.1. Adding a Device</h2></div></div></div><p>Device drivers know what devices they support.  There is a
      table of supported devices in the kernel that drivers use to
      attach to a device.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard-overview"></a>16.1.1. Overview</h3></div></div></div><a id="idp55738360" class="indexterm"></a><p>PC Cards are identified in one of two ways, both based on
	the <em class="firstterm">Card Information Structure</em>
	(<acronym class="acronym">CIS</acronym>)
	stored on the card.  The
	first method is to use numeric manufacturer and product
	numbers.  The second method is to use the human readable
	strings that are also contained in the CIS.  The PC Card bus
	uses a centralized database and some macros to facilitate a
	design pattern to help the driver writer match devices to his
	driver.</p><p>Original equipment manufacturers (<acronym class="acronym">OEM</acronym>s)
	often develop a reference design for a PC Card product, then
	sell this design to other companies to market.  Those
	companies refine the design, market the product to their
	target audience or geographic area, and put their own name
	plate onto the card.  The refinements to the physical card are
	typically very minor, if any changes are made at all.  To
	strengthen their brand, these vendors place their company name
	in the human readable strings in the CIS space, but leave the
	manufacturer and product IDs unchanged.</p><a id="idp55740920" class="indexterm"></a><a id="idp55745528" class="indexterm"></a><a id="idp55746040" class="indexterm"></a><p>Because of this practice, FreeBSD drivers usually rely on
	numeric IDs for device identification.  Using numeric IDs and
	a centralized database complicates adding IDs and support for
	cards to the system.  One must carefully check to see who
	really made the card, especially when it appears that the
	vendor who made the card might already have a different
	manufacturer ID listed in the central database.  Linksys,
	D-Link, and NetGear are a number of US manufacturers of LAN
	hardware that often sell the same design.  These same designs
	can be sold in Japan under names such as Buffalo and Corega.
	Often, these devices will all have the same manufacturer and
	product IDs.</p><p>The PC Card bus code keeps a central database of card
	information, but not which driver is associated with them, in
	<code class="filename">/sys/dev/pccard/pccarddevs</code>.  It also
	provides a set of macros that allow one to easily construct
	simple entries in the table the driver uses to claim
	devices.</p><p>Finally, some really low end devices do not contain
	manufacturer identification at all.  These devices must be
	detected by matching the human readable CIS strings.
	While it would be nice if we did not need this method as a
	fallback, it is necessary for some very low end CD-ROM players
	and Ethernet cards.  This method should generally be
	avoided, but a number of devices are listed in this section
	because they were added prior to the recognition of the
	<acronym class="acronym">OEM</acronym> nature of the PC Card business.  When
	adding new devices, prefer using the numeric method.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard-pccarddevs"></a>16.1.2. Format of <code class="filename">pccarddevs</code></h3></div></div></div><p>There are four sections in the
	<code class="filename">pccarddevs</code> files.  The first section
	lists the manufacturer numbers for vendors that use
	them.  This section is sorted in numerical order.  The next
	section has all of the products that are used by these
	vendors, along with their product ID numbers and a description
	string.  The description string typically is not used (instead
	we set the device's description based on the human readable
	CIS, even if we match on the numeric version).  These two
	sections are then repeated for devices that use the
	string matching method.  Finally, C-style comments enclosed in
	<code class="literal">/*</code> and <code class="literal">*/</code> characters are
	allowed anywhere in the file.</p><p>The first section of the file contains the vendor IDs.
	Please keep this list sorted in numeric order.  Also, please
	coordinate changes to this file because we share it with
	NetBSD to help facilitate a common clearing house for this
	information.  For example, here are the first few vendor
	IDs:</p><pre class="programlisting">vendor FUJITSU			0x0004  Fujitsu Corporation
vendor NETGEAR_2		0x000b  Netgear
vendor PANASONIC		0x0032	Matsushita Electric Industrial Co.
vendor SANDISK			0x0045	Sandisk Corporation</pre><p>Chances are very good
	that the <code class="literal">NETGEAR_2</code> entry is really an OEM
	that NETGEAR purchased cards from and the author of support
	for those cards was unaware at the time that Netgear was using
	someone else's ID.  These entries are fairly straightforward.
	The vendor keyword denotes the kind of line that this is,
	followed by the name of the vendor.  This name will be
	repeated later in <code class="filename">pccarddevs</code>, as
	well as used in the driver's match tables, so keep it short
	and a valid C identifier.  A numeric ID in hex identifies the
	manufacturer.  Do not add IDs of the form
	<code class="literal">0xffffffff</code> or <code class="literal">0xffff</code>
	because these are reserved IDs (the former is
	<span class="quote">&#8220;<span class="quote">no ID set</span>&#8221;</span> while the latter is sometimes seen in
	extremely poor quality cards to try to indicate
	<span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>).  Finally there is a string description
	of the company that makes the card.  This string is not used
	in FreeBSD for anything but commentary purposes.</p><p>The second section of the file contains the products.  As
	shown in this example, the format is similar to the vendor
	lines:</p><pre class="programlisting">/* Allied Telesis K.K. */
product ALLIEDTELESIS LA_PCM	0x0002 Allied Telesis LA-PCM

/* Archos */
product	ARCHOS ARC_ATAPI	0x0043 MiniCD</pre><p>The
	<code class="literal">product</code> keyword is followed by the vendor
	name, repeated from above.  This is followed by the product
	name, which is used by the driver and should be a valid C
	identifier, but may also start with a number.  As with the
	vendors, the hex product ID for this card follows the same
	convention for <code class="literal">0xffffffff</code> and
	<code class="literal">0xffff</code>.  Finally, there is a string
	description of the device itself.  This string typically is
	not used in FreeBSD, since FreeBSD's pccard bus driver will
	construct a string from the human readable CIS entries, but it
	can be used in the rare cases where this is somehow
	insufficient.  The products are in alphabetical order by
	manufacturer, then numerical order by product ID.  They have a
	C comment before each manufacturer's entries and there is a
	blank line between entries.</p><p>The third section is like the previous vendor section, but
	with all of the manufacturer numeric IDs set to
	<code class="literal">-1</code>, meaning
	<span class="quote">&#8220;<span class="quote">match anything found</span>&#8221;</span> in the FreeBSD pccard
	bus code.  Since these are C identifiers, their names must be
	unique.  Otherwise the format is identical to the first
	section of the file.</p><p>The final section contains the entries for those cards
	that must be identified by string entries.  This section's
	format is a little different from the generic section:</p><pre class="programlisting">product ADDTRON AWP100		{ "Addtron", "AWP-100&amp;spWireless&amp;spPCMCIA", "Version&amp;sp01.02", NULL }
product ALLIEDTELESIS WR211PCM	{ "Allied&amp;spTelesis&amp;spK.K.", "WR211PCM", NULL, NULL } Allied Telesis WR211PCM</pre><p>The familiar <code class="literal">product</code> keyword is
	followed by the vendor name and the card name, just as in the
	second section of the file.  Here the format deviates from
	that used earlier.  There is a {} grouping, followed by a
	number of strings.  These strings correspond to the vendor,
	product, and extra information that is defined in a CIS_INFO
	tuple.  These strings are filtered by the program that
	generates <code class="filename">pccarddevs.h</code> to replace &amp;sp
	with a real space.  NULL strings mean that the corresponding
	part of the entry should be ignored.  The example shown here
	contains a bad entry.  It should not contain the version
	number unless that is critical for the operation of the card.
	Sometimes vendors will have many different versions of the
	card in the field that all work, in which case that
	information only makes it harder for someone with a similar
	card to use it with FreeBSD.  Sometimes it is necessary when a
	vendor wishes to sell many different parts under the same
	brand due to market considerations (availability, price, and
	so forth).  Then it can be critical to disambiguating the card
	in those rare cases where the vendor kept the same
	manufacturer/product pair.  Regular expression matching is not
	available at this time.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard-probe"></a>16.1.3. Sample Probe Routine</h3></div></div></div><a id="idp55765240" class="indexterm"></a><p>To understand how to add a device to the list of supported
	devices, one must understand the probe and/or match routines
	that many drivers have.  It is complicated a little in FreeBSD
	5.x because there is a compatibility layer for OLDCARD present
	as well.  Since only the window-dressing is different, an
	idealized version will be presented here.</p><pre class="programlisting">static const struct pccard_product wi_pccard_products[] = {
	PCMCIA_CARD(3COM, 3CRWE737A, 0),
	PCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),
	PCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),
	PCMCIA_CARD(TDK, LAK_CD011WL, 0),
	{ NULL }
};

static int
wi_pccard_probe(dev)
	device_t	dev;
{
	const struct pccard_product *pp;

	if ((pp = pccard_product_lookup(dev, wi_pccard_products,
	    sizeof(wi_pccard_products[0]), NULL)) != NULL) {
		if (pp-&gt;pp_name != NULL)
			device_set_desc(dev, pp-&gt;pp_name);
		return (0);
	}
	return (ENXIO);
}</pre><p>Here we have a simple pccard probe routine that matches a
	few devices.  As stated above, the name may vary (if it is not
	<code class="function">foo_pccard_probe()</code> it will be
	<code class="function">foo_pccard_match()</code>).  The function
	<code class="function">pccard_product_lookup()</code> is a generalized
	function that walks the table and returns a pointer to the
	first entry that it matches.  Some drivers may use this
	mechanism to convey additional information about some cards to
	the rest of the driver, so there may be some variance in the
	table.  The only requirement is that each row of the table
	must have a <code class="function">struct</code>
	<code class="varname">pccard_product</code> as the first
	element.</p><p>Looking at the table
	<code class="varname">wi_pccard_products</code>, one notices that
	all the entries are of the form
	<code class="function">PCMCIA_CARD(<em class="replaceable"><code>foo</code></em>,
	  <em class="replaceable"><code>bar</code></em>,
	  <em class="replaceable"><code>baz</code></em>)</code>.  The
	<em class="replaceable"><code>foo</code></em> part is the manufacturer ID
	from <code class="filename">pccarddevs</code>.  The
	<em class="replaceable"><code>bar</code></em> part is the product ID.
	<em class="replaceable"><code>baz</code></em> is the expected function number
	for this card.  Many pccards can have multiple functions,
	and some way to disambiguate function 1 from function 0 is
	needed.  You may see <code class="literal">PCMCIA_CARD_D</code>, which
	includes the device description from
	<code class="filename">pccarddevs</code>.  You may also see
	<code class="literal">PCMCIA_CARD2</code> and
	<code class="literal">PCMCIA_CARD2_D</code> which are used when you need
	to match both CIS strings and manufacturer numbers, in the
	<span class="quote">&#8220;<span class="quote">use the default description</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">take the
	  description from pccarddevs</span>&#8221;</span> flavors.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard-add"></a>16.1.4. Putting it All Together</h3></div></div></div><p>To add a new device, one must first obtain the
	identification information from the
	device.  The easiest way to do this is to insert the device
	into a PC Card or CF slot and issue
	<code class="command">devinfo -v</code>.  Sample output:</p><pre class="programlisting">        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1
          cardbus1
          pccard1
            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor="BUFFALO" cisproduct="WLI2-CF-S11" function_type=6 at function=0</pre><p><code class="literal">manufacturer</code>
	and <code class="literal">product</code> are the numeric IDs for this
	product, while <code class="literal">cisvendor</code> and
	<code class="literal">cisproduct</code> are the product description
	strings from the CIS.</p><p>Since we first want to prefer the numeric option, first
	try to construct an entry based on that.  The above card has
	been slightly fictionalized for the purpose of this example.
	The vendor is BUFFALO, which we see already has an
	entry:</p><pre class="programlisting">vendor BUFFALO			0x026f	BUFFALO (Melco Corporation)</pre><p>But there is no entry for this particular card.
	Instead we find:</p><pre class="programlisting">/* BUFFALO */
product BUFFALO WLI_PCM_S11	0x0305	BUFFALO AirStation 11Mbps WLAN
product BUFFALO LPC_CF_CLT	0x0307	BUFFALO LPC-CF-CLT
product	BUFFALO	LPC3_CLT	0x030a	BUFFALO LPC3-CLT Ethernet Adapter
product BUFFALO WLI_CF_S11G	0x030b	BUFFALO AirStation 11Mbps CF WLAN</pre><p>To add the device, we can just add this entry to
	<code class="filename">pccarddevs</code>:</p><pre class="programlisting">product BUFFALO WLI2_CF_S11G	0x030c	BUFFALO AirStation ultra 802.11b CF</pre><p>Once these steps are complete, the card can be added to
	the driver.  That is a simple operation of adding one
	line:</p><pre class="programlisting">static const struct pccard_product wi_pccard_products[] = {
	PCMCIA_CARD(3COM, 3CRWE737A, 0),
	PCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),
	PCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),
+	PCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),
	PCMCIA_CARD(TDK, LAK_CD011WL, 0),
	{ NULL }
};</pre><p>Note that I have included a '<code class="literal">+</code>' in the
	line before the line that I added, but that is simply to
	highlight the line.  Do not add it to the actual driver.  Once
	you have added the line, you can recompile your kernel or
	module and test it.  If the device is recognized and works,
	please submit a patch.  If it does not work, please figure out
	what is needed to make it work and submit a patch.  If the
	device is not recognized at all, you have done something wrong
	and should recheck each step.</p><p>If you are a FreeBSD src committer, and everything appears
	to be working, then you can commit the changes to the tree.
	However, there are some minor tricky things to be considered.
	<code class="filename">pccarddevs</code> must be committed to the tree
	first.  Then <code class="filename">pccarddevs.h</code> must be
	regenerated and committed as a second step, ensuring that the
	right $FreeBSD$ tag is in the latter file.
	Finally, commit the additions to the driver.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pccard-pr"></a>16.1.5. Submitting a New Device</h3></div></div></div><p>Please do not send entries for new devices to the author
	directly.  Instead, submit them as a PR and send the author
	the PR number for his records.  This ensures that entries are
	not lost.  When submitting a PR, it is unnecessary to include
	the <code class="filename">pccardevs.h</code> diffs in the patch, since
	those will be regenerated.  It is necessary to include a
	description of the device, as well as the patches to the
	client driver.  If you do not know the name, use OEM99 as the
	name, and the author will adjust OEM99 accordingly after
	investigation.  Committers should not commit OEM99, but
	instead find the highest OEM entry and commit one more than
	that.</p></div></div></div></div><div class="part"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="appendices"></a>Part III. Appendices</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="bibliography"><a href="#idp55804920">Bibliography</a></span></dt></dl></div><div class="bibliography"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55804920"></a>Bibliography</h2></div></div></div><div class="biblioentry"><a id="idp55805176"></a><p>[1] <span class="authorgroup"><span class="firstname">Marshall</span> <span class="othername">Kirk</span> <span class="surname">McKusick</span>, <span class="firstname">Keith</span> <span class="surname">Bostic</span>, <span class="firstname">Michael</span> <span class="othername">J</span> <span class="surname">Karels</span>, and <span class="firstname">John</span> <span class="othername">S</span> <span class="surname">Quarterman</span>. </span><span class="copyright">Copyright © 1996 Addison-Wesley Publishing Company, Inc.. </span><span class="biblioid">0-201-54979-4. </span><span class="publisher"><span class="publishername">Addison-Wesley Publishing Company,
	    Inc.. </span></span><span class="citetitle"><em class="citetitle">The Design and Implementation of the 4.4 BSD
	  Operating System</em>. </span><span class="pagenums">1-2. </span></p></div></div></div><div class="index"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp55829496"></a>Index</h1></div></div></div><div xmlns:xlink="http://www.w3.org/1999/xlink" class="index"><div class="indexdiv"><h3>A</h3><dl><dt id="ientry-idp55715192">AC97, <a class="indexterm" href="#idp55714552">The AC97 Interface</a></dt><dt id="ientry-idp55338744">ATAPI, <a class="indexterm" href="#usb-protocol">USB Drivers Protocol Information</a></dt><dt id="ientry-idp53774456">atomic instructions, <a class="indexterm" href="#idp53773816">Atomic Instructions and Memory Barriers</a></dt><dt id="ientry-idp49125112">atomic operations, <a class="indexterm" href="#locking">Locking Notes</a></dt><dt id="ientry-idp49276664">atomically protected variables, <a class="indexterm" href="#locking-atomic">Atomically Protected Variables</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt id="ientry-idp49324152">Berkeley Packet Filter, <a class="indexterm" href="#idp49323512">Berkeley Packet Filter</a></dt><dt id="ientry-idp49295224">binary compatibility, <a class="indexterm" href="#kernel-objects">Kernel Objects</a></dt><dt id="ientry-idp45058424">BIOS, <a class="indexterm" href="#boot-synopsis">Synopsis</a>, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt id="ientry-idp54226552">block devices, <a class="indexterm" href="#driverbasics-block">Block Devices (Are Gone)</a>, <a class="indexterm" href="#idp55401976">Types of Device Drivers</a></dt><dt id="ientry-idp45063800">booting, <a class="indexterm" href="#boot-synopsis">Synopsis</a></dt><dt id="ientry-idp54256504">bus methods, <a class="indexterm" href="#isa-driver-basics">Basic Information</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt id="ientry-idp55723256">CardBus, <a class="indexterm" href="#pccard">PC Card</a></dt><dt id="ientry-idp54850552">CD-ROM, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt id="ientry-idp54183544">character devices, <a class="indexterm" href="#driverbasics-char">Character Devices</a>, <a class="indexterm" href="#idp55411704">Character Devices</a></dt><dt id="ientry-idp55738360">CIS, <a class="indexterm" href="#pccard-overview">Overview</a></dt><dt id="ientry-idp49302392">class, <a class="indexterm" href="#kernel-objects-term">Terminology</a></dt><dt id="ientry-idp54849400">Common Access Method (CAM), <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt id="ientry-idp53771640">concurrency, <a class="indexterm" href="#smp-intro">Introduction</a></dt><dt id="ientry-idp53889272">context switches, <a class="indexterm" href="#idp53875576">Interrupt Handling</a></dt><dt id="ientry-idp53977208">credentials, <a class="indexterm" href="#idp53976568">Credentials</a></dt><dt id="ientry-idp53917048">critical sections, <a class="indexterm" href="#idp53916408">Critical Sections</a>, <a class="indexterm" href="#idp53924856">Thread Migration</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt id="ientry-idp55746040">D-Link, <a class="indexterm" href="#pccard-overview">Overview</a></dt><dt id="ientry-idp49324664">data link layer, <a class="indexterm" href="#idp49323512">Berkeley Packet Filter</a></dt><dt id="ientry-idp49077624">DDB, <a class="indexterm" href="#idp46451320">init386()</a></dt><dt id="ientry-idp53795960">device driver, <a class="indexterm" href="#driverbasics-intro">Introduction</a>, <a class="indexterm" href="#idp55399160">Purpose of a Device Driver</a></dt><dd><dl><dt>introduction, <a class="indexterm" href="#idp55399160">Purpose of a Device Driver</a></dt><dt>ISA, <a class="indexterm" href="#isa-driver-synopsis">Synopsis</a></dt><dt>resources, <a class="indexterm" href="#isa-driver-resources">Resources</a></dt></dl></dd><dt id="ientry-idp55576312">device drivers</dt><dd><dl><dt>sound, <a class="indexterm" href="#pcm-probe-and-attach">Probing, Attaching, etc.</a></dt></dl></dd><dt id="ientry-idp53797368">device nodes, <a class="indexterm" href="#driverbasics-intro">Introduction</a></dt><dt id="ientry-idp54606456">Direct Memory Access (DMA), <a class="indexterm" href="#isa-driver-dma">DMA</a></dt><dt id="ientry-idp54316024">DMA channel, <a class="indexterm" href="#isa-driver-resources">Resources</a></dt><dt id="ientry-idp49661560">dynamic initialization, <a class="indexterm" href="#sysinit">The SYSINIT Framework</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt id="ientry-idp46392184">ELF, <a class="indexterm" href="#boot-kernel">Kernel Initialization</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt id="ientry-idp49647992">filesystem, <a class="indexterm" href="#idp49647352">Filesystem</a></dt><dt id="ientry-idp45059960">firmware, <a class="indexterm" href="#boot-synopsis">Synopsis</a></dt></dl></div><div class="indexdiv"><h3>G</h3><dl><dt id="ientry-idp49053048">Global Descriptors Table (GDT), <a class="indexterm" href="#idp46451320">init386()</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt id="ientry-idp54998520">hardware control
	    block, <a class="indexterm" href="#scsi-general">General Architecture</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt id="ientry-idp45062264">IA-32, <a class="indexterm" href="#boot-synopsis">Synopsis</a></dt><dt id="ientry-idp54851576">IDE, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt id="ientry-idp49302904">interface, <a class="indexterm" href="#kernel-objects-term">Terminology</a></dt><dt id="ientry-idp49056376">Interrupt Descriptor Table
	  (IDT), <a class="indexterm" href="#idp46451320">init386()</a></dt><dt id="ientry-idp54765176">interrupt handler, <a class="indexterm" href="#isa-driver-intr">xxx_intr</a></dt><dt id="ientry-idp53876216">interrupt handling, <a class="indexterm" href="#idp53875576">Interrupt Handling</a></dt><dt id="ientry-idp53885816">interrupt threads, <a class="indexterm" href="#idp53875576">Interrupt Handling</a></dt><dt id="ientry-idp54296440">IRQ, <a class="indexterm" href="#isa-driver-config">Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</a></dt><dt id="ientry-idp54251128">ISA, <a class="indexterm" href="#isa-driver-synopsis">Synopsis</a></dt><dd><dl><dt>probing, <a class="indexterm" href="#isa-driver-config">Configuration File and the Order of Identifying and Probing
	During Auto-Configuration</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>J</h3><dl><dt id="ientry-idp49408632">Jail, <a class="indexterm" href="#jail">The Jail Subsystem</a>, <a class="indexterm" href="#idp53986296">Jail Structures</a></dt><dd><dl><dt>Kernel Architecture, <a class="indexterm" href="#idp49471736">Kernel Space</a></dt><dt>Userland Program, <a class="indexterm" href="#idp49433464">Userland Code</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>K</h3><dl><dt id="ientry-idp49662328">kernel initialization</dt><dd><dl><dt>dynamic, <a class="indexterm" href="#sysinit">The SYSINIT Framework</a></dt></dl></dd><dt id="ientry-idp49668344">kernel linker, <a class="indexterm" href="#sysinit">The SYSINIT Framework</a></dt><dt id="ientry-idp53800440">kernel linking</dt><dd><dl><dt>dynamic, <a class="indexterm" href="#driverbasics-kld">Dynamic Kernel Linker Facility - KLD</a></dt></dl></dd><dt id="ientry-idp53801592">kernel loadable modules (KLD), <a class="indexterm" href="#driverbasics-kld">Dynamic Kernel Linker Facility - KLD</a></dt><dt id="ientry-idp54285048">kernel module, <a class="indexterm" href="#isa-driver-basics">Basic Information</a></dt><dt id="ientry-idp49667576">kernel modules, <a class="indexterm" href="#sysinit">The SYSINIT Framework</a>, <a class="indexterm" href="#idp53995256">Modules</a></dt><dd><dl><dt>listing, <a class="indexterm" href="#driverbasics-kld">Dynamic Kernel Linker Facility - KLD</a></dt><dt>loading, <a class="indexterm" href="#driverbasics-kld">Dynamic Kernel Linker Facility - KLD</a></dt><dt>unloading, <a class="indexterm" href="#driverbasics-kld">Dynamic Kernel Linker Facility - KLD</a></dt></dl></dd><dt id="ientry-idp49294200">Kernel Objects, <a class="indexterm" href="#kernel-objects">Kernel Objects</a></dt><dd><dl><dt>class, <a class="indexterm" href="#idp49371384">Creating a Class</a></dt><dt>interface, <a class="indexterm" href="#idp49338232">Creating an Interface Template</a></dt><dt>object, <a class="indexterm" href="#idp49381496">Creating an Object</a></dt></dl></dd><dt id="ientry-idp53770360">kernel synchronization, <a class="indexterm" href="#smp-intro">Introduction</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt id="ientry-idp53886712">latency, <a class="indexterm" href="#idp53875576">Interrupt Handling</a></dt><dt id="ientry-idp49674232">linker sets, <a class="indexterm" href="#sysinit-operation">SYSINIT Operation</a></dt><dt id="ientry-idp55745528">Linksys, <a class="indexterm" href="#pccard-overview">Overview</a></dt><dt id="ientry-idp49123064">locking, <a class="indexterm" href="#locking">Locking Notes</a></dt><dt id="ientry-idp49124600">lockmgr, <a class="indexterm" href="#locking">Locking Notes</a></dt><dt id="ientry-idp49183864">locks</dt><dd><dl><dt>allproc_lock, <a class="indexterm" href="#locking-sx">Shared Exclusive Locks</a></dt><dt>callout_lock, <a class="indexterm" href="#locking-mutexes">Mutexes</a></dt><dt>Giant, <a class="indexterm" href="#locking-mutexes">Mutexes</a></dt><dt>proctree_lock, <a class="indexterm" href="#locking-sx">Shared Exclusive Locks</a></dt><dt>sched_lock, <a class="indexterm" href="#locking-mutexes">Mutexes</a></dt><dt>shared exclusive, <a class="indexterm" href="#locking-sx">Shared Exclusive Locks</a></dt><dt>vm86pcb_lock, <a class="indexterm" href="#locking-mutexes">Mutexes</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>M</h3><dl><dt id="ientry-idp53991160">MAC, <a class="indexterm" href="#idp53990520">MAC Framework</a></dt><dt id="ientry-idp45176184">MBR, <a class="indexterm" href="#boot-boot0">The Master Boot Record (boot0)</a></dt><dt id="ientry-idp53774968">memory barriers, <a class="indexterm" href="#idp53773816">Atomic Instructions and Memory Barriers</a></dt><dt id="ientry-idp49297784">method, <a class="indexterm" href="#kernel-objects-term">Terminology</a></dt><dt id="ientry-idp49123576">multi-processing, <a class="indexterm" href="#locking">Locking Notes</a></dt><dt id="ientry-idp54091000">mutex</dt><dd><dl><dt>sleep, <a class="indexterm" href="#idp54092280">Sleep Mutexes</a></dt><dt>spin, <a class="indexterm" href="#idp54090360">Spin Mutexes</a></dt></dl></dd><dt id="ientry-idp49124088">mutexes, <a class="indexterm" href="#locking">Locking Notes</a></dt><dd><dl><dt>spin, <a class="indexterm" href="#idp53916408">Critical Sections</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>N</h3><dl><dt id="ientry-idp55288952">NetBSD, <a class="indexterm" href="#usb-intro">Introduction</a></dt><dt id="ientry-idp55740920">NetGear, <a class="indexterm" href="#pccard-overview">Overview</a></dt><dt id="ientry-idp54242296">network devices, <a class="indexterm" href="#driverbasics-net">Network Drivers</a></dt><dt id="ientry-idp53999352">Newbus, <a class="indexterm" href="#idp53998712">Newbus Device Tree</a>, <a class="indexterm" href="#newbus-overview">Overview of Newbus</a></dt></dl></div><div class="indexdiv"><h3>O</h3><dl><dt id="ientry-idp49297272">object, <a class="indexterm" href="#kernel-objects-term">Terminology</a></dt><dt id="ientry-idp49294712">Object-Oriented, <a class="indexterm" href="#kernel-objects">Kernel Objects</a></dt><dt id="ientry-idp54255608">object-oriented, <a class="indexterm" href="#isa-driver-basics">Basic Information</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt id="ientry-idp53725432">page tables, <a class="indexterm" href="#vm-pagetables">Mapping Page Tables&#8212;vm_map_t,
	vm_entry_t</a></dt><dt id="ientry-idp53698040">paging queues, <a class="indexterm" href="#vm-physmem">Management of Physical
      Memory&#8212;vm_page_t</a></dt><dt id="ientry-idp49044856">parameters, <a class="indexterm" href="#idp46451320">init386()</a></dt><dt id="ientry-idp55722744">PC Card, <a class="indexterm" href="#pccard">PC Card</a></dt><dd><dl><dt>probe, <a class="indexterm" href="#pccard-probe">Sample Probe Routine</a></dt></dl></dd><dt id="ientry-idp54770680">PCI bus, <a class="indexterm" href="#pci">PCI Devices</a></dt><dd><dl><dt>Base Address
	Registers, <a class="indexterm" href="#idp54799224">Base Address Registers</a></dt><dt>DMA, <a class="indexterm" href="#idp54826744">DMA</a></dt><dt>interrupts, <a class="indexterm" href="#idp54822904">Interrupts</a></dt><dt>resources, <a class="indexterm" href="#pci-bus">Bus Resources</a></dt></dl></dd><dt id="ientry-idp53688952">physical memory, <a class="indexterm" href="#vm-physmem">Management of Physical
      Memory&#8212;vm_page_t</a></dt><dt id="ientry-idp54286712">PnP, <a class="indexterm" href="#isa-driver-basics">Basic Information</a></dt><dt id="ientry-idp45060856">POST, <a class="indexterm" href="#boot-synopsis">Synopsis</a></dt><dt id="ientry-idp53887224">preemption, <a class="indexterm" href="#idp53875576">Interrupt Handling</a></dt><dt id="ientry-idp49327864">protocols, <a class="indexterm" href="#idp49327224">Protocols</a></dt><dt id="ientry-idp53796472">pseudo-device, <a class="indexterm" href="#driverbasics-intro">Introduction</a></dt><dt id="ientry-idp49677432">pseudo-devices, <a class="indexterm" href="#sysinit-operation">SYSINIT Operation</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt id="ientry-idp53841784">read locks, <a class="indexterm" href="#idp53841144">Read Locks Versus Write Locks</a></dt><dt id="ientry-idp54313592">resources, <a class="indexterm" href="#isa-driver-resources">Resources</a></dt><dt id="ientry-idp49409144">root, <a class="indexterm" href="#jail">The Jail Subsystem</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt id="ientry-idp54011256">scheduler, <a class="indexterm" href="#idp54010616">Scheduler</a></dt><dt id="ientry-idp54838392">SCSI, <a class="indexterm" href="#scsi-synopsis">Synopsis</a></dt><dd><dl><dt>adapter, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt>BIOS, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt>bus, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt>errors, <a class="indexterm" href="#scsi-errors">Errors Summary</a></dt><dt>interrupts, <a class="indexterm" href="#scsi-interrupts">Interrupts</a></dt></dl></dd><dt id="ientry-idp49408120">security, <a class="indexterm" href="#jail">The Jail Subsystem</a></dt><dt id="ientry-idp49599096">semaphores, <a class="indexterm" href="#idp49581688">SysV IPC</a></dt><dt id="ientry-idp49622264">shared memory, <a class="indexterm" href="#idp49581688">SysV IPC</a></dt><dt id="ientry-idp53769848">SMP Next Generation, <a class="indexterm" href="#smp-intro">Introduction</a></dt><dt id="ientry-idp49121784">SMP Next Generation Project, <a class="indexterm" href="#locking">Locking Notes</a></dt><dt id="ientry-idp49319288">sockets, <a class="indexterm" href="#idp49318648">Sockets</a></dt><dt id="ientry-idp54283640">softc, <a class="indexterm" href="#isa-driver-basics">Basic Information</a></dt><dt id="ientry-idp55536504">sound subsystem, <a class="indexterm" href="#oss-intro">Introduction</a></dt><dt id="ientry-idp53919480">spin mutexes, <a class="indexterm" href="#idp53916408">Critical Sections</a></dt><dt id="ientry-idp53744248">swap partition, <a class="indexterm" href="#vm-tuning">Tuning the FreeBSD VM System</a></dt><dt id="ientry-idp49475448">sysctl, <a class="indexterm" href="#idp49474808">Sysctls</a></dt><dt id="ientry-idp49660792">SYSINIT, <a class="indexterm" href="#sysinit">The SYSINIT Framework</a></dt><dt id="ientry-idp49085944">sysinit objects, <a class="indexterm" href="#idp49083256">mi_startup()</a></dt><dt id="ientry-idp55538552">system call interface, <a class="indexterm" href="#oss-intro">Introduction</a></dt><dt id="ientry-idp45064696">system initialization, <a class="indexterm" href="#boot-synopsis">Synopsis</a></dt><dt id="ientry-idp49582328">System V IPC, <a class="indexterm" href="#idp49581688">SysV IPC</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt id="ientry-idp54851064">tape, <a class="indexterm" href="#scsi-general">General Architecture</a></dt><dt id="ientry-idp53925496">thread migration, <a class="indexterm" href="#idp53924856">Thread Migration</a></dt><dt id="ientry-idp54087544">turnstiles, <a class="indexterm" href="#idp54086904">Turnstiles</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt id="ientry-idp53700088">unified buffer cache, <a class="indexterm" href="#vm-cache">The Unified Buffer
      Cache&#8212;vm_object_t</a></dt><dt id="ientry-idp55288440">Universal Serial Bus
	(USB), <a class="indexterm" href="#usb-intro">Introduction</a></dt><dt id="ientry-idp55321720">USB</dt><dd><dl><dt>disconnect, <a class="indexterm" href="#idp54867320">Device Disconnect and Detach</a></dt><dt>firmware, <a class="indexterm" href="#usb-protocol">USB Drivers Protocol Information</a></dt><dt>host
	controllers, <a class="indexterm" href="#usb-hc">Host Controllers</a></dt><dt>OHCI, <a class="indexterm" href="#idp55042296">OHCI</a></dt><dt>probe, <a class="indexterm" href="#usb-devprobe">Device Probe and Attach</a></dt><dt>UHCI, <a class="indexterm" href="#idp55325176">UHCI</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>V</h3><dl><dt id="ientry-idp53688440">virtual memory, <a class="indexterm" href="#vm-physmem">Management of Physical
      Memory&#8212;vm_page_t</a></dt><dt id="ientry-idp46093432">virtual v86 mode, <a class="indexterm" href="#btx-server">The BTX Server</a></dt><dt id="ientry-idp53700600">vm_object_t structure, <a class="indexterm" href="#vm-cache">The Unified Buffer
      Cache&#8212;vm_object_t</a></dt><dt id="ientry-idp53689464">vm_page_t structure, <a class="indexterm" href="#vm-physmem">Management of Physical
      Memory&#8212;vm_page_t</a></dt><dt id="ientry-idp53721464">vnode, <a class="indexterm" href="#vm-fileio">Filesystem I/O&#8212;struct buf</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt id="ientry-idp54115832">witness, <a class="indexterm" href="#idp54115192">Witness</a></dt><dt id="ientry-idp53842296">write locks, <a class="indexterm" href="#idp53841144">Read Locks Versus Write Locks</a></dt></dl></div></div></div></div></body></html>