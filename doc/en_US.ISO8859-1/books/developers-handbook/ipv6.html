<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Chapter 8. IPv6 Internals</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="ipc.html" title="Part II. Interprocess Communication" /><link rel="prev" href="sockets-concurrent-servers.html" title="7.7. Concurrent Servers" /><link rel="next" href="kernel.html" title="Part III. Kernel" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 8. IPv6 Internals</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sockets-concurrent-servers.html">Prev</a> </td><th width="60%" align="center">Part II. Interprocess Communication</th><td width="20%" align="right"> <a accesskey="n" href="kernel.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6"></a>Chapter 8. IPv6 Internals</h2></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="ipv6.html#ipv6-implementation">8.1. IPv6/IPsec Implementation</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ipv6-implementation"></a>8.1. IPv6/IPsec Implementation</h2></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Yoshinobu</span> <span class="surname">Inoue</span></span>. </span></div></div></div><p>This section should explain IPv6 and IPsec related
      implementation internals.  These functionalities are derived
      from <a class="link" href="http://www.kame.net/" target="_top">KAME
	project</a></p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6details"></a>8.1.1. IPv6</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52407032"></a>8.1.1.1. Conformance</h4></div></div></div><p>The IPv6 related functions conforms, or tries to conform
	  to the latest set of IPv6 specifications.  For future
	  reference we list some of the relevant documents below
	  (<span class="emphasis"><em>NOTE</em></span>: this is not a complete list -
	  this is too hard to maintain...).</p><p>For details please refer to specific chapter in the
	  document, RFCs, manual pages, or comments in the source
	  code.</p><p>Conformance tests have been performed on the KAME STABLE
	  kit at TAHI project.  Results can be viewed at <code class="uri"><a class="uri" href="http://www.tahi.org/report/KAME/" target="_top">http://www.tahi.org/report/KAME/</a></code>.
	  We also attended University of New Hampshire IOL tests (<code class="uri"><a class="uri" href="http://www.iol.unh.edu/" target="_top">http://www.iol.unh.edu/</a></code>)
	  in the past, with our past snapshots.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>RFC1639: FTP Operation Over Big Address Records
	      (FOOBAR)</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>RFC2428 is preferred over RFC1639.  FTP clients
		  will first try RFC2428, then RFC1639 if
		  failed.</p></li></ul></div></li><li class="listitem"><p>RFC1886: DNS Extensions to support IPv6</p></li><li class="listitem"><p>RFC1933: Transition Mechanisms for IPv6 Hosts and
	      Routers</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>IPv4 compatible address is not supported.</p></li><li class="listitem"><p>automatic tunneling (described in 4.3 of this
		  RFC) is not supported.</p></li><li class="listitem"><p><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gif</span>(4)</span></a> interface implements
		  IPv[46]-over-IPv[46] tunnel in a generic way, and it
		  covers "configured tunnel" described in the spec.
		  See <a class="link" href="ipv6.html#gif" title="8.1.1.5. Generic Tunnel Interface">23.5.1.5</a> in this
		  document for details.</p></li></ul></div></li><li class="listitem"><p>RFC1981: Path MTU Discovery for IPv6</p></li><li class="listitem"><p>RFC2080: RIPng for IPv6</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>usr.sbin/route6d support this.</p></li></ul></div></li><li class="listitem"><p>RFC2292: Advanced Sockets API for IPv6</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>For supported library functions/kernel APIs, see
		  <code class="filename">sys/netinet6/ADVAPI</code>.</p></li></ul></div></li><li class="listitem"><p>RFC2362: Protocol Independent Multicast-Sparse Mode
	      (PIM-SM)</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>RFC2362 defines packet formats for PIM-SM.
		  <code class="filename">draft-ietf-pim-ipv6-01.txt</code> is
		  written based on this.</p></li></ul></div></li><li class="listitem"><p>RFC2373: IPv6 Addressing Architecture</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>supports node required addresses, and conforms
		  to the scope requirement.</p></li></ul></div></li><li class="listitem"><p>RFC2374: An IPv6 Aggregatable Global Unicast Address
	      Format</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>supports 64-bit length of Interface ID.</p></li></ul></div></li><li class="listitem"><p>RFC2375: IPv6 Multicast Address Assignments</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Userland applications use the well-known
		  addresses assigned in the RFC.</p></li></ul></div></li><li class="listitem"><p>RFC2428: FTP Extensions for IPv6 and NATs</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>RFC2428 is preferred over RFC1639.  FTP clients
		  will first try RFC2428, then RFC1639 if
		  failed.</p></li></ul></div></li><li class="listitem"><p>RFC2460: IPv6 specification</p></li><li class="listitem"><p>RFC2461: Neighbor discovery for IPv6</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>See <a class="link" href="ipv6.html#neighbor-discovery" title="8.1.1.2. Neighbor Discovery">23.5.1.2</a> in
		  this document for details.</p></li></ul></div></li><li class="listitem"><p>RFC2462: IPv6 Stateless Address
	      Autoconfiguration</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>See <a class="link" href="ipv6.html#ipv6-pnp" title="8.1.1.4. Plug and Play">23.5.1.4</a> in
		  this document for details.</p></li></ul></div></li><li class="listitem"><p>RFC2463: ICMPv6 for IPv6 specification</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>See <a class="link" href="ipv6.html#icmpv6" title="8.1.1.9. ICMPv6">23.5.1.9</a> in
		  this document for details.</p></li></ul></div></li><li class="listitem"><p>RFC2464: Transmission of IPv6 Packets over Ethernet
	      Networks</p></li><li class="listitem"><p>RFC2465: MIB for IPv6: Textual Conventions and
	      General Group</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Necessary statistics are gathered by the kernel.
		  Actual IPv6 MIB support is provided as a patchkit
		  for ucd-snmp.</p></li></ul></div></li><li class="listitem"><p>RFC2466: MIB for IPv6: ICMPv6 group</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Necessary statistics are gathered by the kernel.
		  Actual IPv6 MIB support is provided as patchkit for
		  ucd-snmp.</p></li></ul></div></li><li class="listitem"><p>RFC2467: Transmission of IPv6 Packets over FDDI
	      Networks</p></li><li class="listitem"><p>RFC2497: Transmission of IPv6 packet over ARCnet
	      Networks</p></li><li class="listitem"><p>RFC2553: Basic Socket Interface Extensions for
	      IPv6</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>IPv4 mapped address (3.7) and special behavior
		  of IPv6 wildcard bind socket (3.8) are supported.
		  See <a class="link" href="ipv6.html#ipv6-wildcard-socket" title="8.1.1.12. IPv4 Mapped Address and IPv6 Wildcard Socket">23.5.1.12</a> in
		  this document for details.</p></li></ul></div></li><li class="listitem"><p>RFC2675: IPv6 Jumbograms</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>See <a class="link" href="ipv6.html#ipv6-jumbo" title="8.1.1.7. Jumbo Payload">23.5.1.7</a>
		  in this document for details.</p></li></ul></div></li><li class="listitem"><p>RFC2710: Multicast Listener Discovery for
	      IPv6</p></li><li class="listitem"><p>RFC2711: IPv6 router alert option</p></li><li class="listitem"><p><code class="filename">draft-ietf-ipngwg-router-renum-08</code>:
	      Router renumbering for IPv6</p></li><li class="listitem"><p><code class="filename">draft-ietf-ipngwg-icmp-namelookups-02</code>:
	      IPv6 Name Lookups Through ICMP</p></li><li class="listitem"><p><code class="filename">draft-ietf-ipngwg-icmp-name-lookups-03</code>:
	      IPv6 Name Lookups Through ICMP</p></li><li class="listitem"><p><code class="filename">draft-ietf-pim-ipv6-01.txt</code>: PIM
	      for IPv6</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pim6dd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pim6dd</span>(8)</span></a> implements dense mode.
		  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pim6sd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pim6sd</span>(8)</span></a> implements sparse mode.</p></li></ul></div></li><li class="listitem"><p><code class="filename">draft-itojun-ipv6-tcp-to-anycast-00</code>:
	      Disconnecting TCP connection toward IPv6 anycast
	      address</p></li><li class="listitem"><p><code class="filename">draft-yamamoto-wideipv6-comm-model-00</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>See <a class="link" href="ipv6.html#ipv6-sas" title="8.1.1.6. Source Address Selection">23.5.1.6</a> in
		  this document for details.</p></li></ul></div></li><li class="listitem"><p><code class="filename">draft-ietf-ipngwg-scopedaddr-format-00.txt</code>:
	      An Extension of Format for IPv6 Scoped Addresses</p></li></ul></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="neighbor-discovery"></a>8.1.1.2. Neighbor Discovery</h4></div></div></div><p>Neighbor Discovery is fairly stable.  Currently Address
	  Resolution, Duplicated Address Detection, and Neighbor
	  Unreachability Detection are supported.  In the near future
	  we will be adding Proxy Neighbor Advertisement support in
	  the kernel and Unsolicited Neighbor Advertisement
	  transmission command as admin tool.</p><p>If DAD fails, the address will be marked "duplicated"
	  and message will be generated to syslog (and usually to
	  console).  The "duplicated" mark can be checked with
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>.  It is administrators' responsibility to
	  check for and recover from DAD failures.  The behavior
	  should be improved in the near future.</p><p>Some of the network driver loops multicast packets back
	  to itself, even if instructed not to do so (especially in
	  promiscuous mode).  In such cases DAD may fail, because DAD
	  engine sees inbound NS packet (actually from the node
	  itself) and considers it as a sign of duplicate.  You may
	  want to look at #if condition marked "heuristics" in
	  sys/netinet6/nd6_nbr.c:nd6_dad_timer() as workaround (note
	  that the code fragment in "heuristics" section is not spec
	  conformant).</p><p>Neighbor Discovery specification (RFC2461) does not talk
	  about neighbor cache handling in the following cases:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>when there was no neighbor cache entry, node
	      received unsolicited RS/NS/NA/redirect packet without
	      link-layer address</p></li><li class="listitem"><p>neighbor cache handling on medium without link-layer
	      address (we need a neighbor cache entry for IsRouter
	      bit)</p></li></ol></div><p>For first case, we implemented workaround based on
	  discussions on IETF ipngwg mailing list.  For more details,
	  see the comments in the source code and email thread started
	  from (IPng 7155), dated Feb 6 1999.</p><p>IPv6 on-link determination rule (RFC2461) is quite
	  different from assumptions in BSD network code.  At this
	  moment, no on-link determination rule is supported where
	  default router list is empty (RFC2461, section 5.2, last
	  sentence in 2nd paragraph - note that the spec misuse the
	  word "host" and "node" in several places in the
	  section).</p><p>To avoid possible DoS attacks and infinite loops, only
	  10 options on ND packet is accepted now.  Therefore, if you
	  have 20 prefix options attached to RA, only the first 10
	  prefixes will be recognized.  If this troubles you, please
	  ask it on FREEBSD-CURRENT mailing list and/or modify
	  nd6_maxndopt in <code class="filename">sys/netinet6/nd6.c</code>.  If
	  there are high demands we may provide sysctl knob for the
	  variable.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6-scope-index"></a>8.1.1.3. Scope Index</h4></div></div></div><p>IPv6 uses scoped addresses.  Therefore, it is very
	  important to specify scope index (interface index for
	  link-local address, or site index for site-local address)
	  with an IPv6 address.  Without scope index, scoped IPv6
	  address is ambiguous to the kernel, and kernel will not be
	  able to determine the outbound interface for a
	  packet.</p><p>Ordinary userland applications should use advanced API
	  (RFC2292) to specify scope index, or interface index.  For
	  similar purpose, sin6_scope_id member in sockaddr_in6
	  structure is defined in RFC2553.  However, the semantics for
	  sin6_scope_id is rather vague.  If you care about
	  portability of your application, we suggest you to use
	  advanced API rather than sin6_scope_id.</p><p>In the kernel, an interface index for link-local scoped
	  address is embedded into 2nd 16bit-word (3rd and 4th byte)
	  in IPv6 address.  For example, you may see something
	  like:</p><pre class="screen">	fe80:1::200:f8ff:fe01:6317</pre><p>in the routing table and interface address structure
	  (struct in6_ifaddr).  The address above is a link-local
	  unicast address which belongs to a network interface whose
	  interface identifier is 1.  The embedded index enables us to
	  identify IPv6 link local addresses over multiple interfaces
	  effectively and with only a little code change.</p><p>Routing daemons and configuration programs, like
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=route6d&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">route6d</span>(8)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>, will need to
	  manipulate the "embedded" scope index.  These programs use
	  routing sockets and ioctls (like SIOCGIFADDR_IN6) and the
	  kernel API will return IPv6 addresses with 2nd 16bit-word
	  filled in.  The APIs are for manipulating kernel internal
	  structure.  Programs that use these APIs have to be prepared
	  about differences in kernels anyway.</p><p>When you specify scoped address to the command line,
	  NEVER write the embedded form (such as ff02:1::1 or
	  fe80:2::fedc).  This is not supposed to work.  Always use
	  standard form, like ff02::1 or fe80::fedc, with command line
	  option for specifying interface (like <code class="command">ping6 -I ne0
	    ff02::1</code>).  In general, if a command does not
	  have command line option to specify outgoing interface, that
	  command is not ready to accept scoped address.  This may
	  seem to be opposite from IPv6's premise to support "dentist
	  office" situation.  We believe that specifications need some
	  improvements for this.</p><p>Some of the userland tools support extended numeric IPv6
	  syntax, as documented in
	  <code class="filename">draft-ietf-ipngwg-scopedaddr-format-00.txt</code>.
	  You can specify outgoing link, by using name of the outgoing
	  interface like "fe80::1%ne0".  This way you will be able to
	  specify link-local scoped address without much
	  trouble.</p><p>To use this extension in your program, you will need to
	  use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a>, and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getnameinfo</span>(3)</span></a> with
	  NI_WITHSCOPEID.  The implementation currently assumes 1-to-1
	  relationship between a link and an interface, which is
	  stronger than what specs say.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6-pnp"></a>8.1.1.4. Plug and Play</h4></div></div></div><p>Most of the IPv6 stateless address autoconfiguration is
	  implemented in the kernel.  Neighbor Discovery functions are
	  implemented in the kernel as a whole.  Router Advertisement
	  (RA) input for hosts is implemented in the kernel.  Router
	  Solicitation (RS) output for endhosts, RS input for routers,
	  and RA output for routers are implemented in the
	  userland.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52522488"></a>8.1.1.4.1. Assignment of link-local, and special
	    addresses</h5></div></div></div><p>IPv6 link-local address is generated from IEEE802
	    address (Ethernet MAC address).  Each of interface is
	    assigned an IPv6 link-local address automatically, when
	    the interface becomes up (IFF_UP).  Also, direct route for
	    the link-local address is added to routing table.</p><p>Here is an output of netstat command:</p><pre class="screen">Internet6:
Destination                   Gateway                   Flags      Netif Expire
fe80:1::%ed0/64               link#1                    UC          ed0
fe80:2::%ep0/64               link#2                    UC          ep0</pre><p>Interfaces that has no IEEE802 address (pseudo
	    interfaces like tunnel interfaces, or ppp interfaces) will
	    borrow IEEE802 address from other interfaces, such as
	    Ethernet interfaces, whenever possible.  If there is no
	    IEEE802 hardware attached, a last resort pseudo-random
	    value, MD5(hostname), will be used as source of link-local
	    address.  If it is not suitable for your usage, you will
	    need to configure the link-local address manually.</p><p>If an interface is not capable of handling IPv6 (such
	    as lack of multicast support), link-local address will not
	    be assigned to that interface.  See section 2 for
	    details.</p><p>Each interface joins the solicited multicast address
	    and the link-local all-nodes multicast addresses (e.g.,
	    fe80::1:ff01:6317 and ff02::1, respectively, on the link
	    the interface is attached).  In addition to a link-local
	    address, the loopback address (::1) will be assigned to
	    the loopback interface.  Also, ::1/128 and ff01::/32 are
	    automatically added to routing table, and loopback
	    interface joins node-local multicast group ff01::1.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52525560"></a>8.1.1.4.2. Stateless address autoconfiguration on Hosts</h5></div></div></div><p>In IPv6 specification, nodes are separated into two
	    categories: <span class="emphasis"><em>routers</em></span> and
	    <span class="emphasis"><em>hosts</em></span>.  Routers forward packets
	    addressed to others, hosts does not forward the packets.
	    net.inet6.ip6.forwarding defines whether this node is
	    router or host (router if it is 1, host if it is
	    0).</p><p>When a host hears Router Advertisement from the
	    router, a host may autoconfigure itself by stateless
	    address autoconfiguration.  This behavior can be
	    controlled by net.inet6.ip6.accept_rtadv (host
	    autoconfigures itself if it is set to 1).  By
	    autoconfiguration, network address prefix for the
	    receiving interface (usually global address prefix) is
	    added.  Default route is also configured.  Routers
	    periodically generate Router Advertisement packets.  To
	    request an adjacent router to generate RA packet, a host
	    can transmit Router Solicitation.  To generate a RS packet
	    at any time, use the <span class="emphasis"><em>rtsol</em></span> command.
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rtsold</span>(8)</span></a> daemon is also available.  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rtsold</span>(8)</span></a>
	    generates Router Solicitation whenever necessary, and it
	    works great for nomadic usage (notebooks/laptops).  If one
	    wishes to ignore Router Advertisements, use sysctl to set
	    net.inet6.ip6.accept_rtadv to 0.</p><p>To generate Router Advertisement from a router, use
	    the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rtadvd</span>(8)</span></a> daemon.</p><p>Note that, IPv6 specification assumes the following
	    items, and nonconforming cases are left
	    unspecified:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Only hosts will listen to router
		advertisements</p></li><li class="listitem"><p>Hosts have single network interface (except
		loopback)</p></li></ul></div><p>Therefore, this is unwise to enable
	    net.inet6.ip6.accept_rtadv on routers, or multi-interface
	    host.  A misconfigured node can behave strange
	    (nonconforming configuration allowed for those who would
	    like to do some experiments).</p><p>To summarize the sysctl knob:</p><pre class="screen">	accept_rtadv	forwarding	role of the node
	---		---		---
	0		0		host (to be manually configured)
	0		1		router
	1		0		autoconfigured host
					(spec assumes that host has single
					interface only, autoconfigured host
					with multiple interface is
					out-of-scope)
	1		1		invalid, or experimental
					(out-of-scope of spec)</pre><p>RFC2462 has validation rule against incoming RA prefix
	    information option, in 5.5.3 (e).  This is to protect
	    hosts from malicious (or misconfigured) routers that
	    advertise very short prefix lifetime.  There was an update
	    from Jim Bound to ipngwg mailing list (look for "(ipng
	    6712)" in the archive) and it is implemented Jim's
	    update.</p><p>See <a class="link" href="ipv6.html#neighbor-discovery" title="8.1.1.2. Neighbor Discovery">23.5.1.2</a>
	    in the document for relationship between DAD and
	    autoconfiguration.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="gif"></a>8.1.1.5. Generic Tunnel Interface</h4></div></div></div><p>GIF (Generic InterFace) is a pseudo interface for
	  configured tunnel.  Details are described in <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gif</span>(4)</span></a>.
	  Currently</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>v6 in v6</p></li><li class="listitem"><p>v6 in v4</p></li><li class="listitem"><p>v4 in v6</p></li><li class="listitem"><p>v4 in v4</p></li></ul></div><p>are available.  Use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gifconfig</span>(8)</span></a> to assign physical
	  (outer) source and destination address to gif interfaces.
	  Configuration that uses same address family for inner and
	  outer IP header (v4 in v4, or v6 in v6) is dangerous.  It is
	  very easy to configure interfaces and routing tables to
	  perform infinite level of tunneling.  <span class="emphasis"><em>Please be
	    warned</em></span>.</p><p>gif can be configured to be ECN-friendly.  See <a class="link" href="ipv6.html#ipsec-ecn" title="8.1.4.5. ECN Consideration on IPsec Tunnels">23.5.4.5</a> for ECN-friendliness
	  of tunnels, and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gif</span>(4)</span></a> for how to configure.</p><p>If you would like to configure an IPv4-in-IPv6 tunnel
	  with gif interface, read <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gif</span>(4)</span></a> carefully.  You will
	  need to remove IPv6 link-local address automatically
	  assigned to the gif interface.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6-sas"></a>8.1.1.6. Source Address Selection</h4></div></div></div><p>Current source selection rule is scope oriented (there
	  are some exceptions - see below).  For a given destination,
	  a source IPv6 address is selected by the following
	  rule:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If the source address is explicitly specified by the
	      user (e.g.,  via the advanced API), the specified
	      address is used.</p></li><li class="listitem"><p>If there is an address assigned to the outgoing
	      interface (which is usually determined by looking up the
	      routing table) that has the same scope as the
	      destination address, the address is used.</p><p>This is the most typical case.</p></li><li class="listitem"><p>If there is no address that satisfies the above
	      condition, choose a global address assigned to one of
	      the interfaces on the sending node.</p></li><li class="listitem"><p>If there is no address that satisfies the above
	      condition, and destination address is site local scope,
	      choose a site local address assigned to one of the
	      interfaces on the sending node.</p></li><li class="listitem"><p>If there is no address that satisfies the above
	      condition, choose the address associated with the
	      routing table entry for the destination.  This is the
	      last resort, which may cause scope violation.</p></li></ol></div><p>For instance, ::1 is selected for ff01::1,
	  fe80:1::200:f8ff:fe01:6317 for fe80:1::2a0:24ff:feab:839b
	  (note that embedded interface index - described in <a class="link" href="ipv6.html#ipv6-scope-index" title="8.1.1.3. Scope Index">23.5.1.3</a> - helps us
	  choose the right source address.  Those embedded indices
	  will not be on the wire).  If the outgoing interface has
	  multiple address for the scope, a source is selected longest
	  match basis (rule 3).  Suppose
	  2001:0DB8:808:1:200:f8ff:fe01:6317 and
	  2001:0DB8:9:124:200:f8ff:fe01:6317 are given to the outgoing
	  interface.  2001:0DB8:808:1:200:f8ff:fe01:6317 is chosen as
	  the source for the destination 2001:0DB8:800::1.</p><p>Note that the above rule is not documented in the IPv6
	  spec.  It is considered "up to implementation" item.  There
	  are some cases where we do not use the above rule.  One
	  example is connected TCP session, and we use the address
	  kept in tcb as the source.  Another example is source
	  address for Neighbor Advertisement.  Under the spec (RFC2461
	  7.2.2) NA's source should be the target address of the
	  corresponding NS's target.  In this case we follow the spec
	  rather than the above longest-match rule.</p><p>For new connections (when rule 1 does not apply),
	  deprecated addresses (addresses with preferred lifetime = 0)
	  will not be chosen as source address if other choices are
	  available.  If no other choices are available, deprecated
	  address will be used as a last resort.  If there are
	  multiple choice of deprecated addresses, the above scope
	  rule will be used to choose from those deprecated addresses.
	  If you would like to prohibit the use of deprecated address
	  for some reason, configure net.inet6.ip6.use_deprecated to
	  0.  The issue related to deprecated address is described in
	  RFC2462 5.5.4 (NOTE: there is some debate underway in IETF
	  ipngwg on how to use "deprecated" address).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6-jumbo"></a>8.1.1.7. Jumbo Payload</h4></div></div></div><p>The Jumbo Payload hop-by-hop option is implemented and
	  can be used to send IPv6 packets with payloads longer than
	  65,535 octets.  But currently no physical interface whose
	  MTU is more than 65,535 is supported, so such payloads can
	  be seen only on the loopback interface (i.e., lo0).</p><p>If you want to try jumbo payloads, you first have to
	  reconfigure the kernel so that the MTU of the loopback
	  interface is more than 65,535 bytes; add the following to
	  the kernel configuration file:</p><p><code class="literal">options		"LARGE_LOMTU"		#To
	    test jumbo payload</code></p><p>and recompile the new kernel.</p><p>Then you can test jumbo payloads by the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ping6</span>(8)</span></a>
	  command with -b and -s options.  The -b option must be
	  specified to enlarge the size of the socket buffer and the
	  -s option specifies the length of the packet, which should
	  be more than 65,535.  For example, type as follows:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ping6 -b 70000 -s 68000 ::1</code></strong></pre><p>The IPv6 specification requires that the Jumbo Payload
	  option must not be used in a packet that carries a fragment
	  header.  If this condition is broken, an ICMPv6 Parameter
	  Problem message must be sent to the sender.  specification
	  is followed, but you cannot usually see an ICMPv6 error
	  caused by this requirement.</p><p>When an IPv6 packet is received, the frame length is
	  checked and compared to the length specified in the payload
	  length field of the IPv6 header or in the value of the Jumbo
	  Payload option, if any.  If the former is shorter than the
	  latter, the packet is discarded and statistics are
	  incremented.  You can see the statistics as output of
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">netstat</span>(8)</span></a> command with `-s -p ip6' option:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -s -p ip6</code></strong>
	  ip6:
		(snip)
		1 with data size &lt; data length</pre><p>So, kernel does not send an ICMPv6 error unless the
	  erroneous packet is an actual Jumbo Payload, that is, its
	  packet size is more than 65,535 bytes.  As described above,
	  currently no physical interface with such a huge MTU is
	  supported, so it rarely returns an ICMPv6 error.</p><p>TCP/UDP over jumbogram is not supported at this moment.
	  This is because we have no medium (other than loopback) to
	  test this.  Contact us if you need this.</p><p>IPsec does not work on jumbograms.  This is due to some
	  specification twists in supporting AH with jumbograms (AH
	  header size influences payload length, and this makes it
	  real hard to authenticate inbound packet with jumbo payload
	  option as well as AH).</p><p>There are fundamental issues in *BSD support for
	  jumbograms.  We would like to address those, but we need
	  more time to finalize these.  To name a few:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>mbuf pkthdr.len field is typed as "int" in 4.4BSD,
	      so it will not hold jumbogram with len &gt; 2G on 32bit
	      architecture CPUs.  If we would like to support
	      jumbogram properly, the field must be expanded to hold
	      4G + IPv6 header + link-layer header.  Therefore, it
	      must be expanded to at least int64_t (u_int32_t is NOT
	      enough).</p></li><li class="listitem"><p>We mistakingly use "int" to hold packet length in
	      many places.  We need to convert them into larger
	      integral type.  It needs a great care, as we may
	      experience overflow during packet length
	      computation.</p></li><li class="listitem"><p>We mistakingly check for ip6_plen field of IPv6
	      header for packet payload length in various places.  We
	      should be checking mbuf pkthdr.len instead.  ip6_input()
	      will perform sanity check on jumbo payload option on
	      input, and we can safely use mbuf pkthdr.len
	      afterwards.</p></li><li class="listitem"><p>TCP code needs a careful update in bunch of places,
	      of course.</p></li></ul></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52614648"></a>8.1.1.8. Loop Prevention in Header Processing</h4></div></div></div><p>IPv6 specification allows arbitrary number of extension
	  headers to be placed onto packets.  If we implement IPv6
	  packet processing code in the way BSD IPv4 code is
	  implemented, kernel stack may overflow due to long function
	  call chain.  sys/netinet6 code is carefully designed to
	  avoid kernel stack overflow.  Because of this, sys/netinet6
	  code defines its own protocol switch structure, as "struct
	  ip6protosw" (see
	  <code class="filename">netinet6/ip6protosw.h</code>).  There is no
	  such update to IPv4 part (sys/netinet) for compatibility,
	  but small change is added to its pr_input() prototype.  So
	  "struct ipprotosw" is also defined.  Because of this, if you
	  receive IPsec-over-IPv4 packet with massive number of IPsec
	  headers, kernel stack may blow up.  IPsec-over-IPv6 is okay.
	  (Off-course, for those all IPsec headers to be processed,
	  each such IPsec header must pass each IPsec check.  So an
	  anonymous attacker will not be able to do such an
	  attack.)</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="icmpv6"></a>8.1.1.9. ICMPv6</h4></div></div></div><p>After RFC2463 was published, IETF ipngwg has decided to
	  disallow ICMPv6 error packet against ICMPv6 redirect, to
	  prevent ICMPv6 storm on a network medium.  This is already
	  implemented into the kernel.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52617464"></a>8.1.1.10. Applications</h4></div></div></div><p>For userland programming, we support IPv6 socket API as
	  specified in RFC2553, RFC2292 and upcoming Internet
	  drafts.</p><p>TCP/UDP over IPv6 is available and quite stable.  You
	  can enjoy <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ftp&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ftp</span>(1)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rlogin</span>(1)</span></a>,
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rsh</span>(1)</span></a>, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a>, etc.  These applications are
	  protocol independent.  That is, they automatically chooses
	  IPv4 or IPv6 according to DNS.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52623096"></a>8.1.1.11. Kernel Internals</h4></div></div></div><p>While ip_forward() calls ip_output(), ip6_forward()
	  directly calls if_output() since routers must not divide
	  IPv6 packets into fragments.</p><p>ICMPv6 should contain the original packet as long as
	  possible up to 1280.  UDP6/IP6 port unreach, for instance,
	  should contain all extension headers and the *unchanged*
	  UDP6 and IP6 headers.  So, all IP6 functions except TCP
	  never convert network byte order into host byte order, to
	  save the original packet.</p><p>tcp_input(), udp6_input() and icmp6_input() can not
	  assume that IP6 header is preceding the transport headers
	  due to extension headers.  So, in6_cksum() was implemented
	  to handle packets whose IP6 header and transport header is
	  not continuous.  TCP/IP6 nor UDP6/IP6 header structures do
	  not exist for checksum calculation.</p><p>To process IP6 header, extension headers and transport
	  headers easily, network drivers are now required to store
	  packets in one internal mbuf or one or more external mbufs.
	  A typical old driver prepares two internal mbufs for 96 -
	  204 bytes data, however, now such packet data is stored in
	  one external mbuf.</p><p><code class="command">netstat -s -p ip6</code> tells you whether
	  or not your driver conforms such requirement.  In the
	  following example, "cce0" violates the requirement.  (For
	  more information, refer to Section 2.)</p><pre class="screen">Mbuf statistics:
                317 one mbuf
                two or more mbuf::
                        lo0 = 8
			cce0 = 10
                3282 one ext mbuf
                0 two or more ext mbuf</pre><p>Each input function calls IP6_EXTHDR_CHECK in the
	  beginning to check if the region between IP6 and its header
	  is continuous.  IP6_EXTHDR_CHECK calls m_pullup() only if
	  the mbuf has M_LOOP flag, that is, the packet comes from the
	  loopback interface.  m_pullup() is never called for packets
	  coming from physical network interfaces.</p><p>Both IP and IP6 reassemble functions never call
	  m_pullup().</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipv6-wildcard-socket"></a>8.1.1.12. IPv4 Mapped Address and IPv6 Wildcard Socket</h4></div></div></div><p>RFC2553 describes IPv4 mapped address (3.7) and special
	  behavior of IPv6 wildcard bind socket (3.8).  The spec
	  allows you to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Accept IPv4 connections by AF_INET6 wildcard bind
	      socket.</p></li><li class="listitem"><p>Transmit IPv4 packet over AF_INET6 socket by using
	      special form of the address like ::ffff:10.1.1.1.</p></li></ul></div><p>but the spec itself is very complicated and does not
	  specify how the socket layer should behave.  Here we call
	  the former one "listening side" and the latter one
	  "initiating side", for reference purposes.</p><p>You can perform wildcard bind on both of the address
	  families, on the same port.</p><p>The following table show the behavior of FreeBSD
	  4.x.</p><pre class="screen">listening side          initiating side
                (AF_INET6 wildcard      (connection to ::ffff:10.1.1.1)
                socket gets IPv4 conn.)
                ---                     ---
FreeBSD 4.x     configurable            supported
                default: enabled</pre><p>The following sections will give you more details, and
	  how you can configure the behavior.</p><p>Comments on listening side:</p><p>It looks that RFC2553 talks too little on wildcard bind
	  issue, especially on the port space issue, failure mode and
	  relationship between AF_INET/INET6 wildcard bind.  There can
	  be several separate interpretation for this RFC which
	  conform to it but behaves differently.  So, to implement
	  portable application you should assume nothing about the
	  behavior in the kernel.  Using <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> is the
	  safest way.  Port number space and wildcard bind issues were
	  discussed in detail on ipv6imp mailing list, in mid March
	  1999 and it looks that there is no concrete consensus
	  (means, up to implementers).  You may want to check the
	  mailing list archives.</p><p>If a server application would like to accept IPv4 and
	  IPv6 connections, there will be two alternatives.</p><p>One is using AF_INET and AF_INET6 socket (you will need
	  two sockets).  Use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> with AI_PASSIVE into
	  ai_flags, and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">socket</span>(2)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a> to all the
	  addresses returned.  By opening multiple sockets, you can
	  accept connections onto the socket with proper address
	  family.  IPv4 connections will be accepted by AF_INET
	  socket, and IPv6 connections will be accepted by AF_INET6
	  socket.</p><p>Another way is using one AF_INET6 wildcard bind socket.
	  Use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> with AI_PASSIVE into ai_flags and
	  with AF_INET6 into ai_family, and set the 1st argument
	  hostname to NULL. And <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">socket</span>(2)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a> to the
	  address returned.  (should be IPv6 unspecified addr).  You
	  can accept either of IPv4 and IPv6 packet via this one
	  socket.</p><p>To support only IPv6 traffic on AF_INET6 wildcard binded
	  socket portably, always check the peer address when a
	  connection is made toward AF_INET6 listening socket.  If the
	  address is IPv4 mapped address, you may want to reject the
	  connection.  You can check the condition by using
	  IN6_IS_ADDR_V4MAPPED() macro.</p><p>To resolve this issue more easily, there is system
	  dependent <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a> option, IPV6_BINDV6ONLY, used
	  like below.</p><pre class="programlisting">	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre><p>When this call succeed, then this socket only receive
	  IPv6 packets.</p><p>Comments on initiating side:</p><p>Advise to application implementers: to implement a
	  portable IPv6 application (which works on multiple IPv6
	  kernels), we believe that the following is the key to the
	  success:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>NEVER hardcode AF_INET nor AF_INET6.</p></li><li class="listitem"><p>Use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getnameinfo</span>(3)</span></a>
	      throughout the system.  Never use gethostby*(),
	      getaddrby*(), inet_*() or getipnodeby*().  (To update
	      existing applications to be IPv6 aware easily, sometime
	      getipnodeby*() will be useful.  But if possible, try to
	      rewrite the code to use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> and
	      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getnameinfo</span>(3)</span></a>.)</p></li><li class="listitem"><p>If you would like to connect to destination, use
	      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> and try all the destination
	      returned, like <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> does.</p></li><li class="listitem"><p>Some of the IPv6 stack is shipped with buggy
	      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a>.  Ship a minimal working version
	      with your application and use that as last
	      resort.</p></li></ul></div><p>If you would like to use AF_INET6 socket for both IPv4
	  and IPv6 outgoing connection, you will need to use
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getipnodebyname</span>(3)</span></a>.  When you would like to update your
	  existing application to be IPv6 aware with minimal effort,
	  this approach might be chosen.  But please note that it is a
	  temporal solution, because <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getipnodebyname</span>(3)</span></a> itself is
	  not recommended as it does not handle scoped IPv6 addresses
	  at all.  For IPv6 name resolution, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a> is
	  the preferred API. So you should rewrite your application to
	  use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">getaddrinfo</span>(3)</span></a>, when you get the time to do
	  it.</p><p>When writing applications that make outgoing
	  connections, story goes much simpler if you treat AF_INET
	  and AF_INET6 as totally separate address family.
	  {set,get}sockopt issue goes simpler, DNS issue will be made
	  simpler.  We do not recommend you to rely upon IPv4 mapped
	  address.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52688376"></a>8.1.1.12.1. unified tcp and inpcb code</h5></div></div></div><p>FreeBSD 4.x uses shared tcp code between IPv4 and IPv6
	    (from sys/netinet/tcp*) and separate udp4/6 code.  It uses
	    unified inpcb structure.</p><p>The platform can be configured to support IPv4 mapped
	    address.  Kernel configuration is summarized as
	    follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>By default, AF_INET6 socket will grab IPv4
		connections in certain condition, and can initiate
		connection to IPv4 destination embedded in IPv4 mapped
		IPv6 address.</p></li><li class="listitem"><p>You can disable it on entire system with sysctl
		like below.</p><p><code class="command">sysctl
		  net.inet6.ip6.mapped_addr=0</code></p></li></ul></div><div class="sect5"><div xmlns="" class="titlepage"><div><div><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52692344"></a>8.1.1.12.1.1. Listening Side</h6></div></div></div><p>Each socket can be configured to support special
	      AF_INET6 wildcard bind (enabled by default).  You can
	      disable it on each socket basis with <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a>
	      like below.</p><pre class="programlisting">	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre><p>Wildcard AF_INET6 socket grabs IPv4 connection if
	      and only if the following conditions are
	      satisfied:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>there is no AF_INET socket that matches the IPv4
		  connection</p></li><li class="listitem"><p>the AF_INET6 socket is configured to accept IPv4
		  traffic, i.e.,  getsockopt(IPV6_BINDV6ONLY) returns
		  0.</p></li></ul></div><p>There is no problem with open/close ordering.</p></div><div class="sect5"><div xmlns="" class="titlepage"><div><div><h6 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52328824"></a>8.1.1.12.1.2. Initiating Side</h6></div></div></div><p>FreeBSD 4.x supports outgoing connection to IPv4
	      mapped address (::ffff:10.1.1.1), if the node is
	      configured to support IPv4 mapped address.</p></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52330232"></a>8.1.1.13. sockaddr_storage</h4></div></div></div><p>When RFC2553 was about to be finalized, there was
	  discussion on how struct sockaddr_storage members are named.
	  One proposal is to prepend "__" to the members (like
	  "__ss_len") as they should not be touched.  The other
	  proposal was not to prepend it (like "ss_len") as we need to
	  touch those members directly.  There was no clear consensus
	  on it.</p><p>As a result, RFC2553 defines struct sockaddr_storage as
	  follows:</p><pre class="programlisting">	struct sockaddr_storage {
		u_char	__ss_len;	/* address length */
		u_char	__ss_family;	/* address family */
		/* and bunch of padding */
	};</pre><p>On the contrary, XNET draft defines as follows:</p><pre class="programlisting">	struct sockaddr_storage {
		u_char	ss_len;		/* address length */
		u_char	ss_family;	/* address family */
		/* and bunch of padding */
	};</pre><p>In December 1999, it was agreed that RFC2553bis should
	  pick the latter (XNET) definition.</p><p>Current implementation conforms to XNET definition,
	  based on RFC2553bis discussion.</p><p>If you look at multiple IPv6 implementations, you will
	  be able to see both definitions.  As an userland programmer,
	  the most portable way of dealing with it is to:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ensure ss_family and/or ss_len are available on the
	      platform, by using GNU autoconf,</p></li><li class="listitem"><p>have -Dss_family=__ss_family to unify all
	      occurrences (including header file) into __ss_family,
	      or</p></li><li class="listitem"><p>never touch __ss_family.  cast to sockaddr * and use
	      sa_family like:</p><pre class="programlisting">	struct sockaddr_storage ss;
	family = ((struct sockaddr *)&amp;ss)-&gt;sa_family</pre></li></ol></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52341624"></a>8.1.2. Network Drivers</h3></div></div></div><p>Now following two items are required to be supported by
	standard drivers:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>mbuf clustering requirement.  In this stable release,
	    we changed MINCLSIZE into MHLEN+1 for all the operating
	    systems in order to make all the drivers behave as we
	    expect.</p></li><li class="listitem"><p>multicast.  If <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifmcstat&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifmcstat</span>(8)</span></a> yields no multicast
	    group for a interface, that interface has to be
	    patched.</p></li></ol></div><p>If any of the drivers do not support the requirements,
	then the drivers cannot be used for IPv6 and/or IPsec
	communication.  If you find any problem with your card using
	IPv6/IPsec, then, please report it to the <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugs" target="_top">FreeBSD problem reports mailing list</a>.</p><p>(NOTE: In the past we required all PCMCIA drivers to have
	a call to in6_ifattach().  We have no such requirement any
	more)</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52707320"></a>8.1.3. Translator</h3></div></div></div><p>We categorize IPv4/IPv6 translator into 4 types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Translator A</em></span> --- It is used in
	    the early stage of transition to make it possible to
	    establish a connection from an IPv6 host in an IPv6 island
	    to an IPv4 host in the IPv4 ocean.</p></li><li class="listitem"><p><span class="emphasis"><em>Translator B</em></span> --- It is used in
	    the early stage of transition to make it possible to
	    establish a connection from an IPv4 host in the IPv4 ocean
	    to an IPv6 host in an IPv6 island.</p></li><li class="listitem"><p><span class="emphasis"><em>Translator C</em></span> --- It is used in
	    the late stage of transition to make it possible to
	    establish a connection from an IPv4 host in an IPv4 island
	    to an IPv6 host in the IPv6 ocean.</p></li><li class="listitem"><p><span class="emphasis"><em>Translator D</em></span> --- It is used in
	    the late stage of transition to make it possible to
	    establish a connection from an IPv6 host in the IPv6 ocean
	    to an IPv4 host in an IPv4 island.</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipsec-implementation"></a>8.1.4. IPsec</h3></div></div></div><p>IPsec is mainly organized by three components.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Policy Management</p></li><li class="listitem"><p>Key Management</p></li><li class="listitem"><p>AH and ESP handling</p></li></ol></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52716792"></a>8.1.4.1. Policy Management</h4></div></div></div><p>The kernel implements experimental policy management
	  code.  There are two way to manage security policy.  One is
	  to configure per-socket policy using <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a>.  In
	  this cases, policy configuration is described in
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipsec_set_policy&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipsec_set_policy</span>(3)</span></a>.  The other is to configure kernel
	  packet filter-based policy using PF_KEY interface, via
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setkey</span>(8)</span></a>.</p><p>The policy entry is not re-ordered with its indexes, so
	  the order of entry when you add is very significant.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52720632"></a>8.1.4.2. Key Management</h4></div></div></div><p>The key management code implemented in this kit
	  (sys/netkey) is a home-brew PFKEY v2 implementation.  This
	  conforms to RFC2367.</p><p>The home-brew IKE daemon, "racoon" is included in the
	  kit (kame/kame/racoon).  Basically you will need to run
	  racoon as daemon, then set up a policy to require keys (like
	  <code class="command">ping -P 'out ipsec esp/transport//use'</code>).
	  The kernel will contact racoon daemon as necessary to
	  exchange keys.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52722552"></a>8.1.4.3. AH and ESP Handling</h4></div></div></div><p>IPsec module is implemented as "hooks" to the standard
	  IPv4/IPv6 processing.  When sending a packet,
	  ip{,6}_output() checks if ESP/AH processing is required by
	  checking if a matching SPD (Security Policy Database) is
	  found.  If ESP/AH is needed, {esp,ah}{4,6}_output() will be
	  called and mbuf will be updated accordingly.  When a packet
	  is received, {esp,ah}4_input() will be called based on
	  protocol number, i.e., (*inetsw[proto])().
	  {esp,ah}4_input() will decrypt/check authenticity of the
	  packet, and strips off daisy-chained header and padding for
	  ESP/AH.  It is safe to strip off the ESP/AH header on packet
	  reception, since we will never use the received packet in
	  "as is" form.</p><p>By using ESP/AH, TCP4/6 effective data segment size will
	  be affected by extra daisy-chained headers inserted by
	  ESP/AH.  Our code takes care of the case.</p><p>Basic crypto functions can be found in directory
	  "sys/crypto".  ESP/AH transform are listed in
	  {esp,ah}_core.c with wrapper functions.  If you wish to add
	  some algorithm, add wrapper function in {esp,ah}_core.c, and
	  add your crypto algorithm code into sys/crypto.</p><p>Tunnel mode is partially supported in this release, with
	  the following restrictions:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>IPsec tunnel is not combined with GIF generic
	      tunneling interface.  It needs a great care because we
	      may create an infinite loop between ip_output() and
	      tunnelifp-&gt;if_output().  Opinion varies if it is
	      better to unify them, or not.</p></li><li class="listitem"><p>MTU and Don't Fragment bit (IPv4) considerations
	      need more checking, but basically works fine.</p></li><li class="listitem"><p>Authentication model for AH tunnel must be
	      revisited.  We will need to improve the policy
	      management engine, eventually.</p></li></ul></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52727544"></a>8.1.4.4. Conformance to RFCs and IDs</h4></div></div></div><p>The IPsec code in the kernel conforms (or, tries to
	  conform) to the following standards:</p><p>"old IPsec" specification documented in
	  <code class="filename">rfc182[5-9].txt</code></p><p>"new IPsec" specification documented in
	  <code class="filename">rfc240[1-6].txt</code>,
	  <code class="filename">rfc241[01].txt</code>,
	  <code class="filename">rfc2451.txt</code> and
	  <code class="filename">draft-mcdonald-simple-ipsec-api-01.txt</code>
	  (draft expired, but you can take from <a class="link" href="ftp://ftp.kame.net/pub/internet-drafts/" target="_top">
	    ftp://ftp.kame.net/pub/internet-drafts/</a>).  (NOTE:
	  IKE specifications, <code class="filename">rfc241[7-9].txt</code> are
	  implemented in userland, as "racoon" IKE daemon)</p><p>Currently supported algorithms are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>old IPsec AH</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>null crypto checksum (no document, just for
		  debugging)</p></li><li class="listitem"><p>keyed MD5 with 128bit crypto checksum
		  (<code class="filename">rfc1828.txt</code>)</p></li><li class="listitem"><p>keyed SHA1 with 128bit crypto checksum (no
		  document)</p></li><li class="listitem"><p>HMAC MD5 with 128bit crypto checksum
		  (<code class="filename">rfc2085.txt</code>)</p></li><li class="listitem"><p>HMAC SHA1 with 128bit crypto checksum (no
		  document)</p></li></ul></div></li><li class="listitem"><p>old IPsec ESP</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>null encryption (no document, similar to
		  <code class="filename">rfc2410.txt</code>)</p></li><li class="listitem"><p>DES-CBC mode
		  (<code class="filename">rfc1829.txt</code>)</p></li></ul></div></li><li class="listitem"><p>new IPsec AH</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>null crypto checksum (no document, just for
		  debugging)</p></li><li class="listitem"><p>keyed MD5 with 96bit crypto checksum (no
		  document)</p></li><li class="listitem"><p>keyed SHA1 with 96bit crypto checksum (no
		  document)</p></li><li class="listitem"><p>HMAC MD5 with 96bit crypto checksum
		  (<code class="filename">rfc2403.txt</code>)</p></li><li class="listitem"><p>HMAC SHA1 with 96bit crypto checksum
		  (<code class="filename">rfc2404.txt</code>)</p></li></ul></div></li><li class="listitem"><p>new IPsec ESP</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>null encryption
		  (<code class="filename">rfc2410.txt</code>)</p></li><li class="listitem"><p>DES-CBC with derived IV
		  (<code class="filename">draft-ietf-ipsec-ciph-des-derived-01.txt</code>,
		  draft expired)</p></li><li class="listitem"><p>DES-CBC with explicit IV
		  (<code class="filename">rfc2405.txt</code>)</p></li><li class="listitem"><p>3DES-CBC with explicit IV
		  (<code class="filename">rfc2451.txt</code>)</p></li><li class="listitem"><p>BLOWFISH CBC
		  (<code class="filename">rfc2451.txt</code>)</p></li><li class="listitem"><p>CAST128 CBC
		  (<code class="filename">rfc2451.txt</code>)</p></li><li class="listitem"><p>RC5 CBC
		  (<code class="filename">rfc2451.txt</code>)</p></li><li class="listitem"><p>each of the above can be combined with:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>ESP authentication with
		      HMAC-MD5(96bit)</p></li><li class="listitem"><p>ESP authentication with
		      HMAC-SHA1(96bit)</p></li></ul></div></li></ul></div></li></ul></div><p>The following algorithms are NOT supported:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>old IPsec AH</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>HMAC MD5 with 128bit crypto checksum + 64bit
		  replay prevention
		  (<code class="filename">rfc2085.txt</code>)</p></li><li class="listitem"><p>keyed SHA1 with 160bit crypto checksum + 32bit
		  padding (<code class="filename">rfc1852.txt</code>)</p></li></ul></div></li></ul></div><p>IPsec (in kernel) and IKE (in userland as "racoon") has
	  been tested at several interoperability test events, and it
	  is known to interoperate with many other implementations
	  well.  Also, current IPsec implementation as quite wide
	  coverage for IPsec crypto algorithms documented in RFC (we
	  cover algorithms without intellectual property issues
	  only).</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ipsec-ecn"></a>8.1.4.5. ECN Consideration on IPsec Tunnels</h4></div></div></div><p>ECN-friendly IPsec tunnel is supported as described in
	  <code class="filename">draft-ipsec-ecn-00.txt</code>.</p><p>Normal IPsec tunnel is described in RFC2401.  On
	  encapsulation, IPv4 TOS field (or, IPv6 traffic class field)
	  will be copied from inner IP header to outer IP header.  On
	  decapsulation outer IP header will be simply dropped.  The
	  decapsulation rule is not compatible with ECN, since ECN bit
	  on the outer IP TOS/traffic class field will be lost.</p><p>To make IPsec tunnel ECN-friendly, we should modify
	  encapsulation and decapsulation procedure.  This is
	  described in <a class="link" href="http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt" target="_top">
	    http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>,
	  chapter 3.</p><p>IPsec tunnel implementation can give you three
	  behaviors, by setting net.inet.ipsec.ecn (or
	  net.inet6.ipsec6.ecn) to some value:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>RFC2401: no consideration for ECN (sysctl value
	      -1)</p></li><li class="listitem"><p>ECN forbidden (sysctl value 0)</p></li><li class="listitem"><p>ECN allowed (sysctl value 1)</p></li></ul></div><p>Note that the behavior is configurable in per-node
	  manner, not per-SA manner (draft-ipsec-ecn-00 wants per-SA
	  configuration, but it looks too much for me).</p><p>The behavior is summarized as follows (see source code
	  for more detail):</p><pre class="screen">encapsulate                     decapsulate
                ---                             ---
RFC2401         copy all TOS bits               drop TOS bits on outer
                from inner to outer.            (use inner TOS bits as is)

ECN forbidden   copy TOS bits except for ECN    drop TOS bits on outer
                (masked with 0xfc) from inner   (use inner TOS bits as is)
                to outer.  set ECN bits to 0.

ECN allowed     copy TOS bits except for ECN    use inner TOS bits with some
                CE (masked with 0xfe) from      change.  if outer ECN CE bit
                inner to outer.                 is 1, enable ECN CE bit on
                set ECN CE bit to 0.            the inner.</pre><p>General strategy for configuration is as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>if both IPsec tunnel endpoint are capable of
	      ECN-friendly behavior, you should better configure both
	      end to <span class="quote">&#8220;<span class="quote">ECN allowed</span>&#8221;</span> (sysctl value
	      1).</p></li><li class="listitem"><p>if the other end is very strict about TOS bit, use
	      "RFC2401" (sysctl value -1).</p></li><li class="listitem"><p>in other cases, use "ECN forbidden" (sysctl value
	      0).</p></li></ul></div><p>The default behavior is "ECN forbidden" (sysctl value
	  0).</p><p>For more information, please refer to:</p><p><a class="link" href="http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt" target="_top">
	    http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>,
	  RFC2481 (Explicit Congestion Notification),
	  src/sys/netinet6/{ah,esp}_input.c</p><p>(Thanks goes to Kenjiro Cho
	  <code class="email">&lt;<a xmlns="" class="email" href="mailto:kjc@csl.sony.co.jp">kjc@csl.sony.co.jp</a>&gt;</code> for detailed
	  analysis)</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp52806264"></a>8.1.4.6. Interoperability</h4></div></div></div><p>Here are (some of) platforms that KAME code have tested
	  IPsec/IKE interoperability in the past.  Note that both ends
	  may have modified their implementation, so use the following
	  list just for reference purposes.</p><p>Altiga, Ashley-laurent (vpcom.com), Data Fellows
	  (F-Secure), Ericsson ACC, FreeS/WAN, HITACHI, IBM <span class="trademark">AIX</span>®,
	  IIJ, Intel, <span class="trademark">Microsoft</span>® <span class="trademark">Windows NT</span>®, NIST (linux IPsec +
	  plutoplus), Netscreen, OpenBSD, RedCreek, Routerware, SSH,
	  Secure Computing, Soliton, Toshiba, VPNet, Yamaha
	  RT100i</p></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sockets-concurrent-servers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ipc.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="kernel.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.7. Concurrent Servers </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Part III. Kernel</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>