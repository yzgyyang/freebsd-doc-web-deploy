<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>11.5. Creating Portable Code</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="x86.html" title="Chapter 11. x86 Assembly Language Programming" /><link rel="prev" href="x86-return-values.html" title="11.4. Return Values" /><link rel="next" href="x86-first-program.html" title="11.6. Our First Program" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.5. Creating Portable Code</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="x86-return-values.html">Prev</a> </td><th width="60%" align="center">Chapter 11. x86 Assembly Language Programming</th><td width="20%" align="right"> <a accesskey="n" href="x86-first-program.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="x86-portable-code"></a>11.5. Creating Portable Code</h2></div></div></div><p>Portability is generally not one of the strengths of assembly
    language.  Yet, writing assembly language programs for different
    platforms is possible, especially with
    <span class="application">nasm</span>.  I have written assembly language
    libraries that can be assembled for such different operating
    systems as <span class="trademark">Windows</span>® and FreeBSD.</p><p>It is all the more possible when you want your code to run on
    two platforms which, while different, are based on similar
    architectures.</p><p>For example, FreeBSD is <span class="trademark">UNIX</span>®, Linux is <span class="trademark">UNIX</span>® like.  I only
    mentioned three differences between them (from an assembly
    language programmer's perspective): The calling convention, the
    function numbers, and the way of returning values.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-deal-with-function-numbers"></a>11.5.1. Dealing with Function Numbers</h3></div></div></div><p>In many cases the function numbers are the same.  However,
      even when they are not, the problem is easy to deal with:
      Instead of using numbers in your code, use constants which you
      have declared differently depending on the target
      architecture:</p><pre class="programlisting">%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-deal-with-geneva"></a>11.5.2. Dealing with Conventions</h3></div></div></div><p>Both, the calling convention, and the return value (the
	<code class="varname">errno</code> problem) can be resolved with
	macros:</p><pre class="programlisting">%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-deal-with-other-portability"></a>11.5.3. Dealing with Other Portability Issues</h3></div></div></div><p>The above solutions can handle most cases of writing code
      portable between FreeBSD and Linux.  Nevertheless, with some
      kernel services the differences are deeper.</p><p>In that case, you need to write two different handlers for
      those particular system calls, and use conditional assembly.
      Luckily, most of your code does something other than calling the
      kernel, so usually you will only need a few such conditional
      sections in your code.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-portable-library"></a>11.5.4. Using a Library</h3></div></div></div><p>You can avoid portability issues in your main code
      altogether by writing a library of system calls.  Create a
      separate library for FreeBSD, a different one for Linux, and yet
      other libraries for more operating systems.</p><p>In your library, write a separate function (or procedure, if
      you prefer the traditional assembly language terminology) for
      each system call.  Use the C calling convention of passing
      parameters.  But still use <code class="varname">EAX</code> to pass the call number in.  In
      that case, your FreeBSD library can be very simple, as many
      seemingly different functions can be just labels to the same
      code:</p><pre class="programlisting">sys.open:
sys.close:
[etc...]
	int	80h
	ret</pre><p>Your Linux library will require more different functions.
      But even here you can group system calls using the same number
      of parameters:</p><pre class="programlisting">sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</pre><p>The library approach may seem inconvenient at first because
      it requires you to produce a separate file your code depends on.
      But it has many advantages: For one, you only need to write it
      once and can use it for all your programs.  You can even let
      other assembly language programmers use it, or perhaps use one
      written by someone else.  But perhaps the greatest advantage of
      the library is that your code can be ported to other systems,
      even by other programmers, by simply writing a new library
      without any changes to your code.</p><p>If you do not like the idea of having a library, you can at
      least place all your system calls in a separate assembly
      language file and link it with your main program.  Here, again,
      all porters have to do is create a new object file to link with
      your main program.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-portable-include"></a>11.5.5. Using an Include File</h3></div></div></div><p>If you are releasing your software as (or with) source code,
      you can use macros and place them in a separate file, which you
      include in your code.</p><p>Porters of your software will simply write a new include
      file.  No library or external object file is necessary, yet your
      code is portable without any need to edit the code.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">This is the approach we will use throughout this chapter.
	We will name our include file <code class="filename">system.inc</code>,
	and add to it whenever we deal with a new system call.</p></div><p>We can start our <code class="filename">system.inc</code> by
      declaring the standard file descriptors:</p><pre class="programlisting">%define	stdin	0
%define	stdout	1
%define	stderr	2</pre><p>Next, we create a symbolic name for each system call:</p><pre class="programlisting">%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</pre><p>We add a short, non-global procedure with a long name, so we
      do not accidentally reuse the name in our code:</p><pre class="programlisting">section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</pre><p>We create a macro which takes one argument, the syscall
      number:</p><pre class="programlisting">%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</pre><p>Finally, we create macros for each syscall.  These macros
      take no arguments.</p><pre class="programlisting">%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</pre><p>Go ahead, enter it into your editor and save it as
      <code class="filename">system.inc</code>.  We will add more to it as we
      discuss more syscalls.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="x86-return-values.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="x86.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="x86-first-program.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.4. Return Values </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.6. Our First Program</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>