<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>11.12. One-Pointed Mind</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="x86.html" title="Chapter 11. x86 Assembly Language Programming" /><link rel="prev" href="x86-files.html" title="11.11. Working with Files" /><link rel="next" href="x86-fpu.html" title="11.13. Using the FPU" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.12. One-Pointed Mind</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="x86-files.html">Prev</a> </td><th width="60%" align="center">Chapter 11. x86 Assembly Language Programming</th><td width="20%" align="right"> <a accesskey="n" href="x86-fpu.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="x86-one-pointed-mind"></a>11.12. One-Pointed Mind</h2></div></div></div><p>As a student of Zen, I like the idea of a one-pointed mind:
      Do one thing at a time, and do it well.</p><p>This, indeed, is very much how <span class="trademark">UNIX</span>® works as well.  While
      a typical <span class="trademark">Windows</span>® application is attempting to do everything
      imaginable (and is, therefore, riddled with bugs), a typical
      <span class="trademark">UNIX</span>® program does only one thing, and it does it well.</p><p>The typical <span class="trademark">UNIX</span>® user then essentially assembles his own
      applications by writing a shell script which combines the
      various existing programs by piping the output of one program to
      the input of another.</p><p>When writing your own <span class="trademark">UNIX</span>® software, it is generally a
      good idea to see what parts of the problem you need to solve can
      be handled by existing programs, and only write your own
      programs for that part of the problem that you do not have an
      existing solution for.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-csv"></a>11.12.1. CSV</h3></div></div></div><p>I will illustrate this principle with a specific real-life
	example I was faced with recently:</p><p>I needed to extract the 11th field of each record from a
	database I downloaded from a web site.  The database was a
	<acronym class="acronym">CSV</acronym> file, i.e., a list of
	<span class="emphasis"><em>comma-separated values</em></span>.  That is quite
	a standard format for sharing data among people who may be
	using different database software.</p><p>The first line of the file contains the list of various
	fields separated by commas.  The rest of the file contains the
	data listed line by line, with values separated by
	commas.</p><p>I tried <span class="application">awk</span>, using the comma as
	a separator.  But because several lines contained a quoted
	comma, <span class="application">awk</span> was extracting the wrong
	field from those lines.</p><p>Therefore, I needed to write my own software to extract
	the 11th field from the <acronym class="acronym">CSV</acronym> file.  However,
	going with the <span class="trademark">UNIX</span>® spirit, I only needed to write a simple
	filter that would do the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Remove the first line from the file;</p></li><li class="listitem"><p>Change all unquoted commas to a different
	    character;</p></li><li class="listitem"><p>Remove all quotation marks.</p></li></ul></div><p>Strictly speaking, I could use
	<span class="application">sed</span> to remove the first line from
	the file, but doing so in my own program was very easy, so I
	decided to do it and reduce the size of the pipeline.</p><p>At any rate, writing a program like this took me about
	20 minutes.  Writing a program that extracts the 11th field
	from the <acronym class="acronym">CSV</acronym> file would take a lot longer,
	and I could not reuse it to extract some other field from some
	other database.</p><p>This time I decided to let it do a little more work than a
	typical tutorial program would:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>It parses its command line for options;</p></li><li class="listitem"><p>It displays proper usage if it finds wrong
	    arguments;</p></li><li class="listitem"><p>It produces meaningful error messages.</p></li></ul></div><p>Here is its usage message:</p><pre class="screen">Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]</pre><p>All parameters are optional, and can appear in any
	order.</p><p>The <em class="parameter"><code>-t</code></em> parameter declares what to
	replace the commas with.  The <code class="constant">tab</code> is the
	default here.  For example, <em class="parameter"><code>-t;</code></em> will
	replace all unquoted commas with semicolons.</p><p>I did not need the <em class="parameter"><code>-c</code></em> option, but
	it may come in handy in the future.  It lets me declare that I
	want a character other than a comma replaced with something
	else.  For example, <em class="parameter"><code>-c@</code></em> will replace
	all at signs (useful if you want to split a list of email
	addresses to their user names and domains).</p><p>The <em class="parameter"><code>-p</code></em> option preserves the first
	line, i.e., it does not delete it.  By default, we delete the
	first line because in a <acronym class="acronym">CSV</acronym> file it
	contains the field names rather than data.</p><p>The <em class="parameter"><code>-i</code></em> and
	<em class="parameter"><code>-o</code></em> options let me specify the input and
	the output files.  Defaults are <code class="filename">stdin</code> and
	<code class="filename">stdout</code>, so this is a regular <span class="trademark">UNIX</span>®
	filter.</p><p>I made sure that both <em class="parameter"><code>-i filename</code></em>
	and <em class="parameter"><code>-ifilename</code></em> are accepted.  I also
	made sure that only one input and one output files may be
	specified.</p><p>To get the 11th field of each record, I can now do:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>csv '-t;' <em class="replaceable"><code>data.csv</code></em> | awk '-F;' '{print $11}'</code></strong></pre><p>The code stores the options (except for the file
	descriptors) in <code class="varname">EDX</code>: The
	comma in <code class="varname">DH</code>, the new
	separator in <code class="varname">DL</code>, and the
	flag for the <em class="parameter"><code>-p</code></em> option in the highest
	bit of <code class="varname">EDX</code>, so a check for
	its sign will give us a quick decision what to do.</p><p>Here is the code:</p><pre class="programlisting">;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	'system.inc'

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	'Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]', 0Ah
usglen	equ	$-usg
iemsg	db	"csv: Can't open input file", 0Ah
iemlen	equ	$-iemsg
oemsg	db	"csv: Can't create output file", 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (',' &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], '-'
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, 'o'
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, 'i'
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, 'p'
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, 't'		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, 'c'
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, '"'
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, '"'
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre><p>Much of it is taken from <code class="filename">hex.asm</code>
	above.  But there is one important difference: I no longer
	call <code class="function">write</code> whenever I am outputting a
	line feed.  Yet, the code can be used interactively.</p><p>I have found a better solution for the interactive problem
	since I first started writing this chapter.  I wanted to
	make sure each line is printed out separately only when
	needed.  After all, there is no need to flush out every line
	when used non-interactively.</p><p>The new solution I use now is to call
	<code class="function">write</code> every time I find the input buffer
	  empty.  That way, when running in the interactive mode, the
	  program reads one line from the user's keyboard, processes
	  it, and sees its input buffer is empty.  It flushes its
	  output and reads the next line.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-buffered-dark-side"></a>11.12.1.1. The Dark Side of Buffering</h4></div></div></div><p>This change prevents a mysterious lockup in a very
	    specific case.  I refer to it as the <span class="emphasis"><em>dark side
	      of buffering</em></span>, mostly because it presents a
	    danger that is not quite obvious.</p><p>It is unlikely to happen with a program like the
	    <span class="application">csv</span> above, so let us consider
	    yet another filter: In this case we expect our input to be
	    raw data representing color values, such as the
	    <span class="emphasis"><em>red</em></span>, <span class="emphasis"><em>green</em></span>, and
	    <span class="emphasis"><em>blue</em></span> intensities of a pixel.  Our
	    output will be the negative of our input.</p><p>Such a filter would be very simple to write.  Most of
	    it would look just like all the other filters we have
	    written so far, so I am only going to show you its inner
	    loop:</p><pre class="programlisting">.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre><p>Because this filter works with raw data, it is
	    unlikely to be used interactively.</p><p>But it could be called by image manipulation software.
	    And, unless it calls <code class="function">write</code> before
	    each call to <code class="function">read</code>, chances are it
	    will lock up.</p><p>Here is what might happen:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>The image editor will load our filter using the C
		function <code class="function">popen()</code>.</p></li><li class="step"><p>It will read the first row of pixels from a bitmap
		or pixmap.</p></li><li class="step"><p>It will write the first row of pixels to the
		<span class="emphasis"><em>pipe</em></span> leading to the
		<code class="varname">fd.in</code> of our filter.</p></li><li class="step"><p>Our filter will read each pixel from its input,
		turn it to a negative, and write it to its output
		buffer.</p></li><li class="step"><p>Our filter will call <code class="function">getchar</code>
		to fetch the next pixel.</p></li><li class="step"><p><code class="function">getchar</code> will find an empty
		input buffer, so it will call
		<code class="function">read</code>.</p></li><li class="step"><p><code class="function">read</code> will call the <code class="function">SYS_read</code> system
		call.</p></li><li class="step"><p>The <span class="emphasis"><em>kernel</em></span> will suspend our
		filter until the image editor sends more data to the
		pipe.</p></li><li class="step"><p>The image editor will read from the other pipe,
		connected to the <code class="varname">fd.out</code> of our
		filter so it can set the first row of the output image
		<span class="emphasis"><em>before</em></span> it sends us the second row
		of the input.</p></li><li class="step"><p>The <span class="emphasis"><em>kernel</em></span> suspends the image
		editor until it receives some output from our filter,
		so it can pass it on to the image editor.</p></li></ol></div><p>At this point our filter waits for the image editor to
	    send it more data to process, while the image editor is
	    waiting for our filter to send it the result of the
	    processing of the first row.  But the result sits in our
	    output buffer.</p><p>The filter and the image editor will continue waiting
	    for each other forever (or, at least, until they are
	    killed).  Our software has just entered a <a class="link" href="secure-race-conditions.html" title="3.7. Race Conditions">race
	      condition</a>.</p><p>This problem does not exist if our filter flushes its
	    output buffer <span class="emphasis"><em>before</em></span> asking the
	    <span class="emphasis"><em>kernel</em></span> for more input data.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="x86-files.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="x86.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="x86-fpu.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.11. Working with Files </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.13. Using the <acronym class="acronym">FPU</acronym></td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>