<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>11.7. Writing UNIX® Filters</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="x86.html" title="Chapter 11. x86 Assembly Language Programming" /><link rel="prev" href="x86-first-program.html" title="11.6. Our First Program" /><link rel="next" href="x86-buffered-io.html" title="11.8. Buffered Input and Output" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.7. Writing <span class="trademark">UNIX</span>® Filters</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="x86-first-program.html">Prev</a> </td><th width="60%" align="center">Chapter 11. x86 Assembly Language Programming</th><td width="20%" align="right"> <a accesskey="n" href="x86-buffered-io.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="x86-unix-filters"></a>11.7. Writing <span class="trademark">UNIX</span>® Filters</h2></div></div></div><p>A common type of <span class="trademark">UNIX</span>® application is a filter&#8212;a
    program that reads data from the <code class="filename">stdin</code>,
    processes it somehow, then writes the result to
    <code class="filename">stdout</code>.</p><p>In this chapter, we shall develop a simple filter, and
    learn how to read from <code class="filename">stdin</code> and write to
    <code class="filename">stdout</code>.  This filter will convert each byte
    of its input into a hexadecimal number followed by a blank
    space.</p><pre class="programlisting">%include	'system.inc'

section	.data
hex	db	'0123456789ABCDEF'
buffer	db	0, 0, ' '

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</pre><p>In the data section we create an array called
	<code class="varname">hex</code>.  It contains the 16 hexadecimal digits
	in ascending order.  The array is followed by a buffer which
	we will use for both input and output.  The first two bytes of
	the buffer are initially set to <code class="constant">0</code>.  This
	is where we will write the two hexadecimal digits (the first
	byte also is where we will read the input).  The third byte is
	a space.</p><p>The code section consists of four parts: Reading the byte,
	converting it to a hexadecimal number, writing the result, and
	eventually exiting the program.</p><p>To read the byte, we ask the system to read one byte from
	<code class="filename">stdin</code>, and store it in the first byte of
	the <code class="varname">buffer</code>.  The system returns the number
	of bytes read in <code class="varname">EAX</code>.  This
	will be <code class="constant">1</code> while data is coming, or
	<code class="constant">0</code>, when no more input data is available.
	Therefore, we check the value of <code class="varname">EAX</code>.  If it is
	<code class="constant">0</code>, we jump to <code class="varname">.done</code>,
	otherwise we continue.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">For simplicity sake, we are ignoring the possibility of
	  an error condition at this time.</p></div><p>The hexadecimal conversion reads the byte from the
	<code class="varname">buffer</code> into <code class="varname">EAX</code>, or actually just <code class="varname">AL</code>, while clearing the remaining
	bits of <code class="varname">EAX</code> to zeros.  We
	also copy the byte to <code class="varname">EDX</code>
	because we need to convert the upper four bits (nibble)
	separately from the lower four bits.  We store the result in
	the first two bytes of the buffer.</p><p>Next, we ask the system to write the three bytes of the
	buffer, i.e., the two hexadecimal digits and the blank space,
	to <code class="filename">stdout</code>.  We then jump back to the
	beginning of the program and process the next byte.</p><p>Once there is no more input left, we ask the system to
	exit our program, returning a zero, which is the traditional
	value meaning the program was successful.</p><p>Go ahead, and save the code in a file named
	<code class="filename">hex.asm</code>, then type the following (the
	<strong class="userinput"><code>^D</code></strong> means press the control key and type
	<strong class="userinput"><code>D</code></strong> while holding the control key
	down):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nasm -f elf hex.asm</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>ld -s -o hex hex.o</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>./hex</code></strong>
<strong class="userinput"><code>Hello, World!</code></strong>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A <strong class="userinput"><code>Here I come!</code></strong>
48 65 72 65 20 49 20 63 6F 6D 65 21 0A <strong class="userinput"><code>^D</code></strong> <code class="prompt">%</code></pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">If you are migrating to <span class="trademark">UNIX</span>® from
	  <acronym class="acronym"><span class="trademark">MS-DOS</span>®</acronym>, you may be wondering why each
	  line ends with <code class="constant">0A</code> instead of
	  <code class="constant">0D 0A</code>.  This is because <span class="trademark">UNIX</span>® does not
	  use the cr/lf convention, but a "new line" convention, which
	  is <code class="constant">0A</code> in hexadecimal.</p></div><p>Can we improve this? Well, for one, it is a bit confusing
	because once we have converted a line of text, our input no
	longer starts at the beginning of the line.  We can modify it
	to print a new line instead of a space after each
	<code class="constant">0A</code>:</p><pre class="programlisting">%include	'system.inc'

section	.data
hex	db	'0123456789ABCDEF'
buffer	db	0, 0, ' '

section	.text
global	_start
_start:
	mov	cl, ' '

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</pre><p>We have stored the space in the <code class="varname">CL</code> register.  We can do this
	safely because, unlike <span class="trademark">Microsoft</span>® <span class="trademark">Windows</span>®, <span class="trademark">UNIX</span>® system
	calls do not modify the value of any register they do not use
	to return a value in.</p><p>That means we only need to set <code class="varname">CL</code> once.  We have, therefore,
	added a new label <code class="varname">.loop</code> and jump to it for
	the next byte instead of jumping at <code class="varname">_start</code>.
	We have also added the <code class="varname">.hex</code> label so we can
	either have a blank space or a new line as the third byte of
	the <code class="varname">buffer</code>.</p><p>Once you have changed <code class="filename">hex.asm</code> to
	reflect these changes, type:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nasm -f elf hex.asm</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>ld -s -o hex hex.o</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>./hex</code></strong>
<strong class="userinput"><code>Hello, World!</code></strong>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
<strong class="userinput"><code>Here I come!</code></strong>
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<strong class="userinput"><code>^D</code></strong> <code class="prompt">%</code></pre><p>That looks better.  But this code is quite inefficient! We
	are making a system call for every single byte twice (once to
	read it, another time to write the output).</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="x86-first-program.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="x86.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="x86-buffered-io.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.6. Our First Program </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.8. Buffered Input and Output</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>