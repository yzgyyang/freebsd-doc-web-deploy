<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>7.5. Essential Socket Functions</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="sockets.html" title="Chapter 7. Sockets" /><link rel="prev" href="sockets-model.html" title="7.4. The Sockets Model" /><link rel="next" href="sockets-helper-functions.html" title="7.6. Helper Functions" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.5. Essential Socket Functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sockets-model.html">Prev</a> </td><th width="60%" align="center">Chapter 7. Sockets</th><td width="20%" align="right"> <a accesskey="n" href="sockets-helper-functions.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="sockets-essential-functions"></a>7.5. Essential Socket Functions</h2></div></div></div><p>While FreeBSD offers different functions to work with
      sockets, we only <span class="emphasis"><em>need</em></span> four to
      <span class="quote">&#8220;<span class="quote">open</span>&#8221;</span> a socket.  And in some cases we only need
      two.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-client-server"></a>7.5.1. The Client-Server Difference</h3></div></div></div><p>Typically, one of the ends of a socket-based data
	communication is a <span class="emphasis"><em>server</em></span>, the other is a
	<span class="emphasis"><em>client</em></span>.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-common-elements"></a>7.5.1.1. The Common Elements</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-socket"></a>7.5.1.1.1. <code class="function">socket</code></h5></div></div></div><p>The one function used by both, clients and servers, is
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">socket</span>(2)</span></a>.  It is declared this way:</p><pre class="programlisting">int socket(int domain, int type, int protocol);</pre><p>The return value is of the same type as that of
	    <code class="function">open</code>, an integer.  FreeBSD allocates
	    its value from the same pool as that of file handles.
	    That is what allows sockets to be treated the same way as
	    files.</p><p>The <code class="varname">domain</code> argument tells the
	    system what <span class="emphasis"><em>protocol family</em></span> you want
	    it to use.  Many of them exist, some are vendor specific,
	    others are very common.  They are declared in
	    <code class="filename">sys/socket.h</code>.</p><p>Use <code class="constant">PF_INET</code> for
	    <acronym class="acronym">UDP</acronym>, <acronym class="acronym">TCP</acronym> and other
	    Internet protocols (<acronym class="acronym">IP</acronym>v4).</p><p>Five values are defined for the
	    <code class="varname">type</code> argument, again, in
	    <code class="filename">sys/socket.h</code>.  All of them start with
	    <span class="quote">&#8220;<span class="quote"><code class="constant">SOCK_</code></span>&#8221;</span>.  The most
	    common one is <code class="constant">SOCK_STREAM</code>, which
	    tells the system you are asking for a <span class="emphasis"><em>reliable
	    stream delivery service</em></span> (which is
	    <acronym class="acronym">TCP</acronym> when used with
	    <code class="constant">PF_INET</code>).</p><p>If you asked for <code class="constant">SOCK_DGRAM</code>, you
	    would be requesting a <span class="emphasis"><em>connectionless datagram
	    delivery service</em></span> (in our case,
	    <acronym class="acronym">UDP</acronym>).</p><p>If you wanted to be in charge of the low-level
	    protocols (such as <acronym class="acronym">IP</acronym>), or even network
	    interfaces (e.g., the Ethernet), you would need to specify
	    <code class="constant">SOCK_RAW</code>.</p><p>Finally, the <code class="varname">protocol</code> argument
	    depends on the previous two arguments, and is not always
	    meaningful.  In that case, use <code class="constant">0</code> for
	    its value.</p><div xmlns="" class="note"><h3 class="admontitle"><a xmlns="http://www.w3.org/1999/xhtml" id="sockets-unconnected"></a>The Unconnected Socket: </h3><p xmlns="http://www.w3.org/1999/xhtml">Nowhere, in the <code class="function">socket</code> function
	      have we specified to what other system we should be
	      connected.  Our newly created socket remains
	      <span class="emphasis"><em>unconnected</em></span>.</p><p xmlns="http://www.w3.org/1999/xhtml">This is on purpose: To use a telephone analogy, we
	      have just attached a modem to the phone line.  We have
	      neither told the modem to make a call, nor to answer if
	      the phone rings.</p></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-sockaddr"></a>7.5.1.1.2. <code class="varname">sockaddr</code></h5></div></div></div><p>Various functions of the sockets family expect the
	    address of (or pointer to, to use C terminology) a small
	    area of the memory.  The various C declarations in the
	    <code class="filename">sys/socket.h</code> refer to it as
	    <code class="varname">struct sockaddr</code>.  This structure is
	    declared in the same file:</p><pre class="programlisting">/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	unsigned char	sa_len;		/* total length */
	sa_family_t	sa_family;	/* address family */
	char		sa_data[14];	/* actually longer; address value */
};
#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */</pre><p>Please note the <span class="emphasis"><em>vagueness</em></span> with
	    which the <code class="varname">sa_data</code> field is declared,
	    just as an array of <code class="constant">14</code> bytes, with
	    the comment hinting there can be more than
	    <code class="constant">14</code> of them.</p><p>This vagueness is quite deliberate.  Sockets is a very
	    powerful interface.  While most people perhaps think of it
	    as nothing more than the Internet interface&#8212;and most
	    applications probably use it for that
	    nowadays&#8212;sockets can be used for just about
	    <span class="emphasis"><em>any</em></span> kind of interprocess
	    communications, of which the Internet (or, more precisely,
	    <acronym class="acronym">IP</acronym>) is only one.</p><p>The <code class="filename">sys/socket.h</code> refers to the
	    various types of protocols sockets will handle as
	    <span class="emphasis"><em>address families</em></span>, and lists them
	    right before the definition of
	    <code class="varname">sockaddr</code>:</p><pre class="programlisting">/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#define	AF_LOCAL	1		/* local to host (pipes, portals) */
#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NS		6		/* XEROX NS protocols */
#define	AF_ISO		7		/* ISO protocols */
#define	AF_OSI		AF_ISO
#define	AF_ECMA		8		/* European computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* DEC Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define	AF_APPLETALK	16		/* Apple Talk */
#define	AF_ROUTE	17		/* Internal Routing Protocol */
#define	AF_LINK		18		/* Link layer interface */
#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
#define	AF_CNT		21		/* Computer Network Technology */
#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
#define	AF_IPX		23		/* Novell Internet Protocol */
#define	AF_SIP		24		/* Simple Internet Protocol */
#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
#define	AF_ISDN		26		/* Integrated Services Digital Network*/
#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
#define	pseudo_AF_KEY	27		/* Internal key-management function */
#define	AF_INET6	28		/* IPv6 */
#define	AF_NATM		29		/* native ATM access */
#define	AF_ATM		30		/* ATM */
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
#define	AF_NETGRAPH	32		/* Netgraph sockets */
#define	AF_SLOW		33		/* 802.3ad slow protocol */
#define	AF_SCLUSTER	34		/* Sitara cluster protocol */
#define	AF_ARP		35
#define	AF_BLUETOOTH	36		/* Bluetooth sockets */
#define	AF_MAX		37</pre><p>The one used for <acronym class="acronym">IP</acronym> is
	    <span class="symbol">AF_INET</span>.  It is a symbol for the constant
	    <code class="constant">2</code>.</p><p>It is the <span class="emphasis"><em>address family</em></span> listed
	    in the <code class="varname">sa_family</code> field of
	    <code class="varname">sockaddr</code> that decides how exactly the
	    vaguely named bytes of <code class="varname">sa_data</code> will be
	    used.</p><p>Specifically, whenever the <span class="emphasis"><em>address
	      family</em></span> is <span class="symbol">AF_INET</span>, we can
	    use <code class="varname">struct sockaddr_in</code> found in
	    <code class="filename">netinet/in.h</code>, wherever
	    <code class="varname">sockaddr</code> is expected:</p><pre class="programlisting">/*
 * Socket address, internet style.
 */
struct sockaddr_in {
	uint8_t		sin_len;
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};</pre><p>We can visualize its organization this way:</p><div class="mediaobject"><img src="sockets/sain.png" alt="sockaddr_in" /></div><p>The three important fields are
	    <code class="varname">sin_family</code>, which is byte 1 of the
	    structure, <code class="varname">sin_port</code>, a 16-bit value
	    found in bytes 2 and 3, and <code class="varname">sin_addr</code>, a
	    32-bit integer representation of the <acronym class="acronym">IP</acronym>
	    address, stored in bytes 4-7.</p><p>Now, let us try to fill it out.  Let us assume we are
	    trying to write a client for the
	    <span class="emphasis"><em>daytime</em></span> protocol, which simply states
	    that its server will write a text string representing the
	    current date and time to port 13.  We want to use
	    <acronym class="acronym">TCP/IP</acronym>, so we need to specify
	    <code class="constant">AF_INET</code> in the address family field.
	    <code class="constant">AF_INET</code> is defined as
	    <code class="constant">2</code>.  Let us use the
	    <acronym class="acronym">IP</acronym> address of <code class="systemitem">192.43.244.18</code>, which is
	    the time server of US federal government (<code class="systemitem">time.nist.gov</code>).</p><div class="mediaobject"><img src="sockets/sainfill.png" alt="Specific example of sockaddr_in" /></div><p>By the way the <code class="varname">sin_addr</code> field is
	    declared as being of the <code class="varname">struct in_addr</code>
	    type, which is defined in
	    <code class="filename">netinet/in.h</code>:</p><pre class="programlisting">/*
 * Internet address (a structure for historical reasons)
 */
struct in_addr {
	in_addr_t s_addr;
};</pre><p>In addition, <code class="varname">in_addr_t</code> is a 32-bit
	    integer.</p><p>The <code class="systemitem">192.43.244.18</code> is just a
	    convenient notation of expressing a 32-bit integer by
	    listing all of its 8-bit bytes, starting with the
	    <span class="emphasis"><em>most significant</em></span> one.</p><p>So far, we have viewed <code class="varname">sockaddr</code> as
	    an abstraction.  Our computer does not store
	    <code class="varname">short</code> integers as a single 16-bit
	    entity, but as a sequence of 2 bytes.  Similarly, it
	    stores 32-bit integers as a sequence of 4 bytes.</p><p>Suppose we coded something like this:</p><pre class="programlisting">sa.sin_family      = AF_INET;
sa.sin_port        = 13;
sa.sin_addr.s_addr = (((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18;</pre><p>What would the result look like?</p><p>Well, that depends, of course.  On a <span class="trademark">Pentium</span>®, or
	    other x86, based computer, it would look like this:</p><div class="mediaobject"><img src="sockets/sainlsb.png" alt="sockaddr_in on an Intel system" /></div><p>On a different system, it might look like this:</p><div class="mediaobject"><img src="sockets/sainmsb.png" alt="sockaddr_in on an MSB system" /></div><p>And on a PDP it might look different yet.  But the
	    above two are the most common ways in use today.</p><p>Ordinarily, wanting to write portable code,
	    programmers pretend that these differences do not exist.
	    And they get away with it (except when they code in
	    assembly language).  Alas, you cannot get away with it
	    that easily when coding for sockets.</p><p>Why?</p><p>Because when communicating with another computer, you
	    usually do not know whether it stores data <span class="emphasis"><em>most
	    significant byte</em></span> (<acronym class="acronym">MSB</acronym>) or
	    <span class="emphasis"><em>least significant byte</em></span>
	    (<acronym class="acronym">LSB</acronym>) first.</p><p>You might be wondering, <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">So, will
		sockets not handle it for
		me?</span>&#8221;</span></em></span></p><p>It will not.</p><p>While that answer may surprise you at first, remember
	    that the general sockets interface only understands the
	    <code class="varname">sa_len</code> and <code class="varname">sa_family</code>
	    fields of the <code class="varname">sockaddr</code> structure.  You
	    do not have to worry about the byte order there (of
	    course, on FreeBSD <code class="varname">sa_family</code> is only 1
	    byte anyway, but many other <span class="trademark">UNIX</span>® systems do not have
	    <code class="varname">sa_len</code> and use 2 bytes for
	    <code class="varname">sa_family</code>, and expect the data in
	    whatever order is native to the computer).</p><p>But the rest of the data is just
	    <code class="varname">sa_data[14]</code> as far as sockets goes.
	    Depending on the <span class="emphasis"><em>address family</em></span>,
	    sockets just forwards that data to its destination.</p><p>Indeed, when we enter a port number, it is because we
	    want the other computer to know what service we are asking
	    for.  And, when we are the server, we read the port number
	    so we know what service the other computer is expecting
	    from us.  Either way, sockets only has to forward the port
	    number as data.  It does not interpret it in any
	    way.</p><p>Similarly, we enter the <acronym class="acronym">IP</acronym> address
	    to tell everyone on the way where to send our data to.
	    Sockets, again, only forwards it as data.</p><p>That is why, we (the <span class="emphasis"><em>programmers</em></span>,
	    not the <span class="emphasis"><em>sockets</em></span>) have to distinguish
	    between the byte order used by our computer and a
	    conventional byte order to send the data in to the other
	    computer.</p><p>We will call the byte order our computer uses the
	    <span class="emphasis"><em>host byte order</em></span>, or just the
	    <span class="emphasis"><em>host order</em></span>.</p><p>There is a convention of sending the multi-byte data
	    over <acronym class="acronym">IP</acronym>
	    <span class="emphasis"><em><acronym class="acronym">MSB</acronym> first</em></span>.  This,
	    we will refer to as the <span class="emphasis"><em>network byte
	      order</em></span>, or simply the <span class="emphasis"><em>network
	      order</em></span>.</p><p>Now, if we compiled the above code for an Intel based
	    computer, our <span class="emphasis"><em>host byte order</em></span> would
	    produce:</p><div class="mediaobject"><img src="sockets/sainlsb.png" alt="Host byte order on an Intel system" /></div><p>But the <span class="emphasis"><em>network byte order</em></span>
	    requires that we store the data <acronym class="acronym">MSB</acronym>
	    first:</p><div class="mediaobject"><img src="sockets/sainmsb.png" alt="Network byte order" /></div><p>Unfortunately, our <span class="emphasis"><em>host order</em></span> is
	    the exact opposite of the <span class="emphasis"><em>network
	      order</em></span>.</p><p>We have several ways of dealing with it.  One would be
	    to <span class="emphasis"><em>reverse</em></span> the values in our
	    code:</p><pre class="programlisting">sa.sin_family      = AF_INET;
sa.sin_port        = 13 &lt;&lt; 8;
sa.sin_addr.s_addr = (((((18 &lt;&lt; 8) | 244) &lt;&lt; 8) | 43) &lt;&lt; 8) | 192;</pre><p>This will <span class="emphasis"><em>trick</em></span> our compiler into
	    storing the data in the <span class="emphasis"><em>network byte
	      order</em></span>.  In some cases, this is exactly the
	    way to do it (e.g., when programming in assembly
	    language).  In most cases, however, it can cause a
	    problem.</p><p>Suppose, you wrote a sockets-based program in C.  You
	    know it is going to run on a <span class="trademark">Pentium</span>®, so you enter all
	    your constants in reverse and force them to the
	    <span class="emphasis"><em>network byte order</em></span>.  It works
	    well.</p><p>Then, some day, your trusted old <span class="trademark">Pentium</span>® becomes a
	    rusty old <span class="trademark">Pentium</span>®.  You replace it with a system whose
	    <span class="emphasis"><em>host order</em></span> is the same as the
	    <span class="emphasis"><em>network order</em></span>.  You need to recompile
	    all your software.  All of your software continues to
	    perform well, except the one program you wrote.</p><p>You have since forgotten that you had forced all of
	    your constants to the opposite of the <span class="emphasis"><em>host
	      order</em></span>.  You spend some quality time tearing
	    out your hair, calling the names of all gods you ever
	    heard of (and some you made up), hitting your monitor with
	    a nerf bat, and performing all the other traditional
	    ceremonies of trying to figure out why something that has
	    worked so well is suddenly not working at all.</p><p>Eventually, you figure it out, say a couple of swear
	    words, and start rewriting your code.</p><p>Luckily, you are not the first one to face the
	    problem.  Someone else has created the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=htons&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">htons</span>(3)</span></a> and
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=htonl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">htonl</span>(3)</span></a> C functions to convert a
	    <code class="varname">short</code> and <code class="varname">long</code>
	    respectively from the <span class="emphasis"><em>host byte order</em></span>
	    to the <span class="emphasis"><em>network byte order</em></span>, and the
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ntohs&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ntohs</span>(3)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ntohl</span>(3)</span></a> C functions to go the
	    other way.</p><p>On <span class="emphasis"><em><acronym class="acronym">MSB</acronym>-first</em></span>
	    systems these functions do nothing.  On
	    <span class="emphasis"><em><acronym class="acronym">LSB</acronym>-first</em></span> systems
	    they convert values to the proper order.</p><p>So, regardless of what system your software is
	    compiled on, your data will end up in the correct order if
	    you use these functions.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-client-functions"></a>7.5.1.2. Client Functions</h4></div></div></div><p>Typically, the client initiates the connection to the
	  server.  The client knows which server it is about to call:
	  It knows its <acronym class="acronym">IP</acronym> address, and it knows the
	  <span class="emphasis"><em>port</em></span> the server resides at.  It is akin
	  to you picking up the phone and dialing the number (the
	  <span class="emphasis"><em>address</em></span>), then, after someone answers,
	  asking for the person in charge of wingdings (the
	  <span class="emphasis"><em>port</em></span>).</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-connect"></a>7.5.1.2.1. <code class="function">connect</code></h5></div></div></div><p>Once a client has created a socket, it needs to
	    connect it to a specific port on a remote system.  It uses
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a>:</p><pre class="programlisting">int connect(int s, const struct sockaddr *name, socklen_t namelen);</pre><p>The <code class="varname">s</code> argument is the socket, i.e.,
	    the value returned by the <code class="function">socket</code>
	    function.  The <code class="varname">name</code> is a pointer to
	    <code class="varname">sockaddr</code>, the structure we have talked
	    about extensively.  Finally, <code class="varname">namelen</code>
	    informs the system how many bytes are in our
	    <code class="varname">sockaddr</code> structure.</p><p>If <code class="function">connect</code> is successful, it
	    returns <code class="constant">0</code>.  Otherwise it returns
	    <code class="constant">-1</code> and stores the error code in
	    <code class="varname">errno</code>.</p><p>There are many reasons why
	    <code class="function">connect</code> may fail.  For example, with
	    an attempt to an Internet connection, the
	    <acronym class="acronym">IP</acronym> address may not exist, or it may be
	    down, or just too busy, or it may not have a server
	    listening at the specified port.  Or it may outright
	    <span class="emphasis"><em>refuse</em></span> any request for specific
	    code.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-first-client"></a>7.5.1.2.2. Our First Client</h5></div></div></div><p>We now know enough to write a very simple client, one
	    that will get current time from <code class="systemitem">192.43.244.18</code> and print
	    it to <code class="filename">stdout</code>.</p><pre class="programlisting">/*
 * daytime.c
 *
 * Programmed by G. Adam Stanislav
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main() {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  char buffer[BUFSIZ+1];

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror("socket");
    return 1;
  }

  bzero(&amp;sa, sizeof sa);

  sa.sin_family = AF_INET;
  sa.sin_port = htons(13);
  sa.sin_addr.s_addr = htonl((((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18);
  if (connect(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
    perror("connect");
    close(s);
    return 2;
  }

  while ((bytes = read(s, buffer, BUFSIZ)) &gt; 0)
    write(1, buffer, bytes);

  close(s);
  return 0;
}</pre><p>Go ahead, enter it in your editor, save it as
	    <code class="filename">daytime.c</code>, then compile and run
	    it:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -O3 -o daytime daytime.c</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>./daytime</code></strong>

52079 01-06-19 02:29:25 50 0 1 543.9 UTC(NIST) *
<code class="prompt">%</code></pre><p>In this case, the date was June 19, 2001, the time was
	    02:29:25 <acronym class="acronym">UTC</acronym>.  Naturally, your results
	    will vary.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-server-functions"></a>7.5.1.3. Server Functions</h4></div></div></div><p>The typical server does not initiate the connection.
	  Instead, it waits for a client to call it and request
	  services.  It does not know when the client will call, nor
	  how many clients will call.  It may be just sitting there,
	  waiting patiently, one moment, The next moment, it can find
	  itself swamped with requests from a number of clients, all
	  calling in at the same time.</p><p>The sockets interface offers three basic functions to
	  handle this.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-bind"></a>7.5.1.3.1. <code class="function">bind</code></h5></div></div></div><p>Ports are like extensions to a phone line: After you
	    dial a number, you dial the extension to get to a specific
	    person or department.</p><p>There are 65535 <acronym class="acronym">IP</acronym> ports, but a
	    server usually processes requests that come in on only one
	    of them.  It is like telling the phone room operator that
	    we are now at work and available to answer the phone at a
	    specific extension.  We use <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a> to tell sockets
	    which port we want to serve.</p><pre class="programlisting">int bind(int s, const struct sockaddr *addr, socklen_t addrlen);</pre><p>Beside specifying the port in <code class="varname">addr</code>,
	    the server may include its <acronym class="acronym">IP</acronym> address.
	    However, it can just use the symbolic constant
	    <span class="symbol">INADDR_ANY</span> to indicate it will serve all
	    requests to the specified port regardless of what its
	    <acronym class="acronym">IP</acronym> address is.  This symbol, along with
	    several similar ones, is declared in
	    <code class="filename">netinet/in.h</code></p><pre class="programlisting">#define	INADDR_ANY		(u_int32_t)0x00000000</pre><p>Suppose we were writing a server for the
	    <span class="emphasis"><em>daytime</em></span> protocol over
	    <acronym class="acronym">TCP</acronym>/<acronym class="acronym">IP</acronym>.  Recall that
	    it uses port 13.  Our <code class="varname">sockaddr_in</code>
	    structure would look like this:</p><div class="mediaobject"><img src="sockets/sainserv.png" alt="Example Server sockaddr_in" /></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-listen"></a>7.5.1.3.2. <code class="function">listen</code></h5></div></div></div><p>To continue our office phone analogy, after you have
	    told the phone central operator what extension you will be
	    at, you now walk into your office, and make sure your own
	    phone is plugged in and the ringer is turned on.  Plus,
	    you make sure your call waiting is activated, so you can
	    hear the phone ring even while you are talking to
	    someone.</p><p>The server ensures all of that with the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=listen&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">listen</span>(2)</span></a>
	    function.</p><pre class="programlisting">int listen(int s, int backlog);</pre><p>In here, the <code class="varname">backlog</code> variable tells
	    sockets how many incoming requests to accept while you are
	    busy processing the last request.  In other words, it
	    determines the maximum size of the queue of pending
	    connections.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-accept"></a>7.5.1.3.3. <code class="function">accept</code></h5></div></div></div><p>After you hear the phone ringing, you accept the call
	    by answering the call.  You have now established a
	    connection with your client.  This connection remains
	    active until either you or your client hang up.</p><p>The server accepts the connection by using the
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">accept</span>(2)</span></a> function.</p><pre class="programlisting">int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</pre><p>Note that this time <code class="varname">addrlen</code> is a
	    pointer.  This is necessary because in this case it is the
	    socket that fills out <code class="varname">addr</code>, the
	    <code class="varname">sockaddr_in</code> structure.</p><p>The return value is an integer.  Indeed, the
	    <code class="function">accept</code> returns a <span class="emphasis"><em>new
	      socket</em></span>.  You will use this new socket to
	    communicate with the client.</p><p>What happens to the old socket? It continues to listen
	    for more requests (remember the <code class="varname">backlog</code>
	    variable we passed to <code class="function">listen</code>?) until
	    we <code class="function">close</code> it.</p><p>Now, the new socket is meant only for communications.
	    It is fully connected.  We cannot pass it to
	    <code class="function">listen</code> again, trying to accept
	    additional connections.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="sockets-first-server"></a>7.5.1.3.4. Our First Server</h5></div></div></div><p>Our first server will be somewhat more complex than
	    our first client was: Not only do we have more sockets
	    functions to use, but we need to write it as a
	    daemon.</p><p>This is best achieved by creating a <span class="emphasis"><em>child
	      process</em></span> after binding the port.  The main
	    process then exits and returns control to the
	    <span class="application">shell</span> (or whatever program
	    invoked it).</p><p>The child calls <code class="function">listen</code>, then
	    starts an endless loop, which accepts a connection, serves
	    it, and eventually closes its socket.</p><pre class="programlisting">/*
 * daytimed - a port 13 server
 *
 * Programmed by G. Adam Stanislav
 * June 19, 2001
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define BACKLOG 4

int main() {
    register int s, c;
    int b;
    struct sockaddr_in sa;
    time_t t;
    struct tm *tm;
    FILE *client;

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror("socket");
        return 1;
    }

    bzero(&amp;sa, sizeof sa);

    sa.sin_family = AF_INET;
    sa.sin_port   = htons(13);

    if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
        perror("bind");
        return 2;
    }

    switch (fork()) {
        case -1:
            perror("fork");
            return 3;
            break;
        default:
            close(s);
            return 0;
            break;
        case 0:
            break;
    }

    listen(s, BACKLOG);

    for (;;) {
        b = sizeof sa;

        if ((c = accept(s, (struct sockaddr *)&amp;sa, &amp;b)) &lt; 0) {
            perror("daytimed accept");
            return 4;
        }

        if ((client = fdopen(c, "w")) == NULL) {
            perror("daytimed fdopen");
            return 5;
        }

        if ((t = time(NULL)) &lt; 0) {
            perror("daytimed time");

            return 6;
        }

        tm = gmtime(&amp;t);
        fprintf(client, "%.4i-%.2i-%.2iT%.2i:%.2i:%.2iZ\n",
            tm-&gt;tm_year + 1900,
            tm-&gt;tm_mon + 1,
            tm-&gt;tm_mday,
            tm-&gt;tm_hour,
            tm-&gt;tm_min,
            tm-&gt;tm_sec);

        fclose(client);
    }
}</pre><p>We start by creating a socket.  Then we fill out the
	    <code class="varname">sockaddr_in</code> structure in
	    <code class="varname">sa</code>.  Note the conditional use of
	    <span class="symbol">INADDR_ANY</span>:</p><pre class="programlisting">if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);</pre><p>Its value is <code class="constant">0</code>.  Since we have
	    just used <code class="function">bzero</code> on the entire
	    structure, it would be redundant to set it to
	    <code class="constant">0</code> again.  But if we port our code to
	    some other system where <span class="symbol">INADDR_ANY</span> is
	    perhaps not a zero, we need to assign it to
	    <code class="varname">sa.sin_addr.s_addr</code>.  Most modern C
	    compilers are clever enough to notice that
	    <span class="symbol">INADDR_ANY</span> is a constant.  As long as it
	    is a zero, they will optimize the entire conditional
	    statement out of the code.</p><p>After we have called <code class="function">bind</code>
	    successfully, we are ready to become a
	    <span class="emphasis"><em>daemon</em></span>: We use
	    <code class="function">fork</code> to create a child process.  In
	    both, the parent and the child, the <code class="varname">s</code>
	    variable is our socket.  The parent process will not need
	    it, so it calls <code class="function">close</code>, then it
	    returns <code class="constant">0</code> to inform its own parent it
	    had terminated successfully.</p><p>Meanwhile, the child process continues working in the
	    background.  It calls <code class="function">listen</code> and sets
	    its backlog to <code class="constant">4</code>.  It does not need a
	    large value here because <span class="emphasis"><em>daytime</em></span> is
	    not a protocol many clients request all the time, and
	    because it can process each request instantly
	    anyway.</p><p>Finally, the daemon starts an endless loop, which
	    performs the following steps:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Call <code class="function">accept</code>.  It waits here
		until a client contacts it.  At that point, it
		receives a new socket, <code class="varname">c</code>, which it
		can use to communicate with this particular
		client.</p></li><li class="step"><p>It uses the C function <code class="function">fdopen</code>
		to turn the socket from a low-level <span class="emphasis"><em>file
		  descriptor</em></span> to a C-style
		<code class="varname">FILE</code> pointer.  This will allow the
		use of <code class="function">fprintf</code> later
		on.</p></li><li class="step"><p>It checks the time, and prints it in the
		<span class="emphasis"><em><acronym class="acronym">ISO</acronym> 8601</em></span>
		format to the <code class="varname">client</code>
		<span class="quote">&#8220;<span class="quote">file</span>&#8221;</span>.  It then uses
		<code class="function">fclose</code> to close the file.  That
		will automatically close the socket as
		well.</p></li></ol></div><p>We can <span class="emphasis"><em>generalize</em></span> this, and use
	    it as a model for many other servers:</p><div class="mediaobject"><img src="sockets/serv.png" alt="Sequential Server" /></div><p>This flowchart is good for <span class="emphasis"><em>sequential
	      servers</em></span>, i.e., servers that can serve one
	    client at a time, just as we were able to with our
	    <span class="emphasis"><em>daytime</em></span> server.  This is only
	    possible whenever there is no real
	    <span class="quote">&#8220;<span class="quote">conversation</span>&#8221;</span> going on between the client
	    and the server: As soon as the server detects a connection
	    to the client, it sends out some data and closes the
	    connection.  The entire operation may take nanoseconds,
	    and it is finished.</p><p>The advantage of this flowchart is that, except for
	    the brief moment after the parent
	    <code class="function">fork</code>s and before it exits, there is
	    always only one <span class="emphasis"><em>process</em></span> active: Our
	    server does not take up much memory and other system
	    resources.</p><p>Note that we have added <span class="emphasis"><em>initialize
	      daemon</em></span> in our flowchart.  We did not need to
	    initialize our own daemon, but this is a good place in the
	    flow of the program to set up any
	    <code class="function">signal</code> handlers, open any files we
	    may need, etc.</p><p>Just about everything in the flow chart can be used
	    literally on many different servers.  The
	    <span class="emphasis"><em>serve</em></span> entry is the exception.  We
	    think of it as a <span class="emphasis"><em><span class="quote">&#8220;<span class="quote">black
		box</span>&#8221;</span></em></span>, i.e., something you design
	    specifically for your own server, and just <span class="quote">&#8220;<span class="quote">plug it
	      into the rest.</span>&#8221;</span></p><p>Not all protocols are that simple.  Many receive a
	    request from the client, reply to it, then receive another
	    request from the same client.  Because of that, they do
	    not know in advance how long they will be serving the
	    client.  Such servers usually start a new process for each
	    client.  While the new process is serving its client, the
	    daemon can continue listening for more connections.</p><p>Now, go ahead, save the above source code as
	    <code class="filename">daytimed.c</code> (it is customary to end
	    the names of daemons with the letter
	    <code class="constant">d</code>).  After you have compiled it, try
	    running it:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./daytimed</code></strong>
bind: Permission denied
<code class="prompt">%</code></pre><p>What happened here? As you will recall, the
	    <span class="emphasis"><em>daytime</em></span> protocol uses port 13.  But
	    all ports below 1024 are reserved to the superuser
	    (otherwise, anyone could start a daemon pretending to
	    serve a commonly used port, while causing a security
	    breach).</p><p>Try again, this time as the superuser:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>./daytimed</code></strong>
<code class="prompt">#</code></pre><p>What... Nothing? Let us try again:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>./daytimed</code></strong>

bind: Address already in use
<code class="prompt">#</code></pre><p>Every port can only be bound by one program at a time.
	    Our first attempt was indeed successful: It started the
	    child daemon and returned quietly.  It is still running
	    and will continue to run until you either kill it, or any
	    of its system calls fail, or you reboot the system.</p><p>Fine, we know it is running in the background.  But is
	    it working?  How do we know it is a proper
	    <span class="emphasis"><em>daytime</em></span> server?  Simple:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>telnet localhost 13</code></strong>

Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
2001-06-19T21:04:42Z
Connection closed by foreign host.
<code class="prompt">%</code></pre><p><span class="application">telnet</span> tried the new
	    <acronym class="acronym">IP</acronym>v6, and failed.  It retried with
	    <acronym class="acronym">IP</acronym>v4 and succeeded.  The daemon
	    works.</p><p>If you have access to another <span class="trademark">UNIX</span>® system via
	    <span class="application">telnet</span>, you can use it to test
	    accessing the server remotely.  My computer does not have
	    a static <acronym class="acronym">IP</acronym> address, so this is what I
	    did:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>who</code></strong>

whizkid          ttyp0   Jun 19 16:59   (216.127.220.143)
xxx              ttyp1   Jun 19 16:06   (xx.xx.xx.xx)
<code class="prompt">%</code> <strong class="userinput"><code>telnet 216.127.220.143 13</code></strong>

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is '^]'.
2001-06-19T21:31:11Z
Connection closed by foreign host.
<code class="prompt">%</code></pre><p>Again, it worked.  Will it work using the domain
	    name?</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>telnet r47.bfm.org 13</code></strong>

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is '^]'.
2001-06-19T21:31:40Z
Connection closed by foreign host.
<code class="prompt">%</code></pre><p>By the way, <span class="application">telnet</span> prints
	    the <span class="emphasis"><em>Connection closed by foreign host</em></span>
	    message after our daemon has closed the socket.  This
	    shows us that, indeed, using
	    <code class="function">fclose(client);</code> in our code works as
	    advertised.</p></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sockets-model.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sockets.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sockets-helper-functions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.4. The Sockets Model </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.6. Helper Functions</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>