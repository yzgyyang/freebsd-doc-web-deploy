<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>3.3. Buffer Overflows</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="secure.html" title="Chapter 3. Secure Programming" /><link rel="prev" href="secure-philosophy.html" title="3.2. Secure Design Methodology" /><link rel="next" href="secure-setuid.html" title="3.4. SetUID issues" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. Buffer Overflows</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="secure-philosophy.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Secure Programming</th><td width="20%" align="right"> <a accesskey="n" href="secure-setuid.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="secure-bufferov"></a>3.3. Buffer Overflows</h2></div></div></div><p>Buffer Overflows have been around since the very
      beginnings of the von Neumann <a class="xref" href="bi01.html#COD">1</a> architecture.

      <a id="idp51275000" class="indexterm"></a>
      <a id="idp51275512" class="indexterm"></a>

      They first gained widespread notoriety in 1988 with the Morris
      Internet worm.  Unfortunately, the same basic attack remains

      <a id="idp51276024" class="indexterm"></a>

      effective today.
      By far the most common type of buffer overflow attack is based
      on corrupting the stack.</p><a id="idp51276792" class="indexterm"></a><a id="idp51277304" class="indexterm"></a><p>Most modern computer systems use a stack to pass arguments
      to procedures and to store local variables.  A stack is a last
      in first out (LIFO) buffer in the high memory area of a process
      image.  When a program invokes a function a new "stack frame" is

      <a id="idp51278072" class="indexterm"></a>
      <a id="idp51278584" class="indexterm"></a>

      created.  This stack frame consists of the arguments passed to
      the function as well as a dynamic amount of local variable
      space.  The "stack pointer" is a register that holds the current

      <a id="idp51279736" class="indexterm"></a>
      <a id="idp51280248" class="indexterm"></a>

      location of the top of the stack.  Since this value is
      constantly changing as new values are pushed onto the top of the
      stack, many implementations also provide a "frame pointer" that
      is located near the beginning of a stack frame so that local
      variables can more easily be addressed relative to this
      value. <a class="xref" href="bi01.html#COD">1</a> The return address for function

      <a id="idp51285240" class="indexterm"></a>
      <a id="idp51285752" class="indexterm"></a>
      <a id="idp51286904" class="indexterm"></a>
      <a id="idp51287416" class="indexterm"></a>

      calls is also stored on the stack, and this is the cause of
      stack-overflow exploits since overflowing a local variable in a
      function can overwrite the return address of that function,
      potentially allowing a malicious user to execute any code he or
      she wants.</p><p>Although stack-based attacks are by far the most common,
      it would also be possible to overrun the stack with a heap-based
      (malloc/free) attack.</p><p>The C programming language does not perform automatic
      bounds checking on arrays or pointers as many other languages
      do.  In addition, the standard C library is filled with a
      handful of very dangerous functions.</p><div class="informaltable"><table class="informaltable" width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><code class="function">strcpy</code>(char *dest, const char
          *src)</td><td><p>May overflow the dest buffer</p></td></tr><tr><td><code class="function">strcat</code>(char *dest, const char
          *src)</td><td><p>May overflow the dest buffer</p></td></tr><tr><td><code class="function">getwd</code>(char *buf)</td><td><p>May overflow the buf buffer</p></td></tr><tr><td><code class="function">gets</code>(char *s)</td><td><p>May overflow the s buffer</p></td></tr><tr><td><code class="function">[vf]scanf</code>(const char *format,
          ...)</td><td><p>May overflow its arguments.</p></td></tr><tr><td><code class="function">realpath</code>(char *path, char
          resolved_path[])</td><td><p>May overflow the path buffer</p></td></tr><tr><td><code class="function">[v]sprintf</code>(char *str, const char
          *format, ...)</td><td><p>May overflow the str buffer.</p></td></tr></tbody></table></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp51316600"></a>3.3.1. Example Buffer Overflow</h3></div></div></div><p>The following example code contains a buffer overflow
      designed to overwrite the return address and skip the
      instruction immediately following the function call.  (Inspired
      by <a class="xref" href="bi01.html#Phrack">4</a>)</p><pre class="programlisting">#include &lt;stdio.h&gt;

void manipulate(char *buffer) {
  char newbuffer[80];
  strcpy(newbuffer,buffer);
}

int main() {
  char ch,buffer[4096];
  int i=0;

  while ((buffer[i++] = getchar()) != '\n') {};

  i=1;
  manipulate(buffer);
  i=2;
  printf("The value of i is : %d\n",i);
  return 0;
}</pre><p>Let us examine what the memory image of this process would
      look like if we were to input 160 spaces into our little program
      before hitting return.</p><p>[XXX figure here!]</p><p>Obviously more malicious input can be devised to execute
      actual compiled instructions (such as exec(/bin/sh)).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp51319672"></a>3.3.2. Avoiding Buffer Overflows</h3></div></div></div><p>The most straightforward solution to the problem of
      stack-overflows is to always use length restricted memory and
      string copy functions.  <code class="function">strncpy</code> and
      <code class="function">strncat</code> are part of the standard C library.

      <a id="idp51321208" class="indexterm"></a>
      <a id="idp51322360" class="indexterm"></a>

      These functions accept a length value as a parameter which
      should be no larger than the size of the destination buffer.
      These functions will then copy up to `length' bytes from the
      source to the destination.  However there are a number of
      problems with these functions.  Neither function guarantees NUL
      termination if the size of the input buffer is as large as the

      <a id="idp51323512" class="indexterm"></a>

      destination.  The length parameter is also used inconsistently
      between strncpy and strncat so it is easy for programmers to get
      confused as to their proper usage.  There is also a significant
      performance loss compared to <code class="function">strcpy</code> when
      copying a short string into a large buffer since
      <code class="function">strncpy</code> NUL fills up the size
      specified.</p><p>Another memory copy implementation exists
      to get around these problems.  The
      <code class="function">strlcpy</code> and <code class="function">strlcat</code>
      functions guarantee that they will always null terminate the
      destination string when given a non-zero length argument.</p><a id="idp51326072" class="indexterm"></a><a id="idp51327224" class="indexterm"></a><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp51328376"></a>3.3.2.1. Compiler based run-time bounds checking</h4></div></div></div><a id="idp51328888" class="indexterm"></a><p>Unfortunately there is still a very large assortment of
        code in public use which blindly copies memory around without
        using any of the bounded copy routines we just discussed.
        Fortunately, there is a way to help prevent such attacks &#8212;
        run-time bounds checking, which is implemented by several
        C/C++ compilers.</p><a id="idp51334264" class="indexterm"></a><a id="idp51334776" class="indexterm"></a><a id="idp51335288" class="indexterm"></a><p>ProPolice is one such compiler feature, and is integrated
	  into <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gcc</span>(1)</span></a> versions 4.1 and later.  It replaces and
	  extends the earlier StackGuard <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">gcc</span>(1)</span></a> extension.</p><p>ProPolice helps to protect against stack-based buffer
	  overflows and other attacks by laying pseudo-random numbers in
	  key areas of the stack before calling any function.  When a
	  function returns, these <span class="quote">&#8220;<span class="quote">canaries</span>&#8221;</span> are checked
	  and if they are found to have been changed the executable is
	  immediately aborted.  Thus any attempt to modify the return
	  address or other variable stored on the stack in an attempt to
	  get malicious code to run is unlikely to succeed, as the
	  attacker would have to also manage to leave the pseudo-random
	  canaries untouched.</p><a id="idp51338488" class="indexterm"></a><p>Recompiling your application with ProPolice is an
        effective means of stopping most buffer-overflow attacks, but
        it can still be compromised.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp51339512"></a>3.3.2.2. Library based run-time bounds checking</h4></div></div></div><a id="idp51340024" class="indexterm"></a><p>Compiler-based mechanisms are completely useless for
        binary-only software for which you cannot recompile.  For
        these situations there are a number of libraries which
        re-implement the unsafe functions of the C-library
        (<code class="function">strcpy</code>, <code class="function">fscanf</code>,
        <code class="function">getwd</code>, etc..) and ensure that these
        functions can never write past the stack pointer.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">libsafe</li><li class="listitem">libverify</li><li class="listitem">libparanoia</li></ul></div><p>Unfortunately these library-based defenses have a number
        of shortcomings.  These libraries only protect against a very
        small set of security related issues and they neglect to fix
        the actual problem.  These defenses may fail if the
        application was compiled with -fomit-frame-pointer.  Also, the
        LD_PRELOAD and LD_LIBRARY_PATH environment variables can be
        overwritten/unset by the user.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="secure-philosophy.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="secure.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="secure-setuid.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. Secure Design
      Methodology </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3.4. SetUID issues</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>