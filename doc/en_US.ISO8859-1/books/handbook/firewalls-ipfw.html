<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>30.4. IPFW</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Handbook" /><link rel="up" href="firewalls.html" title="Chapter 30. Firewalls" /><link rel="prev" href="firewalls-pf.html" title="30.3. PF" /><link rel="next" href="firewalls-ipf.html" title="30.5. IPFILTER (IPF)" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">30.4. <span class="application">IPFW</span></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="firewalls-pf.html">Prev</a> </td><th width="60%" align="center">Chapter 30. Firewalls</th><td width="20%" align="right"> <a accesskey="n" href="firewalls-ipf.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="firewalls-ipfw"></a>30.4. <span class="application">IPFW</span></h2></div></div></div><a id="idp71878520" class="indexterm"></a><p><span class="application">IPFW</span> is a stateful firewall
      written for FreeBSD which supports both <acronym class="acronym">IPv4</acronym> and
      <acronym class="acronym">IPv6</acronym>.  It is comprised of several components:
      the kernel firewall filter rule processor and its integrated
      packet accounting facility, the logging facility,
      <acronym class="acronym">NAT</acronym>, the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">dummynet</span>(4)</span></a> traffic shaper, a
      forward facility, a bridge facility, and an ipstealth
      facility.</p><p>FreeBSD provides a sample ruleset in
      <code class="filename">/etc/rc.firewall</code> which defines several
      firewall types for common scenarios to assist novice users in
      generating an appropriate ruleset.
      <span class="application">IPFW</span> provides a powerful syntax which
      advanced users can use to craft customized rulesets that meet
      the security requirements of a given environment.</p><p>This section describes how to enable
      <span class="application">IPFW</span>, provides an overview of its
      rule syntax, and demonstrates several rulesets for common
      configuration scenarios.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipfw-enable"></a>30.4.1. Enabling <span class="application">IPFW</span></h3></div></div></div><a id="idp71889400" class="indexterm"></a><p><span class="application">IPFW</span> is included in the basic
	FreeBSD install as a kernel loadable module, meaning that a
	custom kernel is not needed in order to enable
	<span class="application">IPFW</span>.</p><p>For those users who wish to statically compile
	<span class="application">IPFW</span> support into a custom kernel,
	see <a class="xref" href="firewalls-ipfw.html#firewalls-ipfw-kernelconfig" title="30.4.6. IPFW Kernel Options">Section 30.4.6, &#8220;<span class="application">IPFW</span> Kernel Options&#8221;</a>.</p><p>To configure the system to enable
	<span class="application">IPFW</span> at boot time, add
	<code class="literal">firewall_enable="YES"</code> to
	<code class="filename">/etc/rc.conf</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc firewall_enable="YES"</code></strong></pre><p>To use one of the default firewall types provided by FreeBSD,
	add another line which specifies the type:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc firewall_type="open"</code></strong></pre><p>The available types are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">open</code>: passes all traffic.</p></li><li class="listitem"><p><code class="literal">client</code>: protects only this
	    machine.</p></li><li class="listitem"><p><code class="literal">simple</code>: protects the whole
	    network.</p></li><li class="listitem"><p><code class="literal">closed</code>: entirely disables IP
	    traffic except for the loopback interface.</p></li><li class="listitem"><p><code class="literal">workstation</code>: protects only this
	    machine using stateful rules.</p></li><li class="listitem"><p><code class="literal">UNKNOWN</code>: disables the loading of
	    firewall rules.</p></li><li class="listitem"><p><code class="filename"><em class="replaceable"><code>filename</code></em></code>:
	    full path of the file containing the firewall
	    ruleset.</p></li></ul></div><p>If <code class="literal">firewall_type</code> is set to either
	<code class="literal">client</code> or <code class="literal">simple</code>,
	modify the default rules found in
	<code class="filename">/etc/rc.firewall</code> to fit the
	configuration of the system.</p><p>Note that the <code class="literal">filename</code> type is used to
	load a custom ruleset.</p><p>An alternate way to load a custom ruleset is to set the
	<code class="literal">firewall_script</code> variable to the absolute
	path of an <span class="emphasis"><em>executable script</em></span> that
	includes <span class="application">IPFW</span> commands.    The
	examples used in this section assume that the
	<code class="literal">firewall_script</code> is set to
	<code class="filename">/etc/ipfw.rules</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc firewall_script="/etc/ipfw.rules"</code></strong></pre><p>To enable logging through <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">syslogd</span>(8)</span></a>, include this
	line:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc firewall_logging="YES"</code></strong></pre><div xmlns="" class="warning"><h3 class="admontitle">Warning: </h3><p xmlns="http://www.w3.org/1999/xhtml">Only firewall rules with the <code class="option">log</code> option will
	  be logged.  The default rules do not include this option and it
	  must be manually added.  Therefore it is advisable that the default
	  ruleset is edited for logging.  In addition, log rotation may be
	  desired if the logs are stored in a separate file.</p></div><p>There is no <code class="filename">/etc/rc.conf</code> variable to
	set logging limits.  To limit the number of times a rule is
	logged per connection attempt, specify the number using this
	line in <code class="filename">/etc/sysctl.conf</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>echo "net.inet.ip.fw.verbose_limit=<em class="replaceable"><code>5</code></em>" &gt;&gt; /etc/sysctl.conf</code></strong></pre><p>To enable logging through a dedicated interface named
	<code class="literal">ipfw0</code>, add this line to
	<code class="filename">/etc/rc.conf</code> instead:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc firewall_logif="YES"</code></strong></pre><p>Then use <span class="application">tcpdump</span> to see what is
	being logged:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>tcpdump -t -n -i ipfw0</code></strong></pre><div xmlns="" class="tip"><h3 class="admontitle">Tip: </h3><p xmlns="http://www.w3.org/1999/xhtml">There is no overhead due to logging unless
	  <span class="application">tcpdump</span> is attached.</p></div><p>After saving the needed edits, start the firewall.  To
	enable logging limits now, also set the
	<code class="command">sysctl</code> value specified above:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service ipfw start</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sysctl net.inet.ip.fw.verbose_limit=<em class="replaceable"><code>5</code></em></code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipfw-rules"></a>30.4.2. <span class="application">IPFW</span> Rule Syntax</h3></div></div></div><a id="idp71965816" class="indexterm"></a><p>When a packet enters the <span class="application">IPFW</span>
	firewall, it is compared against the first rule in the ruleset
	and progresses one rule at a time, moving from top to bottom
	in sequence.  When the packet matches the selection parameters
	of a rule, the rule's action is executed and the search of the
	ruleset terminates for that packet.  This is referred to as
	<span class="quote">&#8220;<span class="quote">first match wins</span>&#8221;</span>.  If the packet does not match
	any of the rules, it gets caught by the mandatory
	<span class="application">IPFW</span> default rule number 65535,
	which denies all packets and silently discards them.  However,
	if the packet matches a rule that contains the
	<code class="literal">count</code>, <code class="literal">skipto</code>, or
	<code class="literal">tee</code> keywords, the search continues.  Refer
	to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> for details on how these keywords affect rule
	processing.</p><a id="idp71974648" class="indexterm"></a><p>When creating an
	<span class="application">IPFW</span> rule, keywords must be
	written in the following order.  Some keywords are mandatory
	while other keywords are optional.  The words shown in
	uppercase represent a variable and the words shown in
	lowercase must precede the variable that follows it.  The
	<code class="literal">#</code> symbol is used to mark the start of a
	comment and may appear at the end of a rule or on its own
	line.  Blank lines are ignored.</p><p><em class="replaceable"><code>CMD RULE_NUMBER set SET_NUMBER ACTION log
	  LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT
	  OPTIONS</code></em></p><p>This section provides an overview of these keywords and
	their options.  It is not an exhaustive list of every possible
	option.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> for a complete description of
	the rule syntax that can be used when creating
	<span class="application">IPFW</span> rules.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CMD</span></dt><dd><p>Every rule must start with
	      <em class="parameter"><code>ipfw add</code></em>.</p></dd><dt><span class="term">RULE_NUMBER</span></dt><dd><p>Each rule is associated with a number from
	      <code class="literal">1</code> to
	      <code class="literal">65534</code>.  The number is used to
	      indicate the order of rule processing.  Multiple rules
	      can have the same number, in which case they are applied
	      according to the order in which they have been
	      added.</p></dd><dt><span class="term">SET_NUMBER</span></dt><dd><p>Each rule is associated with a set number from
	      <code class="literal">0</code> to <code class="literal">31</code>.
	      Sets can be individually disabled or enabled, making it
	      possible to quickly add or delete a set of rules.  If a
	      SET_NUMBER is not specified, the rule will be added to
	      set <code class="literal">0</code>.</p></dd><dt><span class="term">ACTION</span></dt><dd><p>A rule can be associated with one of the following
	      actions.  The specified action will be executed when the
	      packet matches the selection criterion of the
	      rule.</p><p><em class="parameter"><code>allow | accept | pass |
		permit</code></em>: these keywords are equivalent and
	      allow packets that match the rule.</p><p><em class="parameter"><code>check-state</code></em>: checks the
	      packet against the dynamic state table.  If a match is
	      found, execute the action associated with the rule which
	      generated this dynamic rule, otherwise move to the next
	      rule.  A <code class="literal">check-state</code> rule does not
	      have selection criterion.  If no
	      <code class="literal">check-state</code> rule is present in the
	      ruleset, the dynamic rules table is checked at the first
	      <code class="literal">keep-state</code> or
	      <code class="literal">limit</code> rule.</p><p><em class="parameter"><code>count</code></em>: updates counters for
	      all packets that match the rule.  The search continues
	      with the next rule.</p><p><em class="parameter"><code>deny | drop</code></em>: either word
	      silently discards packets that match this rule.</p><p>Additional actions are available.  Refer to
	      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> for details.</p></dd><dt><span class="term">LOG_AMOUNT</span></dt><dd><p>When a packet matches a rule with the
	      <code class="literal">log</code> keyword, a message will be logged
	      to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">syslogd</span>(8)</span></a> with a facility name of
	      <code class="literal">SECURITY</code>.  Logging only occurs if the
	      number of packets logged for that particular rule does
	      not exceed a specified LOG_AMOUNT.  If no
	      LOG_AMOUNT is specified, the limit is taken from the
	      value of
	      <code class="varname">net.inet.ip.fw.verbose_limit</code>.  A
	      value of zero removes the logging limit.  Once the limit
	      is reached, logging can be re-enabled by clearing the
	      logging counter or the packet counter for that rule,
	      using <code class="command">ipfw resetlog</code>.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Logging is done after all other packet matching
		conditions have been met, and before performing the
		final action on the packet.  The administrator decides
		which rules to enable logging on.</p></div></dd><dt><span class="term">PROTO</span></dt><dd><p>This optional value can be used to specify any
	      protocol name or number found in
	      <code class="filename">/etc/protocols</code>.</p></dd><dt><span class="term">SRC</span></dt><dd><p>The <code class="literal">from</code> keyword must be followed
	      by the source address or a keyword that represents the
	      source address.  An address can be represented by
	      <code class="literal">any</code>, <code class="literal">me</code> (any
	      address configured on an interface on this system),
	      <code class="literal">me6</code>, (any <acronym class="acronym">IPv6</acronym>
	      address configured on an interface on this system), or
	      <code class="literal">table</code> followed by the number of a
	      lookup table which contains a list of addresses.  When
	      specifying an <acronym class="acronym">IP</acronym> address, it can be
	      optionally followed by its <acronym class="acronym">CIDR</acronym> mask
	      or subnet mask.  For example,
	      <code class="literal">1.2.3.4/25</code> or
	      <code class="literal">1.2.3.4:255.255.255.128</code>.</p></dd><dt><span class="term">SRC_PORT</span></dt><dd><p>An optional source port can be specified using the
	      port number or name from
	      <code class="filename">/etc/services</code>.</p></dd><dt><span class="term">DST</span></dt><dd><p>The <code class="literal">to</code> keyword must be followed
	      by the destination address or a keyword that represents
	      the destination address.  The same keywords and
	      addresses described in the SRC section can be used to
	      describe the destination.</p></dd><dt><span class="term">DST_PORT</span></dt><dd><p>An optional destination port can be specified using
	      the port number or name from
	      <code class="filename">/etc/services</code>.</p></dd><dt><span class="term">OPTIONS</span></dt><dd><p>Several keywords can follow the source and
	      destination.  As the name suggests, OPTIONS are
	      optional.  Commonly used options include
	      <code class="literal">in</code> or <code class="literal">out</code>, which
	      specify the direction of packet flow,
	      <code class="literal">icmptypes</code> followed by the type of
	      <acronym class="acronym">ICMP</acronym> message, and
	      <code class="literal">keep-state</code>.</p><p>When a <em class="parameter"><code>keep-state</code></em> rule is
	      matched, the firewall will create a dynamic rule which
	      matches bidirectional traffic between the source and
	      destination addresses and ports using the same
	      protocol.</p><p>The dynamic rules facility is vulnerable to resource
	      depletion from a SYN-flood attack which would open a
	      huge number of dynamic rules.  To counter this type of
	      attack with  <span class="application">IPFW</span>, use
	      <code class="literal">limit</code>.  This option limits the number
	      of simultaneous sessions by checking the open dynamic
	      rules, counting the number of times this rule and
	      <acronym class="acronym">IP</acronym> address combination occurred.  If
	      this count is greater than the value specified by
	      <code class="literal">limit</code>, the packet is
	      discarded.</p><p>Dozens of OPTIONS are available.  Refer to
	      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> for a description of each available
	      option.</p></dd></dl></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72047096"></a>30.4.3. Example Ruleset</h3></div></div></div><p>This section demonstrates how to create an example
	stateful firewall ruleset script named
	<code class="filename">/etc/ipfw.rules</code>.  In this example, all
	connection rules use <code class="literal">in</code> or
	<code class="literal">out</code> to clarify the direction.  They also
	use <code class="literal">via</code>
	<em class="replaceable"><code>interface-name</code></em> to specify
	the interface the packet is traveling over.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">When first creating or testing a firewall ruleset,
	  consider temporarily setting this tunable:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">net.inet.ip.fw.default_to_accept="1"</pre><p xmlns="http://www.w3.org/1999/xhtml">This sets the default policy of <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> to be more
	  permissive than the default <code class="literal">deny ip from any to
	    any</code>, making it slightly more difficult to get
	  locked out of the system right after a reboot.</p></div><p>The firewall script begins by indicating that it is a
	Bourne shell script and flushes any existing rules.  It then
	creates the <code class="literal">cmd</code> variable so that
	<code class="literal">ipfw add</code> does not have to be typed at the
	beginning of every rule.  It also defines the
	<code class="literal">pif</code> variable which represents the name of
	the interface that is attached to the Internet.</p><pre class="programlisting">#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # interface name of NIC attached to Internet</pre><p>The first two rules allow all traffic on the trusted
	internal interface and on the loopback interface:</p><pre class="programlisting"># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre><p>The next rule allows the packet through if it matches an
	existing entry in the dynamic rules table:</p><pre class="programlisting">$cmd 00101 check-state</pre><p>The next set of rules defines which stateful connections
	internal systems can create to hosts on the Internet:</p><pre class="programlisting"># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP's DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre><p>The next set of rules controls connections from Internet
	hosts to the internal network.  It starts by denying packets
	typically associated with attacks and then explicitly allows
	specific types of connections.  All the authorized services
	that originate from the Internet use <code class="literal">limit</code>
	to prevent flooding.</p><pre class="programlisting"># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP's DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre><p>The last rule logs all packets that do not match any of
	the rules in the ruleset:</p><pre class="programlisting"># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="in-kernel-nat"></a>30.4.4. In-kernel <acronym class="acronym">NAT</acronym></h3></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Chern</span> <span class="surname">Lee</span></span>. </span></div><div><span class="authorgroup">Rewritten and updated by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Dries</span> <span class="surname">Michiels</span></span>. </span></div></div></div><a id="idp72060920" class="indexterm"></a><p>FreeBSD's <span class="application">IPFW</span> firewall has two
	implementations of <acronym class="acronym">NAT</acronym>: the userland
	implementation <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a>, and the more recent in-kernel
	<acronym class="acronym">NAT</acronym> implementation.  Both work in
	conjunction with <span class="application">IPFW</span> to provide
	network address translation.  This can be used to provide an
	Internet Connection Sharing solution so that several internal
	computers can connect to the Internet using a single public
	<acronym class="acronym">IP</acronym> address.</p><p>To do this, the FreeBSD machine connected to the Internet
	must act as a gateway.  This system must have two
	<acronym class="acronym">NIC</acronym>s, where one is connected to the
	Internet and the other is connected to the internal
	<acronym class="acronym">LAN</acronym>.  Each machine connected to the
	<acronym class="acronym">LAN</acronym> should be assigned an
	<acronym class="acronym">IP</acronym> address in the private network space, as
	defined by <a class="link" href="https://www.ietf.org/rfc/rfc1918.txt" target="_top">RFC
	1918</a>.</p><p>Some additional configuration is needed in order to enable
	the in-kernel <acronym class="acronym">NAT</acronym> facility of
	<span class="application">IPFW</span>.  To enable in-kernel
	<acronym class="acronym">NAT</acronym> support at boot time, the following
	must be set in <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">gateway_enable="YES"
firewall_enable="YES"
firewall_nat_enable="YES"</pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">When <code class="literal">firewall_nat_enable</code> is set but
	  <code class="literal">firewall_enable</code> is not, it will have no
	  effect and do nothing.  This is because the in-kernel
	  <acronym class="acronym">NAT</acronym> implementation is only compatible
	  with <span class="application">IPFW</span>.</p></div><p>When the ruleset contains stateful rules, the positioning
	of the <acronym class="acronym">NAT</acronym> rule is critical and the
	<code class="literal">skipto</code> action is used.  The
	<code class="literal">skipto</code> action requires a rule number so
	that it knows which rule to jump to.  The example below builds
	upon the firewall ruleset shown in the previous section.  It
	adds some additional entries and modifies some existing rules
	in order to configure the firewall for in-kernel
	<acronym class="acronym">NAT</acronym>.  It starts by adding some additional
	variables which represent the rule number to skip to, the
	<code class="literal">keep-state</code> option, and a list of
	<acronym class="acronym">TCP</acronym> ports which will be used to reduce the
	number of rules.</p><pre class="programlisting">#!/bin/sh
ipfw -q -f flush
cmd="ipfw -q add"
skip="skipto 1000"
pif=dc0
ks="keep-state"
good_tcpo="22,25,37,53,80,443,110"</pre><p>With in-kernel <acronym class="acronym">NAT</acronym> it is
	necessary to disable TCP segmentation offloading
	(<acronym class="acronym">TSO</acronym>) due to the architecture of
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a>, a library implemented as a kernel module to
	provide the in-kernel <acronym class="acronym">NAT</acronym> facility of
	<span class="application">IPFW</span>.  <acronym class="acronym">TSO</acronym> can
	be disabled on a per network interface basis using
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a> or on a system wide basis using
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  To disable <acronym class="acronym">TSO</acronym> system
	wide, the following must be set it
	<code class="filename">/etc/sysctl.conf</code>:</p><pre class="programlisting">net.inet.tcp.tso="0"</pre><p>A <acronym class="acronym">NAT</acronym> instance will also be configured.
	It is possible to have multiple <acronym class="acronym">NAT</acronym>
	instances each with their own configuration.  For this example
	only one <acronym class="acronym">NAT</acronym> instance is needed,
	<acronym class="acronym">NAT</acronym> instance number 1.  The configuration
	can take a few options such as: <code class="option">if</code> which
	indicates the public interface, <code class="option">same_ports</code>
	which takes care that alliased ports and local port numbers
	are mapped the same, <code class="option">unreg_only</code> will result
	in only unregistered (private) address spaces to be processed
	by the <acronym class="acronym">NAT</acronym> instance, and
	<code class="option">reset</code> which will help to keep a functioning
	<acronym class="acronym">NAT</acronym> instance even when the public
	<acronym class="acronym">IP</acronym> address of the
	<span class="application">IPFW</span> machine changes.  For all
	possible options that can be passed to a single
	<acronym class="acronym">NAT</acronym> instance configuration consult
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a>.  When configuring a stateful
	<acronym class="acronym">NAT</acronym>ing firewall, it is neseccary to allow
	translated packets to be reinjected in the firewall for
	further processing.  This can be achieved by disabling
	<code class="option">one_pass</code> behavior at the start of the
	firewall script.</p><pre class="programlisting">ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre><p>The inbound <acronym class="acronym">NAT</acronym> rule is inserted
	<span class="emphasis"><em>after</em></span> the two rules which allow all
	traffic on the trusted and loopback interfaces and after the
	reassemble rule but <span class="emphasis"><em>before</em></span> the
	<code class="literal">check-state</code> rule.  It is important that the
	rule number selected for this <acronym class="acronym">NAT</acronym> rule, in
	this example <code class="literal">100</code>, is higher than the first
	three rules and lower than the <code class="literal">check-state</code>
	rule.  Furthermore, because of the behavior of in-kernel
	<acronym class="acronym">NAT</acronym> it is advised to place a reassemble
	rule just before the first <acronym class="acronym">NAT</acronym> rule and
	after the rules that allow traffic on trusted interface.
	Normally, <acronym class="acronym">IP</acronym> fragmentation should not
	happen, but when dealing with <acronym class="acronym">IPSEC/ESP/GRE</acronym>
	tunneling traffic it might and the reassembling of fragments
	is necessary before handing the complete packet over to the
	in-kernel <acronym class="acronym">NAT</acronym> facility.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">The reassemble rule was not needed with userland
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> because the internal workings of the
	  <span class="application">IPFW</span> <code class="literal">divert</code>
	  action already takes care of reassembling packets before
	  delivery to the socket as also stated in <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a>.</p><p xmlns="http://www.w3.org/1999/xhtml">The <acronym class="acronym">NAT</acronym> instance and rule number used
	  in this example does not match with the default
	  <acronym class="acronym">NAT</acronym> instance and rule number created by
	  <code class="filename">rc.firewall</code>.
	  <code class="filename">rc.firewall</code> is a script that sets up
	  the default firewall rules present in FreeBSD.</p></div><pre class="programlisting">$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre><p>The outbound rules are modified to replace the
	<code class="literal">allow</code> action with the
	<code class="literal">$skip</code> variable, indicating that rule
	processing will continue at rule <code class="literal">1000</code>.  The
	seven <code class="literal">tcp</code> rules have been replaced by rule
	<code class="literal">125</code> as the
	<code class="literal">$good_tcpo</code> variable contains the
	seven allowed outbound ports.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Remember that <span class="application">IPFW</span>'s
	  performance is largely determined by the number of rules
	  present in the ruleset.</p></div><pre class="programlisting"># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre><p>The inbound rules remain the same, except for the very
	last rule which removes the <code class="literal">via $pif</code> in
	order to catch both inbound and outbound rules.  The
	<acronym class="acronym">NAT</acronym> rule must follow this last outbound
	rule, must have a higher number than that last rule, and the
	rule number must be referenced by the
	<code class="literal">skipto</code> action.  In this ruleset, rule
	number <code class="literal">1000</code> handles passing all packets to
	our configured instance for <acronym class="acronym">NAT</acronym> processing.
	The next rule allows any packet which has undergone
	<acronym class="acronym">NAT</acronym> processing to pass.</p><pre class="programlisting">$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre><p>In this example, rules <code class="literal">100</code>,
	<code class="literal">101</code>, <code class="literal">125</code>,
	<code class="literal">1000</code>, and <code class="literal">1001</code> control
	the address translation of the outbound and inbound packets so
	that the entries in the dynamic state table always register
	the private <acronym class="acronym">LAN</acronym> <acronym class="acronym">IP</acronym>
	address.</p><p>Consider an internal web browser which initializes a new
	outbound <acronym class="acronym">HTTP</acronym> session over port 80.  When
	the first outbound packet enters the firewall, it does not
	match rule <code class="literal">100</code> because it is headed out
	rather than in.  It passes rule <code class="literal">101</code> because
	this is the first packet and it has not been posted to the
	dynamic state table yet.  The packet finally matches rule
	<code class="literal">125</code> as it is outbound on an allowed port
	and has a source <acronym class="acronym">IP</acronym> address from the
	internal <acronym class="acronym">LAN</acronym>.  On matching this rule, two
	actions take place.  First, the <code class="literal">keep-state</code>
	action adds an entry to the dynamic state table and the
	specified action, <code class="literal">skipto rule 1000</code>, is
	executed.  Next, the packet undergoes <acronym class="acronym">NAT</acronym>
	and is sent out to the Internet.  This packet makes its way to
	the destination web server, where a response packet is
	generated and sent back.  This new packet enters the top of
	the ruleset.  It matches rule <code class="literal">100</code> and has
	its destination <acronym class="acronym">IP</acronym> address mapped back to
	the original internal address.  It then is processed by the
	<code class="literal">check-state</code> rule, is found in the table as
	an existing session, and is released to the
	<acronym class="acronym">LAN</acronym>.</p><p>On the inbound side, the ruleset has to deny bad packets
	and allow only authorized services.  A packet which matches an
	inbound rule is posted to the dynamic state table and the
	packet is released to the <acronym class="acronym">LAN</acronym>.  The packet
	generated as a response is recognized by the
	<code class="literal">check-state</code> rule as belonging to an
	existing session.  It is then sent to rule
	<code class="literal">1000</code> to undergo
	<acronym class="acronym">NAT</acronym> before being released to the outbound
	interface.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Transitioning from userland <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> to in-kernel
	  <acronym class="acronym">NAT</acronym> might seem seamless at first but
	  there is small catch.  When using the GENERIC kernel,
	  <span class="application">IPFW</span> will load the
	  <code class="filename">libalias.ko</code> kernel module, when
	  <code class="literal">firewall_nat_enable</code> is enabled in
	  <code class="filename">rc.conf</code>.  The
	  <code class="filename">libalias.ko</code> kernel module only provides
	  basic <acronym class="acronym">NAT</acronym> functionality, whereas the
	  userland implementation <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> has all
	  <acronym class="acronym">NAT</acronym> functionality available in its
	  userland library without any extra configuration.  All
	  functionality refers to the following kernel modules that
	  can additionally be loaded when needed besides the standard
	  <code class="filename">libalias.ko</code> kernel module:
	  <code class="filename">alias_cuseeme.ko</code>,
	  <code class="filename">alias_ftp.ko</code>,
	  <code class="filename">alias_bbt.ko</code>,
	  <code class="filename">skinny.ko</code>, <code class="filename">irc.ko</code>,
	  <code class="filename">alias_pptp.ko</code> and
	  <code class="filename">alias_smedia.ko</code> using the
	  <code class="literal">kld_list</code> directive in
	  <code class="filename">rc.conf</code>.  If a custom kernel is used,
	  the full functionality of the userland library can be
	  compiled in, in the kernel, using the <code class="option">options
	  LIBALIAS</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72171000"></a>30.4.4.1. Port Redirection</h4></div></div></div><p>The drawback with <acronym class="acronym">NAT</acronym> in general is
	  that the <acronym class="acronym">LAN</acronym> clients are not accessible
	  from the Internet.  Clients on the <acronym class="acronym">LAN</acronym>
	  can make outgoing connections to the world but cannot
	  receive incoming ones.  This presents a problem if trying to
	  run Internet services on one of the <acronym class="acronym">LAN</acronym>
	  client machines.  A simple way around this is to redirect
	  selected Internet ports on the <acronym class="acronym">NAT</acronym>
	  providing machine to a <acronym class="acronym">LAN</acronym> client.</p><p>For example, an <acronym class="acronym">IRC</acronym> server runs on
	  client <code class="systemitem">A</code> and a web server runs on
	  client <code class="systemitem">B</code>.  For this to work
	  properly, connections received on ports 6667
	  (<acronym class="acronym">IRC</acronym>) and 80 (<acronym class="acronym">HTTP</acronym>)
	  must be redirected to the respective machines.</p><p>With in-kernel <acronym class="acronym">NAT</acronym> all configuration
	  is done in the <acronym class="acronym">NAT</acronym> instance
	  configuration.  For a full list of options that an in-kernel
	  <acronym class="acronym">NAT</acronym> instance can use, consult
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a>.  The <span class="application">IPFW</span> syntax
	  follows the syntax of <span class="application">natd</span>.  The
	  syntax for <code class="option">redirect_port</code> is as
	  follows:</p><pre class="programlisting">redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre><p>To configure the above example setup, the arguments
	should be:</p><pre class="programlisting">redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre><p>After adding these arguments to the configuration of
	  <acronym class="acronym">NAT</acronym> instance 1 in the above ruleset, the
	  <acronym class="acronym">TCP</acronym> ports will be port forwarded to the
	  <acronym class="acronym">LAN</acronym> client machines running the
	  <acronym class="acronym">IRC</acronym> and <acronym class="acronym">HTTP</acronym>
	  services.</p><pre class="programlisting">ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre><p>Port ranges over individual ports can be indicated with
	  <code class="option">redirect_port</code>.  For example,
	  <em class="replaceable"><code>tcp 192.168.0.2:2000-3000
	  2000-3000</code></em> would redirect all connections
	  received on ports 2000 to 3000 to ports 2000 to 3000 on
	  client <code class="systemitem">A</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp71812984"></a>30.4.4.2. Address Redirection</h4></div></div></div><p>Address redirection is useful if more than one
	  <acronym class="acronym">IP</acronym> address is available.  Each
	  <acronym class="acronym">LAN</acronym> client can be assigned its own
	  external <acronym class="acronym">IP</acronym> address by <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a>,
	  which will then rewrite outgoing packets from the
	  <acronym class="acronym">LAN</acronym> clients with the proper external
	  <acronym class="acronym">IP</acronym> address and redirects all traffic
	  incoming on that particular <acronym class="acronym">IP</acronym> address
	  back to the specific <acronym class="acronym">LAN</acronym> client.  This is
	  also known as static <acronym class="acronym">NAT</acronym>.  For example,
	  if <acronym class="acronym">IP</acronym> addresses <code class="systemitem">128.1.1.1</code>, <code class="systemitem">128.1.1.2</code>, and <code class="systemitem">128.1.1.3</code> are available,
	  <code class="systemitem">128.1.1.1</code> can be
	  used as the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> machine's external
	  <acronym class="acronym">IP</acronym> address, while <code class="systemitem">128.1.1.2</code> and <code class="systemitem">128.1.1.3</code> are forwarded
	  back to <acronym class="acronym">LAN</acronym> clients
	  <code class="systemitem">A</code> and
	  <code class="systemitem">B</code>.</p><p>The <code class="option">redirect_address</code> syntax is as
	  below, where <code class="literal">localIP</code> is the internal
	  <acronym class="acronym">IP</acronym> address of the <acronym class="acronym">LAN</acronym>
	  client, and <code class="literal">publicIP</code> the external
	  <acronym class="acronym">IP</acronym> address corresponding to the
	  <acronym class="acronym">LAN</acronym> client.</p><pre class="programlisting">redirect_address localIP publicIP</pre><p>In the example, the arguments would read:</p><pre class="programlisting">redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre><p>Like <code class="option">redirect_port</code>, these arguments
	  are placed in a <acronym class="acronym">NAT</acronym> instance
	  configuration.  With address redirection, there is no
	  need for port redirection, as all data received on a
	  particular <acronym class="acronym">IP</acronym> address is
	  redirected.</p><p>The external <acronym class="acronym">IP</acronym> addresses on the
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> machine must be active and aliased to the
	  external interface.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> for
	  details.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72245496"></a>30.4.4.3. Userspace <acronym class="acronym">NAT</acronym></h4></div></div></div><p>Let us start with a statement: the userspace
	  <acronym class="acronym">NAT</acronym> implementation: <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a>, has
	  more overhead than in-kernel <acronym class="acronym">NAT</acronym>.  For
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> to translate packets, the packets have to be
	  copied from the kernel to userspace and back which brings in
	  extra overhead that is not present with in-kernel
	  <acronym class="acronym">NAT</acronym>.</p><p>To enable the userpace <acronym class="acronym">NAT</acronym> daemon
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> at boot time, the following is a minimum
	  configuration in <code class="filename">/etc/rc.conf</code>.  Where
	  <code class="option">natd_interface</code> is set to the name of the
	  <acronym class="acronym">NIC</acronym> attached to the Internet.  The
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> script of <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> will automatically check
	  if a dynamic <acronym class="acronym">IP</acronym> address is used and
	  configure itself to handle that.</p><pre class="programlisting">gateway_enable="YES"
natd_enable="YES"
natd_interface="rl0"</pre><p>In general, the above ruleset as explained for in-kernel
	  <acronym class="acronym">NAT</acronym> can also be used together with
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a>.  The exceptions are the configuration of the
	  in-kernel <acronym class="acronym">NAT</acronym> instance <code class="literal">(ipfw -q
	  nat 1 config ...)</code> which is not needed together
	  with reassemble rule 99 because its functionality is
	  included in the <code class="option">divert</code> action.  Rule number
	  100 and 1000 will have to change sligthly as shown
	  below.</p><pre class="programlisting">$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre><p>To configure port or address redirection, a similar
	  syntax as with in-kernel <acronym class="acronym">NAT</acronym> is used.
	  Although, now, instead of specifying the configuration in
	  our ruleset script like with in-kernel
	  <acronym class="acronym">NAT</acronym>, configuration of <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> is
	  best done in a configuration file.  To do this, an extra
	  flag must be passed via <code class="filename">/etc/rc.conf</code>
	  which specifies the path of the configuration file.</p><pre class="programlisting">natd_flags="-f /etc/natd.conf"</pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">The specified file must contain a list of
	    configuration options, one per line.  For more information
	    about the configuration file and possible variables,
	    consult <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a>.  Below are two example
	    entries, one per line:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipfw-cmd"></a>30.4.5. The <span class="application">IPFW</span> Command</h3></div></div></div><a id="idp72263544" class="indexterm"></a><p><code class="command">ipfw</code> can be used to make manual,
	single rule additions or deletions to the active firewall
	while it is running.  The problem with using this method is
	that all the changes are lost when the system reboots.  It is
	recommended to instead write all the rules in a file and to
	use that file to load the rules at boot time and to replace
	the currently running firewall rules whenever that file
	changes.</p><p><code class="command">ipfw</code> is a useful way to display the
	running firewall rules to the console screen.  The
	<span class="application">IPFW</span> accounting facility
	dynamically creates a counter for each rule that counts each
	packet that matches the rule.  During the process of testing a
	rule, listing the rule with its counter is one way to
	determine if the rule is functioning as expected.</p><p>To list all the running rules in sequence:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw list</code></strong></pre><p>To list all the running rules with a time stamp of when
	the last time the rule was matched:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw -t list</code></strong></pre><p>The next example lists accounting information and the
	packet count for matched rules along with the rules
	themselves.  The first column is the rule number, followed by
	the number of matched packets and bytes, followed by the rule
	itself.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw -a list</code></strong></pre><p>To list dynamic rules in addition to static rules:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw -d list</code></strong></pre><p>To also show the expired dynamic rules:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw -d -e list</code></strong></pre><p>To zero the counters:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw zero</code></strong></pre><p>To zero the counters for just the rule with number
	<em class="replaceable"><code>NUM</code></em>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw zero <em class="replaceable"><code>NUM</code></em></code></strong></pre><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72287736"></a>30.4.5.1. Logging Firewall Messages</h4></div></div></div><a id="idp72288376" class="indexterm"></a><p>Even with the logging facility enabled,
	  <span class="application">IPFW</span> will not generate any rule
	  logging on its own.  The firewall administrator decides
	  which rules in the ruleset will be logged, and adds the
	  <code class="literal">log</code> keyword to those rules.  Normally
	  only deny rules are logged.  It is customary to duplicate
	  the <span class="quote">&#8220;<span class="quote">ipfw default deny everything</span>&#8221;</span> rule with
	  the <code class="literal">log</code> keyword included as the last rule
	  in the ruleset.  This way, it is possible to see all the
	  packets that did not match any of the rules in the
	  ruleset.</p><p>Logging is a two edged sword.  If one is not careful,
	  an over abundance of log data or a DoS attack can fill the
	  disk with log files.  Log messages are not only written to
	  <span class="application">syslogd</span>, but also are displayed
	  on the root console screen and soon become annoying.</p><p>The <code class="literal">IPFIREWALL_VERBOSE_LIMIT=5</code>
	  kernel option limits the number of consecutive messages
	  sent to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">syslogd</span>(8)</span></a>, concerning the packet matching of a
	  given rule.  When this option is enabled in the kernel, the
	  number of consecutive messages concerning a particular rule
	  is capped at the number specified.  There is nothing to be
	  gained from 200 identical log messages.  With this option
	  set to five,
	  five consecutive messages concerning a particular rule
	  would be logged to <span class="application">syslogd</span> and
	  the remainder identical consecutive messages would be
	  counted and posted to <span class="application">syslogd</span>
	  with a phrase like the following:</p><pre class="programlisting">last message repeated 45 times</pre><p>All logged packets messages are written by default to
	  <code class="filename">/var/log/security</code>, which is
	  defined in <code class="filename">/etc/syslog.conf</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipfw-rules-script"></a>30.4.5.2. Building a Rule Script</h4></div></div></div><p>Most experienced <span class="application">IPFW</span> users
	  create a file containing the rules and code them in a manner
	  compatible with running them as a script.  The major benefit
	  of doing this is the firewall rules can be refreshed in mass
	  without the need of rebooting the system to activate them.
	  This method is convenient in testing new rules as the
	  procedure can be executed as many times as needed.  Being a
	  script, symbolic substitution can be used for frequently
	  used values to be substituted into multiple rules.</p><p>This example script is compatible with the syntax used
	  by the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>,  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">csh</span>(1)</span></a>, and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">tcsh</span>(1)</span></a> shells.
	  Symbolic substitution fields are prefixed with a dollar sign
	  ($).  Symbolic fields do not have the $
	  prefix.  The value to populate the symbolic field must be
	  enclosed in double quotes ("").</p><p>Start the rules file like this:</p><pre class="programlisting">############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre><p>The rules are not important as the focus of this example
	  is how the symbolic substitution fields are
	  populated.</p><p>If the above example was in
	  <code class="filename">/etc/ipfw.rules</code>, the rules could be
	  reloaded by the following command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sh /etc/ipfw.rules</code></strong></pre><p><code class="filename">/etc/ipfw.rules</code> can be located
	  anywhere and the file can have any name.</p><p>The same thing could be accomplished by running these
	  commands by hand:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw -q -f flush</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add check-state</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add deny all from any to any frag</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add deny tcp from any to any established</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</code></strong></pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipfw-kernelconfig"></a>30.4.6. <span class="application">IPFW</span> Kernel Options</h3></div></div></div><a id="idp72331768" class="indexterm"></a><a id="idp72332920" class="indexterm"></a><a id="idp72334072" class="indexterm"></a><a id="idp72335224" class="indexterm"></a><p>In order to statically compile
	<span class="application">IPFW</span> support into a custom kernel,
	refer to the instructions in <a class="xref" href="kernelconfig.html" title="Chapter 8. Configuring the FreeBSD Kernel">Chapter 8, <em>Configuring the FreeBSD Kernel</em></a>.
	The following options are available for the
	custom kernel configuration file:</p><pre class="programlisting">options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml"><span class="application">IPFW</span> can be loaded as
	  a kernel module: options above are built by default
	  as modules or can be set at runtime using tunables.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="firewalls-pf.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="firewalls.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="firewalls-ipf.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">30.3. PF </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 30.5. IPFILTER (IPF)</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>