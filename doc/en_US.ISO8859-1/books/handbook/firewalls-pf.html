<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>30.3. PF</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Handbook" /><link rel="up" href="firewalls.html" title="Chapter 30. Firewalls" /><link rel="prev" href="firewalls-concepts.html" title="30.2. Firewall Concepts" /><link rel="next" href="firewalls-ipfw.html" title="30.4. IPFW" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">30.3. PF</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="firewalls-concepts.html">Prev</a> </td><th width="60%" align="center">Chapter 30. Firewalls</th><td width="20%" align="right"> <a accesskey="n" href="firewalls-ipfw.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="firewalls-pf"></a>30.3. PF</h2></div><div><span class="authorgroup">Revised and updated by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">John</span> <span class="surname">Ferrell</span></span>. </span></div></div></div><a id="idp71386360" class="indexterm"></a><p>Since FreeBSD 5.3, a ported version of OpenBSD's
      <span class="application">PF</span> firewall has been included as an
      integrated part of the base system.
      <span class="application">PF</span> is a complete, full-featured
      firewall that has optional support for
      <span class="application">ALTQ</span> (Alternate Queuing), which
      provides Quality of Service (<acronym class="acronym">QoS</acronym>).</p><p>The OpenBSD Project maintains the definitive reference for
      <span class="application">PF</span> in the <a class="link" href="http://www.openbsd.org/faq/pf/" target="_top">PF FAQ</a>.
      Peter Hansteen maintains a thorough
      <span class="application">PF</span> tutorial at <a class="link" href="http://home.nuug.no/~peter/pf/" target="_top">http://home.nuug.no/~peter/pf/</a>.</p><div xmlns="" class="warning"><h3 class="admontitle">Warning: </h3><p xmlns="http://www.w3.org/1999/xhtml">When reading the <a class="link" href="http://www.openbsd.org/faq/pf/" target="_top">PF FAQ</a>,
	keep in mind that FreeBSD's version of
	<span class="application">PF</span> has diverged substantially from
	the upstream OpenBSD version over the years.  Not all features
	work the same way on FreeBSD as they do in OpenBSD and vice
	versa.</p></div><p>The <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf" target="_top">FreeBSD packet filter mailing list</a> is a good place to ask questions about
      configuring and running the <span class="application">PF</span>
      firewall.  Check the mailing list archives before asking a
      question as it may have already been answered.</p><p>This section of the Handbook focuses on
      <span class="application">PF</span> as it pertains to FreeBSD.  It
      demonstrates how to enable <span class="application">PF</span> and
      <span class="application">ALTQ</span>.  It also provides several
      examples for creating rulesets on a FreeBSD system.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp71412728"></a>30.3.1. Enabling <span class="application">PF</span></h3></div></div></div><p>To use <span class="application">PF</span>, its kernel
	module must be first loaded.  This section describes the
	entries that can be added to <code class="filename">/etc/rc.conf</code>
	to enable <span class="application">PF</span>.</p><p>Start by adding <code class="literal">pf_enable=yes</code> to
	<code class="filename">/etc/rc.conf</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc pf_enable=yes</code></strong></pre><p>Additional options, described in <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pfctl</span>(8)</span></a>, can be
	passed to <span class="application">PF</span> when it is started.
	Add or change this entry in <code class="filename">/etc/rc.conf</code>
	and specify any required flags between the two quotes
	(<code class="literal">""</code>):</p><pre class="programlisting">pf_flags=""                     # additional flags for pfctl startup</pre><p><span class="application">PF</span> will not start if it cannot
	find its ruleset configuration file.  By default, FreeBSD does
	not ship with a ruleset and there is no
	<code class="filename">/etc/pf.conf</code>.  Example rulesets can be
	found in <code class="filename">/usr/share/examples/pf/</code>.  If a
	custom ruleset has been saved somewhere else, add a line to
	<code class="filename">/etc/rc.conf</code> which specifies the full
	path to the file:</p><pre class="programlisting">pf_rules="<em class="replaceable"><code>/path/to/pf.conf</code></em>"</pre><p>Logging support for <span class="application">PF</span> is
	provided by <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pflog</span>(4)</span></a>.  To enable logging support, add
	<code class="literal">pflog_enable=yes</code> to
	<code class="filename">/etc/rc.conf</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc pflog_enable=yes</code></strong></pre><p>The following lines can also be added to change the
	default location of the log file or to specify any additional
	flags to pass to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pflog</span>(4)</span></a> when it is started:</p><pre class="programlisting">pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</pre><p>Finally, if there is a <acronym class="acronym">LAN</acronym> behind the
	firewall and packets need to be forwarded for the computers on
	the <acronym class="acronym">LAN</acronym>, or <acronym class="acronym">NAT</acronym> is
	required, enable the following option:</p><pre class="programlisting">gateway_enable="YES"            # Enable as LAN gateway</pre><p>After saving the needed edits,
	<span class="application">PF</span> can be started with logging
	support by typing:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service pf start</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>service pflog start</code></strong></pre><p>By default, <span class="application">PF</span> reads its
	configuration rules from <code class="filename">/etc/pf.conf</code> and
	modifies, drops, or passes packets according to the rules or
	definitions specified in this file.  The FreeBSD installation
	includes several sample files located in
	<code class="filename">/usr/share/examples/pf/</code>.  Refer to the
	<a class="link" href="http://www.openbsd.org/faq/pf/" target="_top">PF
	  FAQ</a> for complete coverage
	of <span class="application">PF</span> rulesets.</p><p>To control <span class="application">PF</span>, use
	<code class="command">pfctl</code>.  <a class="xref" href="firewalls-pf.html#pfctl" title="Table 30.1. Useful pfctl Options">Table 30.1, &#8220;Useful <code class="command">pfctl</code> Options&#8221;</a> summarizes
	some useful options to this command.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">pfctl</span>(8)</span></a>
	for a description of all available options:</p><div class="table"><a id="pfctl"></a><div class="table-title">Table 30.1. Useful <code class="command">pfctl</code> Options</div><div class="table-contents"><table class="table" summary="Useful pfctl Options" width="100%" border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Command</th><th>Purpose</th></tr></thead><tbody><tr><td><code class="command">pfctl
		  -e</code></td><td>Enable <span class="application">PF</span>.</td></tr><tr><td><code class="command">pfctl
		  -d</code></td><td>Disable <span class="application">PF</span>.</td></tr><tr><td><code class="command">pfctl -F all
		  -f /etc/pf.conf</code></td><td>Flush all <acronym class="acronym">NAT</acronym>, filter, state,
		and table rules and reload
		<code class="filename">/etc/pf.conf</code>.</td></tr><tr><td><code class="command">pfctl -s [ rules | nat |
		  states ]</code></td><td>Report on the filter rules,
		<acronym class="acronym">NAT</acronym> rules, or state
		table.</td></tr><tr><td><code class="command">pfctl -vnf
		  /etc/pf.conf</code></td><td>Check <code class="filename">/etc/pf.conf</code> for
		errors, but do not load ruleset.</td></tr></tbody></table></div></div><br class="table-break" /><div xmlns="" class="tip"><h3 class="admontitle">Tip: </h3><p xmlns="http://www.w3.org/1999/xhtml"><a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/security/sudo/pkg-descr">security/sudo</a> is useful for running
	  commands like <code class="command">pfctl</code> that require elevated
	  privileges.  It can be installed from the Ports
	  Collection.</p></div><p>To keep an eye on the traffic that passes through the
	<span class="application">PF</span> firewall, consider installing
	the <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/sysutils/pftop/pkg-descr">sysutils/pftop</a> package or port.  Once
	installed, <span class="application">pftop</span> can be run to
	view a running snapshot of traffic in a format which is
	similar to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pf-tutorial"></a>30.3.2. <span class="application">PF</span> Rulesets</h3></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Peter</span> <span class="othername">N. M.</span> <span class="surname">Hansteen</span></span>. </span></div></div></div><p>This section demonstrates how to create a customized
	ruleset.  It starts with the simplest of rulesets and builds
	upon its concepts using several examples to demonstrate
	real-world usage of <span class="application">PF</span>'s many
	features.</p><p>The simplest possible ruleset is for a single machine
	that does not run any services and which needs access to one
	network, which may be the Internet.  To create this minimal
	ruleset, edit <code class="filename">/etc/pf.conf</code> so it looks
	like this:</p><pre class="programlisting">block in all
pass out all keep state</pre><p>The first rule denies all incoming traffic by default.
	The second rule allows connections created by this system to
	pass out, while retaining state information on those
	connections.  This state information allows return traffic for
	those connections to pass back and should only be used on
	machines that can be trusted.  The ruleset can be loaded
	with:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -e ; pfctl -f /etc/pf.conf</code></strong></pre><p>In addition to keeping state,
	<span class="application">PF</span> provides
	<em class="firstterm">lists</em> and
	<em class="firstterm">macros</em> which can be defined for use
	when creating rules.  Macros can include lists and need to be
	defined before use.  As an example, insert these lines at the
	very top of the ruleset:</p><pre class="programlisting">tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</pre><p><span class="application">PF</span> understands port names as
	well as port numbers, as long as the names are listed in
	<code class="filename">/etc/services</code>.  This example creates two
	macros.  The first is a list of seven
	<acronym class="acronym">TCP</acronym> port names and the second is one
	<acronym class="acronym">UDP</acronym> port name.  Once defined, macros can be
	used in rules.  In this example, all traffic is blocked except
	for the  connections initiated by this system for the seven
	specified <acronym class="acronym">TCP</acronym> services and the one
	specified <acronym class="acronym">UDP</acronym> service:</p><pre class="programlisting">tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre><p>Even though <acronym class="acronym">UDP</acronym> is considered to be a
	stateless protocol, <span class="application">PF</span> is able to
	track some state information.  For example, when a
	<acronym class="acronym">UDP</acronym> request is passed which asks a name
	server about a domain name, <span class="application">PF</span> will
	watch for the response to pass it back.</p><p>Whenever an edit is made to a ruleset, the new rules must
	be loaded so they can be used:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -f /etc/pf.conf</code></strong></pre><p>If there are no syntax errors, <code class="command">pfctl</code>
	will not output any messages during the rule load.  Rules can
	also be tested before attempting to load them:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -nf /etc/pf.conf</code></strong></pre><p>Including <code class="option">-n</code> causes the rules to be
	interpreted only, but not loaded.  This provides an
	opportunity to correct any errors.  At all times, the last
	valid ruleset loaded will be enforced until either
	<span class="application">PF</span> is disabled or a new ruleset is
	loaded.</p><div xmlns="" class="tip"><h3 class="admontitle">Tip: </h3><p xmlns="http://www.w3.org/1999/xhtml">Adding <code class="option">-v</code> to a <code class="command">pfctl</code>
	  ruleset verify or load will display the fully parsed rules
	  exactly the way they will be loaded.  This is extremely
	  useful when debugging rules.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-gateway"></a>30.3.2.1. A Simple Gateway with NAT</h4></div></div></div><p>This section demonstrates how to configure a FreeBSD system
	  running <span class="application">PF</span> to act as a gateway
	  for at least one other machine.  The gateway needs at least
	  two network interfaces, each connected to a separate
	  network.  In this example, <code class="filename">xl0</code> is
	  connected to the Internet and <code class="filename">xl1</code> is
	  connected to the internal network.</p><p>First, enable the gateway to let the machine
	  forward the network traffic it receives on one interface to
	  another interface.  This <span class="application">sysctl</span>
	  setting will forward <acronym class="acronym">IPv4</acronym> packets:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl net.inet.ip.forwarding=1</code></strong></pre><p>To forward <acronym class="acronym">IPv6</acronym> traffic, use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl net.inet6.ip6.forwarding=1</code></strong></pre><p>To enable these settings at system boot, use
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sysrc</span>(8)</span></a> to add them to
	  <code class="filename">/etc/rc.conf</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysrc gateway_enable=yes</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sysrc ipv6_gateway_enable=yes</code></strong></pre><p>Verify with <code class="command">ifconfig</code> that both of the
	  interfaces are up and running.</p><p>Next, create the <span class="application">PF</span> rules to
	  allow the gateway to pass traffic.  While the following rule
	  allows stateful traffic from hosts of the internal network
	  to pass to the gateway, the <code class="literal">to</code> keyword
	  does not guarantee passage all the way from source to
	  destination:</p><pre class="programlisting">pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre><p>That rule only lets the traffic pass in to the gateway
	  on the internal interface.  To let the packets go further, a
	  matching rule is needed:</p><pre class="programlisting">pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre><p>While these two rules will work, rules this specific are
	  rarely needed.  For a busy network admin, a readable ruleset
	  is a safer ruleset.  The remainder of this section
	  demonstrates how to keep the rules as simple as possible for
	  readability.  For example, those two rules could be
	  replaced with one rule:</p><pre class="programlisting">pass from xl1:network to any port $ports keep state</pre><p>The <code class="literal">interface:network</code> notation can be
	  replaced with a macro to make the ruleset even more
	  readable.  For example, a <code class="literal">$localnet</code> macro
	  could be defined as the network directly attached to the
	  internal interface (<code class="literal">$xl1:network</code>).
	  Alternatively, the definition of
	  <code class="literal">$localnet</code> could be changed to an
	  <span class="emphasis"><em>IP address/netmask</em></span> notation to denote
	  a network, such as <code class="literal">192.168.100.1/24</code> for a
	  subnet of private addresses.</p><p>If required, <code class="literal">$localnet</code> could even be
	  defined as a list of networks.  Whatever the specific needs,
	  a sensible <code class="literal">$localnet</code> definition could be
	  used in a typical pass rule as follows:</p><pre class="programlisting">pass from $localnet to any port $ports keep state</pre><p>The following sample ruleset allows all traffic
	  initiated by machines on the internal network.  It first
	  defines two macros to represent the external and internal
	  3COM interfaces of the gateway.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">For dialup users, the external interface will use
	    <code class="filename">tun0</code>.  For an
	    <acronym class="acronym">ADSL</acronym> connection, specifically those
	    using <acronym class="acronym">PPP</acronym> over Ethernet
	    (<acronym class="acronym">PPPoE</acronym>), the correct external
	    interface is <code class="filename">tun0</code>, not the physical
	    Ethernet interface.</p></div><pre class="programlisting">ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre><p>This ruleset introduces the <code class="literal">nat</code> rule
	  which is used to handle the network address translation from
	  the non-routable addresses inside the internal network to
	  the <acronym class="acronym">IP</acronym> address assigned to the external
	  interface.  The parentheses surrounding the last part of the
	  nat rule <code class="literal">($ext_if)</code> is included when the
	  <acronym class="acronym">IP</acronym> address of the external interface is
	  dynamically assigned.  It ensures that network traffic runs
	  without serious interruptions even if the external
	  <acronym class="acronym">IP</acronym> address changes.</p><p>Note that this ruleset probably allows more traffic to
	  pass out of the network than is needed.  One reasonable
	  setup could create this macro:</p><pre class="programlisting">client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"</pre><p>to use in the main pass rule:</p><pre class="programlisting">pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre><p>A few other pass rules may be needed.  This one enables
	  <acronym class="acronym">SSH</acronym> on the external interface:</p><pre class="programlisting">pass in inet proto tcp to $ext_if port ssh</pre><p>This macro definition and rule allows
	  <acronym class="acronym">DNS</acronym> and <acronym class="acronym">NTP</acronym> for
	  internal clients:</p><pre class="programlisting">udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre><p>Note the <code class="literal">quick</code> keyword in this rule.
	  Since the ruleset consists of several rules, it is important
	  to understand the relationships between the rules in a
	  ruleset.  Rules are evaluated from top to bottom, in the
	  sequence they are written.  For each packet or connection
	  evaluated by <span class="application">PF</span>,
	  <span class="emphasis"><em>the last matching rule</em></span> in the ruleset
	  is the one which is applied.  However, when a packet matches
	  a rule which contains the <code class="literal">quick</code> keyword,
	  the rule processing stops and the packet is treated
	  according to that rule.  This is very useful when an
	  exception to the general rules is needed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-ftp"></a>30.3.2.2. Creating an <acronym class="acronym">FTP</acronym> Proxy</h4></div></div></div><p>Configuring working <acronym class="acronym">FTP</acronym> rules can be
	  problematic due to the nature of the <acronym class="acronym">FTP</acronym>
	  protocol.  <acronym class="acronym">FTP</acronym> pre-dates firewalls by
	  several decades and is insecure in its design.  The most
	  common points against using <acronym class="acronym">FTP</acronym>
	  include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Passwords are transferred in the clear.</p></li><li class="listitem"><p>The protocol demands the use of at least two
	      <acronym class="acronym">TCP</acronym> connections (control and data) on
	      separate ports.</p></li><li class="listitem"><p>When a session is established, data is communicated
	      using randomly selected ports.</p></li></ul></div><p>All of these points present security challenges, even
	  before considering any potential security weaknesses in
	  client or server software.  More secure alternatives for
	  file transfer exist, such as <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sftp</span>(1)</span></a> or <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">scp</span>(1)</span></a>,
	  which both feature authentication and data transfer over
	  encrypted connections..</p><p>For those situations when <acronym class="acronym">FTP</acronym> is
	  required, <span class="application">PF</span> provides
	  redirection of <acronym class="acronym">FTP</acronym> traffic to a small
	  proxy program called <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ftp-proxy</span>(8)</span></a>, which is included in
	  the base system of FreeBSD.  The role of the proxy is to
	  dynamically insert and delete rules in the ruleset, using a
	  set of anchors, to correctly handle
	  <acronym class="acronym">FTP</acronym> traffic.</p><p>To enable the <acronym class="acronym">FTP</acronym> proxy, add this
	  line to <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">ftpproxy_enable="YES"</pre><p>Then start the proxy by running <code class="command">service
	    ftp-proxy start</code>.</p><p>For a basic configuration, three elements need to be
	  added to <code class="filename">/etc/pf.conf</code>.  First, the
	  anchors which the proxy will use to insert the rules it
	  generates for the <acronym class="acronym">FTP</acronym> sessions:</p><pre class="programlisting">nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</pre><p>Second, a pass rule is needed to allow
	  <acronym class="acronym">FTP</acronym> traffic in to the proxy.</p><p>Third, redirection and <acronym class="acronym">NAT</acronym> rules need
	  to be defined before the filtering rules.  Insert this
	  <code class="literal">rdr</code> rule immediately after the
	  <code class="literal">nat</code> rule:</p><pre class="programlisting">rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre><p>Finally, allow the redirected traffic to pass:</p><pre class="programlisting">pass out proto tcp from $proxy to any port ftp</pre><p>where <code class="literal">$proxy</code> expands to the address
	  the proxy daemon is bound to.</p><p>Save <code class="filename">/etc/pf.conf</code>, load the new
	  rules, and verify from a client that <acronym class="acronym">FTP</acronym>
	  connections are working:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -f /etc/pf.conf</code></strong></pre><p>This example covers a basic setup where the clients in
	  the local network need to contact <acronym class="acronym">FTP</acronym>
	  servers elsewhere.  This basic configuration should
	  work well with most combinations of <acronym class="acronym">FTP</acronym>
	  clients and servers.  As shown in <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ftp-proxy</span>(8)</span></a>, the
	  proxy's behavior can be changed in various ways by adding
	  options to the <code class="literal">ftpproxy_flags=</code> line.
	  Some clients or servers may have specific quirks that must
	  be compensated for in the configuration, or there may be a
	  need to integrate the proxy in specific ways such as
	  assigning <acronym class="acronym">FTP</acronym> traffic to a specific
	  queue.</p><p>For ways to run an <acronym class="acronym">FTP</acronym> server
	  protected by <span class="application">PF</span> and
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ftp-proxy</span>(8)</span></a>, configure a separate
	  <code class="command">ftp-proxy</code> in reverse mode, using
	  <code class="option">-R</code>, on a separate port with its own
	  redirecting pass rule.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-icmp"></a>30.3.2.3. Managing <acronym class="acronym">ICMP</acronym></h4></div></div></div><p>Many of the tools used for debugging or troubleshooting
	  a <acronym class="acronym">TCP/IP</acronym> network rely on the Internet
	  Control Message Protocol (<acronym class="acronym">ICMP</acronym>), which
	  was designed specifically with debugging in mind.</p><p>The <acronym class="acronym">ICMP</acronym> protocol sends and receives
	  <span class="emphasis"><em>control messages</em></span> between hosts and
	  gateways, mainly to provide feedback to a sender about any
	  unusual or difficult conditions enroute to the target host.
	  Routers use <acronym class="acronym">ICMP</acronym> to negotiate packet
	  sizes and other transmission parameters in a process often
	  referred to as <span class="emphasis"><em>path <acronym class="acronym">MTU</acronym>
	    discovery</em></span>.</p><p>From a firewall perspective, some
	  <acronym class="acronym">ICMP</acronym> control messages are vulnerable to
	  known attack vectors.  Also, letting all diagnostic traffic
	  pass unconditionally makes debugging easier, but it also
	  makes it easier for others to extract information about the
	  network.  For these reasons, the following rule may not be
	  optimal:</p><pre class="programlisting">pass inet proto icmp from any to any</pre><p>One solution is to let all <acronym class="acronym">ICMP</acronym>
	  traffic from the local network through while stopping all
	  probes from outside the network:</p><pre class="programlisting">pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre><p>Additional options are available which demonstrate some
	  of <span class="application">PF</span>'s flexibility.  For
	  example, rather than allowing all <acronym class="acronym">ICMP</acronym>
	  messages, one can specify the messages used by <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ping</span>(8)</span></a>
	  and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a>.  Start by defining a macro for that
	  type of message:</p><pre class="programlisting">icmp_types = "echoreq"</pre><p>and a rule which uses the macro:</p><pre class="programlisting">pass inet proto icmp all icmp-type $icmp_types keep state</pre><p>If other types of <acronym class="acronym">ICMP</acronym> packets are
	  needed, expand <code class="literal">icmp_types</code> to a list of
	  those packet types.  Type <code class="command">more
	    /usr/src/sbin/pfctl/pfctl_parser.c</code> to see
	  the list of <acronym class="acronym">ICMP</acronym> message types supported
	  by <span class="application">PF</span>.  Refer to <a class="link" href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml" target="_top">http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a>
	  for an explanation of each message type.</p><p>Since Unix <code class="command">traceroute</code> uses
	  <acronym class="acronym">UDP</acronym> by default, another rule is needed to
	  allow Unix <code class="command">traceroute</code>:</p><pre class="programlisting"># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre><p>Since <code class="command">TRACERT.EXE</code> on Microsoft
	  Windows systems uses <acronym class="acronym">ICMP</acronym> echo request
	  messages, only the first rule is needed to allow network
	  traces from those systems.  Unix
	  <code class="command">traceroute</code> can be instructed to use other
	  protocols as well, and will use <acronym class="acronym">ICMP</acronym> echo
	  request messages if <code class="option">-I</code> is used.  Check the
	  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a> man page for details.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-pathmtudisc"></a>30.3.2.3.1. Path <acronym class="acronym">MTU</acronym> Discovery</h5></div></div></div><p>Internet protocols are designed to be device
	    independent, and one consequence of device independence is
	    that the optimal packet size for a given connection cannot
	    always be predicted reliably.  The main constraint on
	    packet size is the <em class="firstterm">Maximum Transmission
	      Unit</em> (<acronym class="acronym">MTU</acronym>) which sets the
	    upper limit on the packet size for an interface.  Type
	    <code class="command">ifconfig</code> to view the
	    <acronym class="acronym">MTU</acronym>s for a system's network
	    interfaces.</p><p><acronym class="acronym">TCP/IP</acronym> uses a process known as path
	    <acronym class="acronym">MTU</acronym> discovery to determine the right
	    packet size for a connection.  This process sends packets
	    of varying sizes with the <span class="quote">&#8220;<span class="quote">Do not fragment</span>&#8221;</span>
	    flag set, expecting an <acronym class="acronym">ICMP</acronym> return
	    packet of <span class="quote">&#8220;<span class="quote">type 3, code 4</span>&#8221;</span> when the upper
	    limit has been reached.  Type 3 means <span class="quote">&#8220;<span class="quote">destination
	      unreachable</span>&#8221;</span>, and code 4 is short for
	    <span class="quote">&#8220;<span class="quote">fragmentation needed, but the do-not-fragment flag
	      is set</span>&#8221;</span>.  To allow path MTU discovery in order
	    to support connections to other <acronym class="acronym">MTU</acronym>s,
	    add the <code class="literal">destination unreachable</code> type to
	    the <code class="literal">icmp_types</code> macro:</p><pre class="programlisting">icmp_types = "{ echoreq, unreach }"</pre><p>Since the pass rule already uses that macro, it does
	    not need to be modified to support the new
	    <acronym class="acronym">ICMP</acronym> type:</p><pre class="programlisting">pass inet proto icmp all icmp-type $icmp_types keep state</pre><p><span class="application">PF</span> allows filtering on all
	    variations of <acronym class="acronym">ICMP</acronym> types and codes.
	    The list of possible types and codes are documented in
	    <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">icmp</span>(4)</span></a> and <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">icmp6</span>(4)</span></a>.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-tables"></a>30.3.2.4. Using Tables</h4></div></div></div><p>Some types of data are relevant to filtering and
	  redirection at a given time, but their definition is too
	  long to be included in the ruleset file.
	  <span class="application">PF</span> supports the use of tables,
	  which are defined lists that can be manipulated without
	  needing to reload the entire ruleset, and which can provide
	  fast lookups.  Table names are always enclosed within
	  <code class="literal">&lt; &gt;</code>, like this:</p><pre class="programlisting">table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre><p>In this example, the <code class="literal">192.168.2.0/24</code>
	  network is part of the table, except for the address
	  <code class="literal">192.168.2.5</code>, which is excluded using the
	  <code class="literal">!</code> operator.  It is also possible to load
	  tables from files where each item is on a separate line, as
	  seen in this example
	  <code class="filename">/etc/clients</code>:</p><pre class="programlisting">192.168.2.0/24
!192.168.2.5</pre><p>To refer to the file, define the table like this:</p><pre class="programlisting">table &lt;clients&gt; persist file "/etc/clients"</pre><p>Once the table is defined, it can be referenced by a
	  rule:</p><pre class="programlisting">pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre><p>A table's contents can be manipulated live, using
	  <code class="command">pfctl</code>.  This example adds another network
	  to the table:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -t clients -T add 192.168.1.0/16</code></strong></pre><p>Note that any changes made this way will take affect
	  now, making them ideal for testing, but will not survive a
	  power failure or reboot.  To make the changes permanent,
	  modify the definition of the table in the ruleset or edit
	  the file that the table refers to.  One can maintain the
	  on-disk copy of the table using a <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> job which
	  dumps the table's contents to disk at regular intervals,
	  using a command such as <code class="command">pfctl -t clients -T show
	    &gt;/etc/clients</code>.  Alternatively,
	  <code class="filename">/etc/clients</code> can be updated with the
	  in-memory table contents:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -t clients -T replace -f /etc/clients</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-overload"></a>30.3.2.5. Using Overload Tables to Protect
	  <acronym class="acronym">SSH</acronym></h4></div></div></div><p>Those who run <acronym class="acronym">SSH</acronym> on an external
	  interface have probably seen something like this in the
	  authentication logs:</p><pre class="programlisting">Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre><p>This is indicative of a brute force attack where
	  somebody or some program is trying to discover the user name
	  and password which will let them into the system.</p><p>If external <acronym class="acronym">SSH</acronym> access is needed for
	  legitimate users, changing the default port used by
	  <acronym class="acronym">SSH</acronym> can offer some protection.  However,
	  <span class="application">PF</span> provides a more elegant
	  solution.  Pass rules can contain limits on what connecting
	  hosts can do and violators can be banished to a table of
	  addresses which are denied some or all access.  It is even
	  possible to drop all existing connections from machines
	  which overreach the limits.</p><p>To configure this, create this table in the tables
	  section of the ruleset:</p><pre class="programlisting">table &lt;bruteforce&gt; persist</pre><p>Then, somewhere early in the ruleset, add rules to block
	  brute access while allowing legitimate access:</p><pre class="programlisting">block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn <em class="replaceable"><code>100</code></em>, max-src-conn-rate <em class="replaceable"><code>15/5</code></em>, \
    overload &lt;bruteforce&gt; flush global)</pre><p>The part in parentheses defines the limits and the
	  numbers should be changed to meet local requirements.  It
	  can be read as follows:</p><p><code class="literal">max-src-conn</code> is the number of
	  simultaneous connections allowed from one host.</p><p><code class="literal">max-src-conn-rate</code> is the rate of new
	  connections allowed from any single host
	  (<em class="replaceable"><code>15</code></em>) per number of seconds
	  (<em class="replaceable"><code>5</code></em>).</p><p><code class="literal">overload &lt;bruteforce&gt;</code> means
	  that any host which exceeds these limits gets its address
	  added to the <code class="literal">bruteforce</code> table.  The
	  ruleset blocks all traffic from addresses in the
	  <code class="literal">bruteforce</code> table.</p><p>Finally, <code class="literal">flush global</code> says that when
	  a host reaches the limit, that all
	  (<code class="literal">global</code>) of that host's connections will
	  be terminated (<code class="literal">flush</code>).</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">These rules will <span class="emphasis"><em>not</em></span> block slow
	    bruteforcers, as described in <a class="link" href="http://home.nuug.no/~peter/hailmary2013/" target="_top">http://home.nuug.no/~peter/hailmary2013/</a>.</p></div><p>This example ruleset is intended mainly as an
	  illustration.  For example, if a generous number of
	  connections in general are wanted, but the desire is to be
	  more restrictive when it comes to
	  <span class="application">ssh</span>, supplement the rule above
	  with something like the one below, early on in the rule
	  set:</p><pre class="programlisting">pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre><div xmlns="" class="note"><h3 class="admontitle">It May Not be Necessary to Block All
	    Overloaders: </h3><p xmlns="http://www.w3.org/1999/xhtml">It is worth noting that the overload mechanism is a
	    general technique which does not apply exclusively to
	    <acronym class="acronym">SSH</acronym>, and it is not always optimal to
	    entirely block all traffic from offenders.</p><p xmlns="http://www.w3.org/1999/xhtml">For example, an overload rule could be used to
	    protect a mail service or a web service, and the overload
	    table could be used in a rule to assign offenders to a
	    queue with a minimal bandwidth allocation or to redirect
	    to a specific web page.</p></div><p>Over time, tables will be filled by overload rules and
	  their size will grow incrementally, taking up more memory.
	  Sometimes an <acronym class="acronym">IP</acronym> address that is blocked
	  is a dynamically assigned one, which has since been assigned
	  to a host who has a legitimate reason to communicate with
	  hosts in the local network.</p><p>For situations like these,
	  <span class="application">pfctl</span> provides the ability to
	  expire table entries.  For example, this command will remove
	  <code class="literal">&lt;bruteforce&gt;</code> table entries which
	  have not been referenced for <code class="literal">86400</code>
	  seconds:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pfctl -t bruteforce -T expire 86400</code></strong></pre><p>Similar functionality is provided by
	  <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/security/expiretable/pkg-descr">security/expiretable</a>, which removes table
	  entries which have not been accessed for a specified period
	  of time.</p><p>Once installed, <span class="application">expiretable</span>
	  can be run to remove <code class="literal">&lt;bruteforce&gt;</code>
	  table entries older than a specified age.  This example
	  removes all entries older than 24 hours:</p><pre class="programlisting">/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-spamd"></a>30.3.2.6. Protecting Against <acronym class="acronym">SPAM</acronym></h4></div></div></div><p>Not to be confused with the
	  <span class="application">spamd</span> daemon which comes bundled
	  with <span class="application">spamassassin</span>,
	  <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/mail/spamd/pkg-descr">mail/spamd</a> can be configured with
	  <span class="application">PF</span> to provide an outer defense
	  against <acronym class="acronym">SPAM</acronym>.  This
	  <span class="application">spamd</span> hooks into the
	  <span class="application">PF</span> configuration using a set of
	  redirections.</p><p>Spammers tend to send a large number of messages, and
	  <acronym class="acronym">SPAM</acronym> is mainly sent from a few spammer
	  friendly networks and a large number of hijacked machines,
	  both of which are reported to
	  <em class="firstterm">blacklists</em> fairly quickly.</p><p>When an <acronym class="acronym">SMTP</acronym> connection from an
	  address in a blacklist is received,
	  <span class="application">spamd</span> presents its banner and
	  immediately switches to a mode where it answers
	  <acronym class="acronym">SMTP</acronym> traffic one byte at a time.  This
	  technique, which is intended to waste as much time as
	  possible on the spammer's end, is called
	  <em class="firstterm">tarpitting</em>.  The specific
	  implementation which uses one byte <acronym class="acronym">SMTP</acronym>
	  replies is often referred to as
	  <em class="firstterm">stuttering</em>.</p><p>This example demonstrates the basic procedure for
	  setting up <span class="application">spamd</span> with
	  automatically updated blacklists.  Refer to the man pages
	  which are installed with <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/mail/spamd/pkg-descr">mail/spamd</a> for
	  more information.</p><div class="procedure"><a id="idp71756664"></a><div class="procedure-title">Procedure 30.1. Configuring <span class="application">spamd</span></div><ol class="procedure" type="1"><li class="step"><p>Install the <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/mail/spamd/pkg-descr">mail/spamd</a> package
	      or port.  To use <span class="application">spamd</span>'s
	      greylisting features, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">fdescfs</span>(5)</span></a> must be mounted at
	      <code class="filename">/dev/fd</code>.  Add the following line to
	      <code class="filename">/etc/fstab</code>:</p><pre class="programlisting"> fdescfs /dev/fd fdescfs rw 0 0</pre><p>Then, mount the filesystem:</p><pre class="programlisting"><code class="prompt">#</code> <strong class="userinput"><code>mount fdescfs</code></strong></pre></li><li class="step"><p>Next, edit the <span class="application">PF</span> ruleset
	      to include:</p><pre class="programlisting">table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre><p>The two tables <code class="literal">&lt;spamd&gt;</code> and
	      <code class="literal">&lt;spamd-white&gt;</code> are essential.
	      <acronym class="acronym">SMTP</acronym> traffic from an address listed
	      in <code class="literal">&lt;spamd&gt;</code> but not in
	      <code class="literal">&lt;spamd-white&gt;</code> is redirected to
	      the <span class="application">spamd</span> daemon listening at
	      port 8025.</p></li><li class="step"><p>The next step is to configure
	      <span class="application">spamd</span> in
	      <code class="filename">/usr/local/etc/spamd.conf</code> and to
	      add some <code class="filename">rc.conf</code> parameters.</p><p>The installation of <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/mail/spamd/pkg-descr">mail/spamd</a>
	      includes a sample configuration file
	      (<code class="filename">/usr/local/etc/spamd.conf.sample</code>)
	      and a man page for <code class="filename">spamd.conf</code>.
	      Refer to these for additional configuration options
	      beyond those shown in this example.</p><p>One of the first lines in the configuration file
	      that does not begin with a <code class="literal">#</code> comment
	      sign contains the block which defines the
	      <code class="literal">all</code> list, which specifies the lists
	      to use:</p><pre class="programlisting">all:\
    :traplist:whitelist:</pre><p>This entry adds the desired blacklists, separated by
	      colons (<code class="literal">:</code>).  To use a whitelist to
	      subtract addresses from a blacklist, add the name of the
	      whitelist <span class="emphasis"><em>immediately</em></span> after the
	      name of that blacklist.  For example:
	      <code class="literal">:blacklist:whitelist:</code>.</p><p>This is followed by the specified blacklist's
	      definition:</p><pre class="programlisting">traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre><p>where the first line is the name of the blacklist
	      and the second line specifies the list type.  The
	      <code class="literal">msg</code> field contains the message to
	      display to blacklisted senders during the
	      <acronym class="acronym">SMTP</acronym> dialogue.  The
	      <code class="literal">method</code> field specifies how
	      <span class="application">spamd-setup</span> fetches the list
	      data; supported methods are <code class="literal">http</code>,
	      <code class="literal">ftp</code>, from a
	      <code class="literal">file</code> in a mounted file system, and
	      via <code class="literal">exec</code> of an external program.
	      Finally, the <code class="literal">file</code> field specifies
	      the name of the file <span class="application">spamd</span>
	      expects to receive.</p><p>The definition of the specified whitelist is
	      similar, but omits the <code class="literal">msg</code> field
	      since a message is not needed:</p><pre class="programlisting">whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre><div xmlns="" class="tip"><h3 class="admontitle">Choose Data Sources with Care: </h3><p xmlns="http://www.w3.org/1999/xhtml">Using all the blacklists in the sample
		<code class="filename">spamd.conf</code> will blacklist large
		blocks of the Internet.  Administrators need to edit
		the file to create an optimal configuration which uses
		applicable data sources and, when necessary, uses
		custom lists.</p></div><p>Next, add this entry to
	      <code class="filename">/etc/rc.conf</code>.  Additional flags are
	      described in the man page specified by the
	      comment:</p><pre class="programlisting">spamd_flags="-v" # use "" and see spamd-setup(8) for flags</pre><p>When finished, reload the ruleset, start
	      <span class="application">spamd</span> by typing
	      <code class="command">service obspamd start</code>, and complete
	      the configuration using <code class="command">spamd-setup</code>.
	      Finally, create a <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> job which calls
	      <code class="command">spamd-setup</code> to update the tables at
	      reasonable intervals.</p></li></ol></div><p>On a typical gateway in front of a mail server, hosts
	  will soon start getting trapped within a few seconds to
	  several minutes.</p><p><span class="application">PF</span> also supports
	  <em class="firstterm">greylisting</em>, which temporarily
	  rejects messages from unknown hosts with
	  <em class="replaceable"><code>45n</code></em> codes.  Messages from
	  greylisted hosts which try again within a reasonable time
	  are let through.  Traffic from senders which are set up to
	  behave within the limits set by RFC 1123 and RFC 2821 are
	  immediately let through.</p><p>More information about greylisting as a technique can be
	  found at the <a class="link" href="http://www.greylisting.org/" target="_top">greylisting.org</a>
	  web site.  The most amazing thing about greylisting, apart
	  from its simplicity, is that it still works.  Spammers and
	  malware writers have been very slow to adapt to bypass this
	  technique.</p><p>The basic procedure for configuring greylisting is as
	  follows:</p><div class="procedure"><a id="idp71808376"></a><div class="procedure-title">Procedure 30.2. Configuring Greylisting</div><ol class="procedure" type="1"><li class="step"><p>Make sure that <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">fdescfs</span>(5)</span></a> is mounted as
	      described in Step 1 of the previous Procedure.</p></li><li class="step"><p>To run <span class="application">spamd</span> in
	      greylisting mode, add this line to
	      <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">spamd_grey="YES"  # use spamd greylisting if YES</pre><p>Refer to the <span class="application">spamd</span> man
	      page for descriptions of additional related
	      parameters.</p></li><li class="step"><p>To complete the greylisting setup:</p><pre class="programlisting"><code class="prompt">#</code> <strong class="userinput"><code>service obspamd restart</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>service obspamlogd start</code></strong></pre></li></ol></div><p>Behind the scenes, the <span class="application">spamdb</span>
	  database tool and the <span class="application">spamlogd</span>
	  whitelist updater perform essential functions for the
	  greylisting feature.  <span class="application">spamdb</span> is
	  the administrator's main interface to managing the black,
	  grey, and white lists via the contents of the
	  <code class="filename">/var/db/spamdb</code> database.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-hygiene"></a>30.3.2.7. Network Hygiene</h4></div></div></div><p>This section describes how
	  <code class="literal">block-policy</code>, <code class="literal">scrub</code>,
	  and <code class="literal">antispoof</code> can be used to make the
	  ruleset behave sanely.</p><p>The <code class="literal">block-policy</code> is an option which
	  can be set in the <code class="literal">options</code> part of the
	  ruleset, which precedes the redirection and filtering rules.
	  This option determines which feedback, if any,
	  <span class="application">PF</span> sends to hosts that are
	  blocked by a rule.  The option has two possible values:
	  <code class="literal">drop</code> drops blocked packets with no
	  feedback, and <code class="literal">return</code> returns a status
	  code such as
	  <code class="computeroutput">Connection refused</code>.</p><p>If not set, the default policy is
	  <code class="literal">drop</code>.  To change the
	  <code class="literal">block-policy</code>, specify the desired
	  value:</p><pre class="programlisting">set block-policy return</pre><p>In <span class="application">PF</span>,
	  <code class="literal">scrub</code> is a keyword which enables network
	  packet normalization.  This process reassembles fragmented
	  packets and drops TCP packets that have invalid flag
	  combinations.  Enabling <code class="literal">scrub</code> provides a
	  measure of protection against certain kinds of attacks
	  based on incorrect handling of packet fragments.  A number
	  of options are available, but the simplest form is suitable
	  for most configurations:</p><pre class="programlisting">scrub in all</pre><p>Some services, such as <acronym class="acronym">NFS</acronym>, require
	  specific fragment handling options.  Refer to <a class="link" href="https://home.nuug.no/~peter/pf/en/scrub.html" target="_top">https://home.nuug.no/~peter/pf/en/scrub.html</a>
	  for more information.</p><p>This example reassembles fragments, clears the
	  <span class="quote">&#8220;<span class="quote">do not fragment</span>&#8221;</span> bit, and sets the maximum
	  segment size to 1440 bytes:</p><pre class="programlisting">scrub in all fragment reassemble no-df max-mss 1440</pre><p>The <code class="literal">antispoof</code> mechanism protects
	  against activity from spoofed or forged
	  <acronym class="acronym">IP</acronym> addresses, mainly by blocking packets
	  appearing on interfaces and in directions which are
	  logically not possible.</p><p>These rules weed out spoofed traffic coming in from the
	  rest of the world as well as any spoofed packets which
	  originate in the local network:</p><pre class="programlisting">antispoof for $ext_if
antispoof for $int_if</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="pftut-unrouteables"></a>30.3.2.8. Handling Non-Routable Addresses</h4></div></div></div><p>Even with a properly configured gateway to handle
	  network address translation, one may have to compensate for
	  other people's misconfigurations.  A common misconfiguration
	  is to let traffic with non-routable addresses out to the
	  Internet.  Since traffic from non-routeable addresses can
	  play a part in several <acronym class="acronym">DoS</acronym> attack
	  techniques, consider explicitly blocking traffic from
	  non-routeable addresses from entering the network through
	  the external interface.</p><p>In this example, a macro containing non-routable
	  addresses is defined, then used in blocking rules.  Traffic
	  to and from these addresses is quietly dropped on the
	  gateway's external
	  interface.</p><pre class="programlisting">martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp71845880"></a>30.3.3. Enabling <span class="application">ALTQ</span></h3></div></div></div><p>On FreeBSD, <span class="application">ALTQ</span> can be used with
	<span class="application">PF</span> to provide Quality of Service
	(<acronym class="acronym">QOS</acronym>).  Once
	<span class="application">ALTQ</span> is enabled, queues can be
	defined in the ruleset which determine the processing priority
	of outbound packets.</p><p>Before enabling <span class="application">ALTQ</span>, refer to
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">altq</span>(4)</span></a> to determine if the drivers for the network cards
	installed on the system support it.</p><p><span class="application">ALTQ</span> is not available as a
	loadable kernel module.  If the system's interfaces support
	<span class="application">ALTQ</span>, create a custom kernel using
	the instructions in <a class="xref" href="kernelconfig.html" title="Chapter 8. Configuring the FreeBSD Kernel">Chapter 8, <em>Configuring the FreeBSD Kernel</em></a>.  The
	following kernel options are available.  The first is needed
	to enable <span class="application">ALTQ</span>.  At least one of
	the other options is necessary to specify the queueing
	scheduler algorithm:</p><pre class="programlisting">options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre><p>The following scheduler algorithms are available:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CBQ</span></dt><dd><p>Class Based Queuing (<acronym class="acronym">CBQ</acronym>) is
	      used to divide a connection's bandwidth into different
	      classes or queues to prioritize traffic based on filter
	      rules.</p></dd><dt><span class="term">RED</span></dt><dd><p>Random Early Detection (<acronym class="acronym">RED</acronym>) is
	      used to avoid network congestion by measuring the length
	      of the queue and comparing it to the minimum and maximum
	      thresholds for the queue.  When the queue is over the
	      maximum, all new packets are randomly dropped.</p></dd><dt><span class="term">RIO</span></dt><dd><p>In Random Early Detection In and Out
	      (<acronym class="acronym">RIO</acronym>) mode, <acronym class="acronym">RED</acronym>
	      maintains multiple average queue lengths and multiple
	      threshold values, one for each
	      <acronym class="acronym">QOS</acronym> level.</p></dd><dt><span class="term">HFSC</span></dt><dd><p>Hierarchical Fair Service Curve Packet Scheduler
	      (<acronym class="acronym">HFSC</acronym>) is described in <code class="uri"><a class="uri" href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html" target="_top">http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a></code>.</p></dd><dt><span class="term">PRIQ</span></dt><dd><p>Priority Queuing (<acronym class="acronym">PRIQ</acronym>) always
	      passes traffic that is in a higher queue first.</p></dd></dl></div><p>More information about the scheduling
	algorithms and example rulesets are available at the <code class="uri"><a class="uri" href="https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html" target="_top">OpenBSD's web archive</a></code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="firewalls-concepts.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="firewalls.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="firewalls-ipfw.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">30.2. Firewall Concepts </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 30.4. <span class="application">IPFW</span></td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>