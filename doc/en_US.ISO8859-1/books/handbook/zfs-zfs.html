<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>19.4. zfs Administration</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Handbook" /><link rel="up" href="zfs.html" title="Chapter 19. The Z File System (ZFS)" /><link rel="prev" href="zfs-zpool.html" title="19.3. zpool Administration" /><link rel="next" href="zfs-zfs-allow.html" title="19.5. Delegated Administration" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">19.4. <code class="command">zfs</code> Administration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="zfs-zpool.html">Prev</a> </td><th width="60%" align="center">Chapter 19. The Z File System (<acronym class="acronym">ZFS</acronym>)</th><td width="20%" align="right"> <a accesskey="n" href="zfs-zfs-allow.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="zfs-zfs"></a>19.4. <code class="command">zfs</code> Administration</h2></div></div></div><p>The <code class="command">zfs</code> utility is responsible for
      creating, destroying, and managing all <acronym class="acronym">ZFS</acronym>
      datasets that exist within a pool.  The pool is managed using
      <a class="link" href="zfs-zpool.html" title="19.3. zpool Administration"><code class="command">zpool</code></a>.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-create"></a>19.4.1. Creating and Destroying Datasets</h3></div></div></div><p>Unlike traditional disks and volume managers, space in
	<acronym class="acronym">ZFS</acronym> is <span class="emphasis"><em>not</em></span>
	preallocated.  With traditional file systems, after all of the
	space is partitioned and assigned, there is no way to add an
	additional file system without adding a new disk.  With
	<acronym class="acronym">ZFS</acronym>, new file systems can be created at any
	time.  Each <a class="link" href="zfs-term.html#zfs-term-dataset"><span class="emphasis"><em>dataset</em></span></a>
	has properties including features like compression,
	deduplication, caching, and quotas, as well as other useful
	properties like readonly, case sensitivity, network file
	sharing, and a mount point.  Datasets can be nested inside
	each other, and child datasets will inherit properties from
	their parents.  Each dataset can be administered,
	<a class="link" href="zfs-zfs-allow.html" title="19.5. Delegated Administration">delegated</a>,
	<a class="link" href="zfs-zfs.html#zfs-zfs-send" title="19.4.7. Replication">replicated</a>,
	<a class="link" href="zfs-zfs.html#zfs-zfs-snapshot" title="19.4.5. Managing Snapshots">snapshotted</a>,
	<a class="link" href="zfs-zfs.html#zfs-zfs-jail" title="19.4.12. ZFS and Jails">jailed</a>, and destroyed as a
	unit.  There are many advantages to creating a separate
	dataset for each different type or set of files.  The only
	drawbacks to having an extremely large number of datasets is
	that some commands like <code class="command">zfs list</code> will be
	slower, and the mounting of hundreds or even thousands of
	datasets can slow the FreeBSD boot process.</p><p>Create a new dataset and enable <a class="link" href="zfs-term.html#zfs-term-compression-lz4">LZ4
	  compression</a> on it:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<code class="prompt">#</code> <strong class="userinput"><code>zfs create -o compress=lz4 <em class="replaceable"><code>mypool/usr/mydataset</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</pre><p>Destroying a dataset is much quicker than deleting all
	of the files that reside on the dataset, as it does not
	involve scanning all of the files and updating all of the
	corresponding metadata.</p><p>Destroy the previously-created dataset:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<code class="prompt">#</code> <strong class="userinput"><code>zfs destroy <em class="replaceable"><code>mypool/usr/mydataset</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</pre><p>In modern versions of <acronym class="acronym">ZFS</acronym>,
	<code class="command">zfs destroy</code> is asynchronous, and the free
	space might take several minutes to appear in the pool.  Use
	<code class="command">zpool get freeing
	  <em class="replaceable"><code>poolname</code></em></code> to see the
	<code class="literal">freeing</code> property, indicating how many
	datasets are having their blocks freed in the background.
	If there are child datasets, like
	<a class="link" href="zfs-term.html#zfs-term-snapshot">snapshots</a> or other
	datasets, then the parent cannot be destroyed.  To destroy a
	dataset and all of its children, use <code class="option">-r</code> to
	recursively destroy the dataset and all of its children.
	Use <code class="option">-n</code> <code class="option">-v</code> to list datasets
	and snapshots that would be destroyed by this operation, but
	do not actually destroy anything.  Space that would be
	reclaimed by destruction of snapshots is also shown.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-volume"></a>19.4.2. Creating and Destroying Volumes</h3></div></div></div><p>A volume is a special type of dataset.  Rather than being
	mounted as a file system, it is exposed as a block device
	under
	<code class="filename">/dev/zvol/<em class="replaceable"><code>poolname</code></em>/<em class="replaceable"><code>dataset</code></em></code>.
	This allows the volume to be used for other file systems, to
	back the disks of a virtual machine, or to be exported using
	protocols like <acronym class="acronym">iSCSI</acronym> or
	<acronym class="acronym">HAST</acronym>.</p><p>A volume can be formatted with any file system, or used
	without a file system to store raw data.  To the user, a
	volume appears to be a regular disk.  Putting ordinary file
	systems on these <span class="emphasis"><em>zvols</em></span> provides features
	that ordinary disks or file systems do not normally have.  For
	example, using the compression property on a 250 MB
	volume allows creation of a compressed <acronym class="acronym">FAT</acronym>
	file system.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs create -V 250m -o compression=on tank/fat32</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list tank</code></strong>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<code class="prompt">#</code> <strong class="userinput"><code>newfs_msdos -F32 /dev/zvol/tank/fat32</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount -t msdosfs /dev/zvol/tank/fat32 /mnt</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>df -h /mnt | grep fat32</code></strong>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<code class="prompt">#</code> <strong class="userinput"><code>mount | grep fat32</code></strong>
/dev/zvol/tank/fat32 on /mnt (msdosfs, local)</pre><p>Destroying a volume is much the same as destroying a
	regular file system dataset.  The operation is nearly
	instantaneous, but it may take several minutes for the free
	space to be reclaimed in the background.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-rename"></a>19.4.3. Renaming a Dataset</h3></div></div></div><p>The name of a dataset can be changed with
	<code class="command">zfs rename</code>.  The parent of a dataset can
	also be changed with this command.  Renaming a dataset to be
	under a different parent dataset will change the value of
	those properties that are inherited from the parent dataset.
	When a dataset is renamed, it is unmounted and then remounted
	in the new location (which is inherited from the new parent
	dataset).  This behavior can be prevented with
	<code class="option">-u</code>.</p><p>Rename a dataset and move it to be under a different
	parent dataset:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<code class="prompt">#</code> <strong class="userinput"><code>zfs rename <em class="replaceable"><code>mypool/usr/mydataset</code></em> <em class="replaceable"><code>mypool/var/newname</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</pre><p>Snapshots can also be renamed like this.  Due to the
	nature of snapshots, they cannot be renamed into a different
	parent dataset.  To rename a recursive snapshot, specify
	<code class="option">-r</code>, and all snapshots with the same name in
	child datasets with also be renamed.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<code class="prompt">#</code> <strong class="userinput"><code>zfs rename <em class="replaceable"><code>mypool/var/newname@first_snapshot</code></em> <em class="replaceable"><code>new_snapshot_name</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-set"></a>19.4.4. Setting Dataset Properties</h3></div></div></div><p>Each <acronym class="acronym">ZFS</acronym> dataset has a number of
	properties that control its behavior.  Most properties are
	automatically inherited from the parent dataset, but can be
	overridden locally.  Set a property on a dataset with
	<code class="command">zfs set
	  <em class="replaceable"><code>property</code></em>=<em class="replaceable"><code>value</code></em>
	  <em class="replaceable"><code>dataset</code></em></code>.  Most
	properties have a limited set of valid values,
	<code class="command">zfs get</code> will display each possible property
	and valid values.  Most properties can be reverted to their
	inherited values using <code class="command">zfs inherit</code>.</p><p>User-defined properties can also be set.  They become part
	of the dataset configuration and can be used to provide
	additional information about the dataset or its contents.  To
	distinguish these custom properties from the ones supplied as
	part of <acronym class="acronym">ZFS</acronym>, a colon (<code class="literal">:</code>)
	is used to create a custom namespace for the property.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set <em class="replaceable"><code>custom</code></em>:<em class="replaceable"><code>costcenter</code></em>=<em class="replaceable"><code>1234</code></em> <em class="replaceable"><code>tank</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs get <em class="replaceable"><code>custom</code></em>:<em class="replaceable"><code>costcenter</code></em> <em class="replaceable"><code>tank</code></em></code></strong>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  local</pre><p>To remove a custom property, use
	<code class="command">zfs inherit</code> with <code class="option">-r</code>.  If
	the custom property is not defined in any of the parent
	datasets, it will be removed completely (although the changes
	are still recorded in the pool's history).</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs inherit -r <em class="replaceable"><code>custom</code></em>:<em class="replaceable"><code>costcenter</code></em> <em class="replaceable"><code>tank</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs get <em class="replaceable"><code>custom</code></em>:<em class="replaceable"><code>costcenter</code></em> <em class="replaceable"><code>tank</code></em></code></strong>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
<code class="prompt">#</code> <strong class="userinput"><code>zfs get all <em class="replaceable"><code>tank</code></em> | grep <em class="replaceable"><code>custom</code></em>:<em class="replaceable"><code>costcenter</code></em></code></strong>
<code class="prompt">#</code></pre><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-set-share"></a>19.4.4.1. Getting and Setting Share Properties</h4></div></div></div><p>Two commonly used and useful dataset properties are the
	<acronym class="acronym">NFS</acronym> and <acronym class="acronym">SMB</acronym> share
	options.  Setting these define if and how
	<acronym class="acronym">ZFS</acronym> datasets may be shared on the network.
	At present, only setting sharing via <acronym class="acronym">NFS</acronym> is
	supported on FreeBSD.  To get the current status of
	a share, enter:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get sharenfs <em class="replaceable"><code>mypool/usr/home</code></em></code></strong>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharenfs  on       local
<code class="prompt">#</code> <strong class="userinput"><code>zfs get sharesmb <em class="replaceable"><code>mypool/usr/home</code></em></code></strong>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharesmb  off      local</pre><p>To enable sharing of a dataset, enter:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code> zfs set sharenfs=on <em class="replaceable"><code>mypool/usr/home</code></em></code></strong></pre><p>It is also possible to set additional options for sharing
      datasets through <acronym class="acronym">NFS</acronym>, such as
      <code class="option">-alldirs</code>, <code class="option">-maproot</code> and
      <code class="option">-network</code>.  To set additional options to a
      dataset shared through NFS, enter:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code> zfs set sharenfs="-alldirs,-maproot=<em class="replaceable"><code>root</code></em>,-network=<em class="replaceable"><code>192.168.1.0/24</code></em>" <em class="replaceable"><code>mypool/usr/home</code></em></code></strong></pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-snapshot"></a>19.4.5. Managing Snapshots</h3></div></div></div><p><a class="link" href="zfs-term.html#zfs-term-snapshot">Snapshots</a> are one
	of the most powerful features of <acronym class="acronym">ZFS</acronym>.  A
	snapshot provides a read-only, point-in-time copy of the
	dataset.  With Copy-On-Write (<acronym class="acronym">COW</acronym>),
	snapshots can be created quickly by preserving the older
	version of the data on disk.  If no snapshots exist, space is
	reclaimed for future use when data is rewritten or deleted.
	Snapshots preserve disk space by recording only the
	differences between the current dataset and a previous
	version.  Snapshots are allowed only on whole datasets, not on
	individual files or directories.  When a snapshot is created
	from a dataset, everything contained in it is duplicated.
	This includes the file system properties, files, directories,
	permissions, and so on.  Snapshots use no additional space
	when they are first created, only consuming space as the
	blocks they reference are changed.  Recursive snapshots taken
	with <code class="option">-r</code> create a snapshot with the same name
	on the dataset and all of its children, providing a consistent
	moment-in-time snapshot of all of the file systems.  This can
	be important when an application has files on multiple
	datasets that are related or dependent upon each other.
	Without snapshots, a backup would have copies of the files
	from different points in time.</p><p>Snapshots in <acronym class="acronym">ZFS</acronym> provide a variety of
	features that even other file systems with snapshot
	functionality lack.  A typical example of snapshot use is to
	have a quick way of backing up the current state of the file
	system when a risky action like a software installation or a
	system upgrade is performed.  If the action fails, the
	snapshot can be rolled back and the system has the same state
	as when the snapshot was created.  If the upgrade was
	successful, the snapshot can be deleted to free up space.
	Without snapshots, a failed upgrade often requires a restore
	from backup, which is tedious, time consuming, and may require
	downtime during which the system cannot be used.  Snapshots
	can be rolled back quickly, even while the system is running
	in normal operation, with little or no downtime.  The time
	savings are enormous with multi-terabyte storage systems and
	the time required to copy the data from backup.  Snapshots are
	not a replacement for a complete backup of a pool, but can be
	used as a quick and easy way to store a copy of the dataset at
	a specific point in time.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-snapshot-creation"></a>19.4.5.1. Creating Snapshots</h4></div></div></div><p>Snapshots are created  with <code class="command">zfs snapshot
	    <em class="replaceable"><code>dataset</code></em>@<em class="replaceable"><code>snapshotname</code></em></code>.
	  Adding <code class="option">-r</code> creates a snapshot recursively,
	  with the same name on all child datasets.</p><p>Create a recursive snapshot of the entire pool:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -t all</code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot -r <em class="replaceable"><code>mypool@my_recursive_snapshot</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</pre><p>Snapshots are not shown by a normal
	  <code class="command">zfs list</code> operation.  To list snapshots,
	  <code class="option">-t snapshot</code> is appended to
	  <code class="command">zfs list</code>.  <code class="option">-t all</code>
	  displays both file systems and snapshots.</p><p>Snapshots are not mounted directly, so no path is shown in
	  the <code class="literal">MOUNTPOINT</code> column.  There is no
	  mention of available disk space in the
	  <code class="literal">AVAIL</code> column, as snapshots cannot be
	  written to after they are created.  Compare the snapshot
	  to the original dataset from which it was created:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt all <em class="replaceable"><code>mypool/usr/home</code></em></code></strong>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</pre><p>Displaying both the dataset and the snapshot together
	  reveals how snapshots work in
	  <a class="link" href="zfs-term.html#zfs-term-cow">COW</a> fashion.  They save
	  only the changes (<span class="emphasis"><em>delta</em></span>) that were made
	  and not the complete file system contents all over again.
	  This means that snapshots take little space when few changes
	  are made.  Space usage can be made even more apparent by
	  copying a file to the dataset, then making a second
	  snapshot:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cp <em class="replaceable"><code>/etc/passwd</code></em> <em class="replaceable"><code>/var/tmp</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot <em class="replaceable"><code>mypool/var/tmp</code></em>@<em class="replaceable"><code>after_cp</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt all <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</pre><p>The second snapshot contains only the changes to the
	  dataset after the copy operation.  This yields enormous
	  space savings.  Notice that the size of the snapshot
	  <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em>
	  also changed in the <code class="literal">USED</code>
	  column to indicate the changes between itself and the
	  snapshot taken afterwards.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-snapshot-diff"></a>19.4.5.2. Comparing Snapshots</h4></div></div></div><p>ZFS provides a built-in command to compare the
	  differences in content between two snapshots.  This is
	  helpful when many snapshots were taken over time and the
	  user wants to see how the file system has changed over time.
	  For example, <code class="command">zfs diff</code> lets a user find
	  the latest snapshot that still contains a file that was
	  accidentally deleted.  Doing this for the two snapshots that
	  were created in the previous section yields this
	  output:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt all <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<code class="prompt">#</code> <strong class="userinput"><code>zfs diff <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em></code></strong>
M       /var/tmp/
+       /var/tmp/passwd</pre><p>The command lists the changes between the specified
	  snapshot (in this case
	  <code class="literal"><em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em></code>)
	  and the live file system.  The first column shows the
	  type of change:</p><div class="informaltable"><table class="informaltable" width="100%" border="1"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td valign="top">+</td><td valign="top">The path or file was added.</td></tr><tr><td valign="top">-</td><td valign="top">The path or file was deleted.</td></tr><tr><td valign="top">M</td><td valign="top">The path or file was modified.</td></tr><tr><td valign="top">R</td><td valign="top">The path or file was renamed.</td></tr></tbody></table></div><p>Comparing the output with the table, it becomes clear
	  that <code class="filename"><em class="replaceable"><code>passwd</code></em></code>
	  was added after the snapshot
	  <code class="literal"><em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em></code>
	  was created.  This also resulted in a modification to the
	  parent directory mounted at
	  <code class="literal"><em class="replaceable"><code>/var/tmp</code></em></code>.</p><p>Comparing two snapshots is helpful when using the
	  <acronym class="acronym">ZFS</acronym> replication feature to transfer a
	  dataset to a different host for backup purposes.</p><p>Compare two snapshots by providing the full dataset name
	  and snapshot name of both datasets:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cp /var/tmp/passwd /var/tmp/passwd.copy</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot <em class="replaceable"><code>mypool/var/tmp@diff_snapshot</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs diff <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em> <em class="replaceable"><code>mypool/var/tmp@diff_snapshot</code></em></code></strong>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<code class="prompt">#</code> <strong class="userinput"><code>zfs diff <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em> <em class="replaceable"><code>mypool/var/tmp@after_cp</code></em></code></strong>
M       /var/tmp/
+       /var/tmp/passwd</pre><p>A backup administrator can compare two snapshots
	  received from the sending host and determine the actual
	  changes in the dataset.  See the
	  <a class="link" href="zfs-zfs.html#zfs-zfs-send" title="19.4.7. Replication">Replication</a> section for
	  more information.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-snapshot-rollback"></a>19.4.5.3. Snapshot Rollback</h4></div></div></div><p>When at least one snapshot is available, it can be
	  rolled back to at any time.  Most of the time this is the
	  case when the current state of the dataset is no longer
	  required and an older version is preferred.  Scenarios such
	  as local development tests have gone wrong, botched system
	  updates hampering the system's overall functionality, or the
	  requirement to restore accidentally deleted files or
	  directories are all too common occurrences.  Luckily,
	  rolling back a snapshot is just as easy as typing
	  <code class="command">zfs rollback
	    <em class="replaceable"><code>snapshotname</code></em></code>.
	  Depending on how many changes are involved, the operation
	  will finish in a certain amount of time.  During that time,
	  the dataset always remains in a consistent state, much like
	  a database that conforms to ACID principles is performing a
	  rollback.  This is happening while the dataset is live and
	  accessible without requiring a downtime.  Once the snapshot
	  has been rolled back, the dataset has the same state as it
	  had when the snapshot was originally taken.  All other data
	  in that dataset that was not part of the snapshot is
	  discarded.  Taking a snapshot of the current state of the
	  dataset before rolling back to a previous one is a good idea
	  when some data is required later.  This way, the user can
	  roll back and forth between snapshots without losing data
	  that is still valuable.</p><p>In the first example, a snapshot is rolled back because
	  of a careless <code class="command">rm</code> operation that removes
	  too much data than was intended.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt all <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp</code></strong>
passwd          passwd.copy     vi.recover
<code class="prompt">#</code> <strong class="userinput"><code>rm /var/tmp/passwd*</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp</code></strong>
vi.recover</pre><p>At this point, the user realized that too many files
	  were deleted and wants them back.  <acronym class="acronym">ZFS</acronym>
	  provides an easy way to get them back using rollbacks, but
	  only when snapshots of important data are performed on a
	  regular basis.  To get the files back and start over from
	  the last snapshot, issue the command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs rollback <em class="replaceable"><code>mypool/var/tmp@diff_snapshot</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp</code></strong>
passwd          passwd.copy     vi.recover</pre><p>The rollback operation restored the dataset to the state
	  of the last snapshot.  It is also possible to roll back to a
	  snapshot that was taken much earlier and has other snapshots
	  that were created after it.  When trying to do this,
	  <acronym class="acronym">ZFS</acronym> will issue this warning:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt snapshot <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<code class="prompt">#</code> <strong class="userinput"><code>zfs rollback <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em></code></strong>
cannot rollback to 'mypool/var/tmp@my_recursive_snapshot': more recent snapshots exist
use '-r' to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</pre><p>This warning means that snapshots exist between the
	  current state of the dataset and the snapshot to which the
	  user wants to roll back.  To complete the rollback, these
	  snapshots must be deleted.  <acronym class="acronym">ZFS</acronym> cannot
	  track all the changes between different states of the
	  dataset, because snapshots are read-only.
	  <acronym class="acronym">ZFS</acronym> will not delete the affected
	  snapshots unless the user specifies <code class="option">-r</code> to
	  indicate that this is the desired action.  If that is the
	  intention, and the consequences of losing all intermediate
	  snapshots is understood, the command can be issued:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs rollback -r <em class="replaceable"><code>mypool/var/tmp@my_recursive_snapshot</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt snapshot <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp</code></strong>
vi.recover</pre><p>The output from <code class="command">zfs list -t snapshot</code>
	  confirms that the intermediate snapshots
	  were removed as a result of
	  <code class="command">zfs rollback -r</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-snapshot-snapdir"></a>19.4.5.4. Restoring Individual Files from Snapshots</h4></div></div></div><p>Snapshots are mounted in a hidden directory under the
	  parent dataset:
	  <code class="filename">.zfs/snapshots/<em class="replaceable"><code>snapshotname</code></em></code>.
	  By default, these directories will not be displayed even
	  when a standard <code class="command">ls -a</code> is issued.
	  Although the directory is not displayed, it is there
	  nevertheless and can be accessed like any normal directory.
	  The property named <code class="literal">snapdir</code> controls
	  whether these hidden directories show up in a directory
	  listing.  Setting the property to <code class="literal">visible</code>
	  allows them to appear in the output of <code class="command">ls</code>
	  and other commands that deal with directory contents.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get snapdir <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<code class="prompt">#</code> <strong class="userinput"><code>ls -a /var/tmp</code></strong>
.               ..              passwd          vi.recover
<code class="prompt">#</code> <strong class="userinput"><code>zfs set snapdir=visible <em class="replaceable"><code>mypool/var/tmp</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls -a /var/tmp</code></strong>
.               ..              .zfs            passwd          vi.recover</pre><p>Individual files can easily be restored to a previous
	  state by copying them from the snapshot back to the parent
	  dataset.  The directory structure below
	  <code class="filename">.zfs/snapshot</code> has a directory named
	  exactly like the snapshots taken earlier to make it easier
	  to identify them.  In the next example, it is assumed that a
	  file is to be restored from the hidden
	  <code class="filename">.zfs</code> directory by copying it from the
	  snapshot that contained the latest version of the
	  file:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm /var/tmp/passwd</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls -a /var/tmp</code></strong>
.               ..              .zfs            vi.recover
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp/.zfs/snapshot</code></strong>
after_cp                my_recursive_snapshot
<code class="prompt">#</code> <strong class="userinput"><code>ls /var/tmp/.zfs/snapshot/<em class="replaceable"><code>after_cp</code></em></code></strong>
passwd          vi.recover
<code class="prompt">#</code> <strong class="userinput"><code>cp /var/tmp/.zfs/snapshot/<em class="replaceable"><code>after_cp/passwd</code></em> <em class="replaceable"><code>/var/tmp</code></em></code></strong></pre><p>When <code class="command">ls .zfs/snapshot</code> was issued, the
	  <code class="literal">snapdir</code> property might have been set to
	  hidden, but it would still be possible to list the contents
	  of that directory.  It is up to the administrator to decide
	  whether these directories will be displayed.  It is possible
	  to display these for certain datasets and prevent it for
	  others.  Copying files or directories from this hidden
	  <code class="filename">.zfs/snapshot</code> is simple enough.  Trying
	  it the other way around results in this error:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cp <em class="replaceable"><code>/etc/rc.conf</code></em> /var/tmp/.zfs/snapshot/<em class="replaceable"><code>after_cp/</code></em></code></strong>
cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</pre><p>The error reminds the user that snapshots are read-only
	  and cannot be changed after creation.  Files cannot be
	  copied into or removed from snapshot directories because
	  that would change the state of the dataset they
	  represent.</p><p>Snapshots consume space based on how much the parent
	  file system has changed since the time of the snapshot.  The
	  <code class="literal">written</code> property of a snapshot tracks how
	  much space is being used by the snapshot.</p><p>Snapshots are destroyed and the space reclaimed with
	  <code class="command">zfs destroy
	    <em class="replaceable"><code>dataset</code></em>@<em class="replaceable"><code>snapshot</code></em></code>.
	  Adding <code class="option">-r</code> recursively removes all snapshots
	  with the same name under the parent dataset.  Adding
	  <code class="option">-n -v</code> to the command displays a list of the
	  snapshots that would be deleted and an estimate of how much
	  space would be reclaimed without performing the actual
	  destroy operation.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-clones"></a>19.4.6. Managing Clones</h3></div></div></div><p>A clone is a copy of a snapshot that is treated more like
	a regular dataset.  Unlike a snapshot, a clone is not read
	only, is mounted, and can have its own properties.  Once a
	clone has been created using <code class="command">zfs clone</code>, the
	snapshot it was created from cannot be destroyed.  The
	child/parent relationship between the clone and the snapshot
	can be reversed using <code class="command">zfs promote</code>.  After a
	clone has been promoted, the snapshot becomes a child of the
	clone, rather than of the original parent dataset.  This will
	change how the space is accounted, but not actually change the
	amount of space consumed.  The clone can be mounted at any
	point within the <acronym class="acronym">ZFS</acronym> file system hierarchy,
	not just below the original location of the snapshot.</p><p>To demonstrate the clone feature, this example dataset is
	used:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs list -rt all <em class="replaceable"><code>camino/home/joe</code></em></code></strong>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</pre><p>A typical use for clones is to experiment with a specific
	dataset while keeping the snapshot around to fall back to in
	case something goes wrong.  Since snapshots cannot be
	changed, a read/write clone of a snapshot is created.  After
	the desired result is achieved in the clone, the clone can be
	promoted to a dataset and the old file system removed.  This
	is not strictly necessary, as the clone and dataset can
	coexist without problems.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs clone <em class="replaceable"><code>camino/home/joe</code></em>@<em class="replaceable"><code>backup</code></em> <em class="replaceable"><code>camino/home/joenew</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls /usr/home/joe*</code></strong>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<code class="prompt">#</code> <strong class="userinput"><code>df -h /usr/home</code></strong>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</pre><p>After a clone is created it is an exact copy of the state
	the dataset was in when the snapshot was taken.  The clone can
	now be changed independently from its originating dataset.
	The only connection between the two is the snapshot.
	<acronym class="acronym">ZFS</acronym> records this connection in the property
	<code class="literal">origin</code>.  Once the dependency between the
	snapshot and the clone has been removed by promoting the clone
	using <code class="command">zfs promote</code>, the
	<code class="literal">origin</code> of the clone is removed as it is now
	an independent dataset.  This example demonstrates it:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get origin <em class="replaceable"><code>camino/home/joenew</code></em></code></strong>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<code class="prompt">#</code> <strong class="userinput"><code>zfs promote <em class="replaceable"><code>camino/home/joenew</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs get origin <em class="replaceable"><code>camino/home/joenew</code></em></code></strong>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</pre><p>After making some changes like copying
	<code class="filename">loader.conf</code> to the promoted clone, for
	example, the old directory becomes obsolete in this case.
	Instead, the promoted clone can replace it.  This can be
	achieved by two consecutive commands: <code class="command">zfs
	  destroy</code> on the old dataset and <code class="command">zfs
	  rename</code> on the clone to name it like the old
	dataset (it could also get an entirely different name).</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cp <em class="replaceable"><code>/boot/defaults/loader.conf</code></em> <em class="replaceable"><code>/usr/home/joenew</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs destroy -f <em class="replaceable"><code>camino/home/joe</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs rename <em class="replaceable"><code>camino/home/joenew</code></em> <em class="replaceable"><code>camino/home/joe</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ls /usr/home/joe</code></strong>
backup.txz     loader.conf     plans.txt
<code class="prompt">#</code> <strong class="userinput"><code>df -h <em class="replaceable"><code>/usr/home</code></em></code></strong>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</pre><p>The cloned snapshot is now handled like an ordinary
	dataset.  It contains all the data from the original snapshot
	plus the files that were added to it like
	<code class="filename">loader.conf</code>.  Clones can be used in
	different scenarios to provide useful features to ZFS users.
	For example, jails could be provided as snapshots containing
	different sets of installed applications.  Users can clone
	these snapshots and add their own applications as they see
	fit.  Once they are satisfied with the changes, the clones can
	be promoted to full datasets and provided to end users to work
	with like they would with a real dataset.  This saves time and
	administrative overhead when providing these jails.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-send"></a>19.4.7. Replication</h3></div></div></div><p>Keeping data on a single pool in one location exposes
	it to risks like theft and natural or human disasters.  Making
	regular backups of the entire pool is vital.
	<acronym class="acronym">ZFS</acronym> provides a built-in serialization
	feature that can send a stream representation of the data to
	standard output.  Using this technique, it is possible to not
	only store the data on another pool connected to the local
	system, but also to send it over a network to another system.
	Snapshots are the basis for this replication (see the section
	on <a class="link" href="zfs-zfs.html#zfs-zfs-snapshot" title="19.4.5. Managing Snapshots"><acronym class="acronym">ZFS</acronym>
	  snapshots</a>).  The commands used for replicating data
	are <code class="command">zfs send</code> and
	<code class="command">zfs receive</code>.</p><p>These examples demonstrate <acronym class="acronym">ZFS</acronym>
	replication with these two pools:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</pre><p>The pool named <em class="replaceable"><code>mypool</code></em> is the
	primary pool where data is written to and read from on a
	regular basis.  A second pool,
	<em class="replaceable"><code>backup</code></em> is used as a standby in case
	the primary pool becomes unavailable.  Note that this
	fail-over is not done automatically by <acronym class="acronym">ZFS</acronym>,
	but must be manually done by a system administrator when
	needed.  A snapshot is used to provide a consistent version of
	the file system to be replicated.  Once a snapshot of
	<em class="replaceable"><code>mypool</code></em> has been created, it can be
	copied to the <em class="replaceable"><code>backup</code></em> pool.  Only
	snapshots can be replicated.  Changes made since the most
	recent snapshot will not be included.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>backup1</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</pre><p>Now that a snapshot exists, <code class="command">zfs send</code>
	can be used to create a stream representing the contents of
	the snapshot.  This stream can be stored as a file or received
	by another pool.  The stream is written to standard output,
	but must be redirected to a file or pipe or an error is
	produced:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs send <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>backup1</code></em></code></strong>
Error: Stream can not be written to a terminal.
You must redirect standard output.</pre><p>To back up a dataset with <code class="command">zfs send</code>,
	redirect to a file located on the mounted backup pool.  Ensure
	that the pool has enough free space to accommodate the size of
	the snapshot being sent, which means all of the data contained
	in the snapshot, not just the changes from the previous
	snapshot.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs send <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>backup1</code></em> &gt; <em class="replaceable"><code>/backup/backup1</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</pre><p>The <code class="command">zfs send</code> transferred all the data
	in the snapshot called <em class="replaceable"><code>backup1</code></em> to
	the pool named <em class="replaceable"><code>backup</code></em>.  Creating
	and sending these snapshots can be done automatically with a
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> job.</p><p>Instead of storing the backups as archive files,
	<acronym class="acronym">ZFS</acronym> can receive them as a live file system,
	allowing the backed up data to be accessed directly.  To get
	to the actual data contained in those streams,
	<code class="command">zfs receive</code> is used to transform the
	streams back into files and directories.  The example below
	combines <code class="command">zfs send</code> and
	<code class="command">zfs receive</code> using a pipe to copy the data
	from one pool to another.  The data can be used directly on
	the receiving pool after the transfer is complete.  A dataset
	can only be replicated to an empty dataset.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>replica1</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs send -v <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>replica1</code></em> | zfs receive <em class="replaceable"><code>backup/mypool</code></em></code></strong>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</pre><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-send-incremental"></a>19.4.7.1. Incremental Backups</h4></div></div></div><p><code class="command">zfs send</code> can also determine the
	  difference between two snapshots and send only the
	  differences between the two.  This saves disk space and
	  transfer time.  For example:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs snapshot <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>replica2</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</pre><p>A second snapshot called
	  <em class="replaceable"><code>replica2</code></em> was created.  This
	  second snapshot contains only the changes that were made to
	  the file system between now and the previous snapshot,
	  <em class="replaceable"><code>replica1</code></em>.  Using
	  <code class="command">zfs send -i</code> and indicating the pair of
	  snapshots generates an incremental replica stream containing
	  only the data that has changed.  This can only succeed if
	  the initial snapshot already exists on the receiving
	  side.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs send -v -i <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>replica1</code></em> <em class="replaceable"><code>mypool</code></em>@<em class="replaceable"><code>replica2</code></em> | zfs receive <em class="replaceable"><code>/backup/mypool</code></em></code></strong>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

<code class="prompt">#</code> <strong class="userinput"><code>zfs list</code></strong>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<code class="prompt">#</code> <strong class="userinput"><code>zfs list -t snapshot</code></strong>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</pre><p>The incremental stream was successfully transferred.
	  Only the data that had changed was replicated, rather than
	  the entirety of <em class="replaceable"><code>replica1</code></em>.  Only
	  the differences were sent, which took much less time to
	  transfer and saved disk space by not copying the complete
	  pool each time.  This is useful when having to rely on slow
	  networks or when costs per transferred byte must be
	  considered.</p><p>A new file system,
	  <em class="replaceable"><code>backup/mypool</code></em>, is available with
	  all of the files and data from the pool
	  <em class="replaceable"><code>mypool</code></em>.  If <code class="option">-P</code>
	  is specified, the properties of the dataset will be copied,
	  including compression settings, quotas, and mount points.
	  When <code class="option">-R</code> is specified, all child datasets of
	  the indicated dataset will be copied, along with all of
	  their properties.  Sending and receiving can be automated so
	  that regular backups are created on the second pool.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-send-ssh"></a>19.4.7.2. Sending Encrypted Backups over
	  <span class="application">SSH</span></h4></div></div></div><p>Sending streams over the network is a good way to keep a
	  remote backup, but it does come with a drawback.  Data sent
	  over the network link is not encrypted, allowing anyone to
	  intercept and transform the streams back into data without
	  the knowledge of the sending user.  This is undesirable,
	  especially when sending the streams over the internet to a
	  remote host.  <span class="application">SSH</span> can be used to
	  securely encrypt data send over a network connection.  Since
	  <acronym class="acronym">ZFS</acronym> only requires the stream to be
	  redirected from standard output, it is relatively easy to
	  pipe it through <span class="application">SSH</span>.  To keep the
	  contents of the file system encrypted in transit and on the
	  remote system, consider using <a class="link" href="https://wiki.freebsd.org/PEFS" target="_top">PEFS</a>.</p><p>A few settings and security precautions must be
	  completed first.  Only the necessary steps required for the
	  <code class="command">zfs send</code> operation are shown here.  For
	  more information on <span class="application">SSH</span>, see
	  <a class="xref" href="openssh.html" title="13.8. OpenSSH">Section 13.8, &#8220;OpenSSH&#8221;</a>.</p><p>This configuration is required:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Passwordless <span class="application">SSH</span> access
	      between sending and receiving host using
	      <span class="application">SSH</span> keys</p></li><li class="listitem"><p>Normally, the privileges of the
	      <code class="systemitem">root</code> user are
	      needed to send and receive streams.  This requires
	      logging in to the receiving system as
	      <code class="systemitem">root</code>.
	      However, logging in as
	      <code class="systemitem">root</code> is
	      disabled by default for security reasons.  The
	      <a class="link" href="zfs-zfs-allow.html" title="19.5. Delegated Administration">ZFS Delegation</a>
	      system can be used to allow a
	      non-<code class="systemitem">root</code> user
	      on each system to perform the respective send and
	      receive operations.</p></li><li class="listitem"><p>On the sending system:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs allow -u someuser send,snapshot <em class="replaceable"><code>mypool</code></em></code></strong></pre></li><li class="listitem"><p>To mount the pool, the unprivileged user must own
	      the directory, and regular users must be allowed to
	      mount file systems.  On the receiving system:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl vfs.usermount=1</code></strong>
vfs.usermount: 0 -&gt; 1
<code class="prompt">#</code> <strong class="userinput"><code>echo vfs.usermount=1 &gt;&gt; /etc/sysctl.conf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs create <em class="replaceable"><code>recvpool/backup</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs allow -u <em class="replaceable"><code>someuser</code></em> create,mount,receive <em class="replaceable"><code>recvpool/backup</code></em></code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chown <em class="replaceable"><code>someuser</code></em> <em class="replaceable"><code>/recvpool/backup</code></em></code></strong></pre></li></ul></div><p>The unprivileged user now has the ability to receive and
	  mount datasets, and the <em class="replaceable"><code>home</code></em>
	  dataset can be replicated to the remote system:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>zfs snapshot -r <em class="replaceable"><code>mypool/home</code></em>@<em class="replaceable"><code>monday</code></em></code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>zfs send -R <em class="replaceable"><code>mypool/home</code></em>@<em class="replaceable"><code>monday</code></em> | ssh <em class="replaceable"><code>someuser@backuphost</code></em> zfs recv -dvu <em class="replaceable"><code>recvpool/backup</code></em></code></strong></pre><p>A recursive snapshot called
	  <em class="replaceable"><code>monday</code></em> is made of the file system
	  dataset <em class="replaceable"><code>home</code></em> that resides on the
	  pool <em class="replaceable"><code>mypool</code></em>.  Then it is sent
	  with <code class="command">zfs send -R</code> to include the dataset,
	  all child datasets, snapshots, clones, and settings in the
	  stream.  The output is piped to the waiting
	  <code class="command">zfs receive</code> on the remote host
	  <em class="replaceable"><code>backuphost</code></em> through
	  <span class="application">SSH</span>.  Using a fully qualified
	  domain name or IP address is recommended.  The receiving
	  machine writes the data to the
	  <em class="replaceable"><code>backup</code></em> dataset on the
	  <em class="replaceable"><code>recvpool</code></em> pool.  Adding
	  <code class="option">-d</code> to <code class="command">zfs recv</code>
	  overwrites the name of the pool on the receiving side with
	  the name of the snapshot.  <code class="option">-u</code> causes the
	  file systems to not be mounted on the receiving side.  When
	  <code class="option">-v</code> is included, more detail about the
	  transfer is shown, including elapsed time and the amount of
	  data transferred.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-quota"></a>19.4.8. Dataset, User, and Group Quotas</h3></div></div></div><p><a class="link" href="zfs-term.html#zfs-term-quota">Dataset quotas</a> are
	used to restrict the amount of space that can be consumed
	by a particular dataset.
	<a class="link" href="zfs-term.html#zfs-term-refquota">Reference Quotas</a> work
	in very much the same way, but only count the space
	used by the dataset itself, excluding snapshots and child
	datasets.  Similarly,
	<a class="link" href="zfs-term.html#zfs-term-userquota">user</a> and
	<a class="link" href="zfs-term.html#zfs-term-groupquota">group</a> quotas can be
	used to prevent users or groups from using all of the
	space in the pool or dataset.</p><p>The following examples assume that the users already
	exist in the system.  Before adding a user to the system,
	make sure to create their home dataset first and set the
	<code class="option">mountpoint</code> to
	<code class="literal">/home/<em class="replaceable"><code>bob</code></em></code>.
	Then, create the user and make the home directory point to
	the dataset's <code class="option">mountpoint</code> location.  This will
	properly set owner and group permissions without shadowing any
	pre-existing home directory paths that might exist.</p><p>To enforce a dataset quota of 10 GB for
	<code class="filename">storage/home/bob</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set quota=10G storage/home/bob</code></strong></pre><p>To enforce a reference quota of 10 GB for
	<code class="filename">storage/home/bob</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set refquota=10G storage/home/bob</code></strong></pre><p>To remove a quota of 10 GB for
	<code class="filename">storage/home/bob</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set quota=none storage/home/bob</code></strong></pre><p>The general format is
	<code class="literal">userquota@<em class="replaceable"><code>user</code></em>=<em class="replaceable"><code>size</code></em></code>,
	and the user's name must be in one of these formats:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><acronym class="acronym">POSIX</acronym> compatible name such as
	    <em class="replaceable"><code>joe</code></em>.</p></li><li class="listitem"><p><acronym class="acronym">POSIX</acronym> numeric ID such as
	    <em class="replaceable"><code>789</code></em>.</p></li><li class="listitem"><p><acronym class="acronym">SID</acronym> name
	    such as
	    <em class="replaceable"><code>joe.bloggs@example.com</code></em>.</p></li><li class="listitem"><p><acronym class="acronym">SID</acronym>
	    numeric ID such as
	    <em class="replaceable"><code>S-1-123-456-789</code></em>.</p></li></ul></div><p>For example, to enforce a user quota of 50 GB for the
	user named <em class="replaceable"><code>joe</code></em>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set userquota@joe=50G</code></strong></pre><p>To remove any quota:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set userquota@joe=none</code></strong></pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">User quota properties are not displayed by
	  <code class="command">zfs get all</code>.
	  Non-<code class="systemitem">root</code> users can
	  only see their own quotas unless they have been granted the
	  <code class="literal">userquota</code> privilege.  Users with this
	  privilege are able to view and set everyone's quota.</p></div><p>The general format for setting a group quota is:
	<code class="literal">groupquota@<em class="replaceable"><code>group</code></em>=<em class="replaceable"><code>size</code></em></code>.</p><p>To set the quota for the group
	<em class="replaceable"><code>firstgroup</code></em> to 50 GB,
	use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set groupquota@firstgroup=50G</code></strong></pre><p>To remove the quota for the group
	<em class="replaceable"><code>firstgroup</code></em>, or to make sure that
	one is not set, instead use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set groupquota@firstgroup=none</code></strong></pre><p>As with the user quota property,
	non-<code class="systemitem">root</code> users can
	only see the quotas associated with the groups to which they
	belong.  However,
	<code class="systemitem">root</code> or a user with
	the <code class="literal">groupquota</code> privilege can view and set
	all quotas for all groups.</p><p>To display the amount of space used by each user on
	a file system or snapshot along with any quotas, use
	<code class="command">zfs userspace</code>.  For group information, use
	<code class="command">zfs groupspace</code>.  For more information about
	supported options or how to display only specific options,
	refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">zfs</span>(1)</span></a>.</p><p>Users with sufficient privileges, and
	<code class="systemitem">root</code>, can list the
	quota for <code class="filename">storage/home/bob</code> using:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get quota storage/home/bob</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-reservation"></a>19.4.9. Reservations</h3></div></div></div><p><a class="link" href="zfs-term.html#zfs-term-reservation">Reservations</a>
	guarantee a minimum amount of space will always be available
	on a dataset.  The reserved space will not be available to any
	other dataset.  This feature can be especially useful to
	ensure that free space is available for an important dataset
	or log files.</p><p>The general format of the <code class="literal">reservation</code>
	property is
	<code class="literal">reservation=<em class="replaceable"><code>size</code></em></code>,
	so to set a reservation of 10 GB on
	<code class="filename">storage/home/bob</code>, use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set reservation=10G storage/home/bob</code></strong></pre><p>To clear any reservation:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set reservation=none storage/home/bob</code></strong></pre><p>The same principle can be applied to the
	<code class="literal">refreservation</code> property for setting a
	<a class="link" href="zfs-term.html#zfs-term-refreservation">Reference
	  Reservation</a>, with the general format
	<code class="literal">refreservation=<em class="replaceable"><code>size</code></em></code>.</p><p>This command shows any reservations or refreservations
	that exist on <code class="filename">storage/home/bob</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get reservation storage/home/bob</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>zfs get refreservation storage/home/bob</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-compression"></a>19.4.10. Compression</h3></div></div></div><p><acronym class="acronym">ZFS</acronym> provides transparent compression.
	Compressing data at the block level as it is written not only
	saves space, but can also increase disk throughput.  If data
	is compressed by 25%, but the compressed data is written to
	the disk at the same rate as the uncompressed version,
	resulting in an effective write speed of 125%.  Compression
	can also be a great alternative to
	<a class="link" href="zfs-zfs.html#zfs-zfs-deduplication" title="19.4.11. Deduplication">Deduplication</a>
	because it does not require additional memory.</p><p><acronym class="acronym">ZFS</acronym> offers several different
	compression algorithms, each with different trade-offs.  With
	the introduction of <acronym class="acronym">LZ4</acronym> compression in
	<acronym class="acronym">ZFS</acronym> v5000, it is possible to enable
	compression for the entire pool without the large performance
	trade-off of other algorithms.  The biggest advantage to
	<acronym class="acronym">LZ4</acronym> is the <span class="emphasis"><em>early abort</em></span>
	feature.  If <acronym class="acronym">LZ4</acronym> does not achieve at least
	12.5% compression in the first part of the data, the block is
	written uncompressed to avoid wasting CPU cycles trying to
	compress data that is either already compressed or
	uncompressible.  For details about the different compression
	algorithms available in <acronym class="acronym">ZFS</acronym>, see the
	<a class="link" href="zfs-term.html#zfs-term-compression">Compression</a> entry
	in the terminology section.</p><p>The administrator can monitor the effectiveness of
	compression using a number of dataset properties.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs get used,compressratio,compression,logicalused <em class="replaceable"><code>mypool/compressed_dataset</code></em></code></strong>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       local
mypool/compressed_dataset  logicalused       496G      -</pre><p>The dataset is currently using 449 GB of space (the
	used property).  Without compression, it would have taken
	496 GB of space (the <code class="literal">logicalused</code>
	property).  This results in the 1.11:1 compression
	ratio.</p><p>Compression can have an unexpected side effect when
	combined with
	<a class="link" href="zfs-term.html#zfs-term-userquota">User Quotas</a>.
	User quotas restrict how much space a user can consume on a
	dataset, but the measurements are based on how much space is
	used <span class="emphasis"><em>after compression</em></span>.  So if a user has
	a quota of 10 GB, and writes 10 GB of compressible
	data, they will still be able to store additional data.  If
	they later update a file, say a database, with more or less
	compressible data, the amount of space available to them will
	change.  This can result in the odd situation where a user did
	not increase the actual amount of data (the
	<code class="literal">logicalused</code> property), but the change in
	compression caused them to reach their quota limit.</p><p>Compression can have a similar unexpected interaction with
	backups.  Quotas are often used to limit how much data can be
	stored to ensure there is sufficient backup space available.
	However since quotas do not consider compression, more data
	may be written than would fit with uncompressed
	backups.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-deduplication"></a>19.4.11. Deduplication</h3></div></div></div><p>When enabled,
	<a class="link" href="zfs-term.html#zfs-term-deduplication">deduplication</a>
	uses the checksum of each block to detect duplicate blocks.
	When a new block is a duplicate of an existing block,
	<acronym class="acronym">ZFS</acronym> writes an additional reference to the
	existing data instead of the whole duplicate block.
	Tremendous space savings are possible if the data contains
	many duplicated files or repeated information.  Be warned:
	deduplication requires an extremely large amount of memory,
	and most of the space savings can be had without the extra
	cost by enabling compression instead.</p><p>To activate deduplication, set the
	<code class="literal">dedup</code> property on the target pool:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zfs set dedup=on <em class="replaceable"><code>pool</code></em></code></strong></pre><p>Only new data being written to the pool will be
	deduplicated.  Data that has already been written to the pool
	will not be deduplicated merely by activating this option.  A
	pool with a freshly activated deduplication property will look
	like this example:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -</pre><p>The <code class="literal">DEDUP</code> column shows the actual rate
	of deduplication for the pool.  A value of
	<code class="literal">1.00x</code> shows that data has not been
	deduplicated yet.  In the next example, the ports tree is
	copied three times into different directories on the
	deduplicated pool created above.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>for d in dir1 dir2 dir3; do</code></strong>
&gt; <strong class="userinput"><code>mkdir $d &amp;&amp; cp -R /usr/ports $d &amp;</code></strong>
&gt; <strong class="userinput"><code>done</code></strong></pre><p>Redundant data is detected and deduplicated:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zpool list</code></strong>
NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -</pre><p>The <code class="literal">DEDUP</code> column shows a factor of
	<code class="literal">3.00x</code>.  Multiple copies of the ports tree
	data was detected and deduplicated, using only a third of the
	space.  The potential for space savings can be enormous, but
	comes at the cost of having enough memory to keep track of the
	deduplicated blocks.</p><p>Deduplication is not always beneficial, especially when
	the data on a pool is not redundant.
	<acronym class="acronym">ZFS</acronym> can show potential space savings by
	simulating deduplication on an existing pool:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>zdb -S <em class="replaceable"><code>pool</code></em></code></strong>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
------   ------   -----   -----   -----   ------   -----   -----   -----
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup = 1.05, compress = 1.11, copies = 1.00, dedup * compress / copies = 1.16</pre><p>After <code class="command">zdb -S</code> finishes analyzing the
	pool, it shows the space reduction ratio that would be
	achieved by activating deduplication.  In this case,
	<code class="literal">1.16</code> is a very poor space saving ratio that
	is mostly provided by compression.  Activating deduplication
	on this pool would not save any significant amount of space,
	and is not worth the amount of memory required to enable
	deduplication.  Using the formula
	<span class="emphasis"><em>ratio = dedup * compress / copies</em></span>,
	system administrators can plan the storage allocation,
	deciding whether the workload will contain enough duplicate
	blocks to justify the memory requirements.  If the data is
	reasonably compressible, the space savings may be very good.
	Enabling compression first is recommended, and compression can
	also provide greatly increased performance.  Only enable
	deduplication in cases where the additional savings will be
	considerable and there is sufficient memory for the <a class="link" href="zfs-term.html#zfs-term-deduplication"><acronym class="acronym">DDT</acronym></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="zfs-zfs-jail"></a>19.4.12. <acronym class="acronym">ZFS</acronym> and Jails</h3></div></div></div><p><code class="command">zfs jail</code> and the corresponding
	<code class="literal">jailed</code> property are used to delegate a
	<acronym class="acronym">ZFS</acronym> dataset to a
	<a class="link" href="jails.html" title="Chapter 14. Jails">Jail</a>.
	<code class="command">zfs jail <em class="replaceable"><code>jailid</code></em></code>
	attaches a dataset to the specified jail, and
	<code class="command">zfs unjail</code> detaches it.  For the dataset to
	be controlled from within a jail, the
	<code class="literal">jailed</code> property must be set.  Once a
	dataset is jailed, it can no longer be mounted on the
	host because it may have mount points that would compromise
	the security of the host.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="zfs-zpool.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="zfs.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="zfs-zfs-allow.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">19.3. <code class="command">zpool</code> Administration </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 19.5. Delegated Administration</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>