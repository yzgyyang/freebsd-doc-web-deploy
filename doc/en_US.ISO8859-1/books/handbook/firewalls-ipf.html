<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>30.5. IPFILTER (IPF)</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeBSD Handbook" /><link rel="up" href="firewalls.html" title="Chapter 30. Firewalls" /><link rel="prev" href="firewalls-ipfw.html" title="30.4. IPFW" /><link rel="next" href="firewalls-blacklistd.html" title="30.6. Blacklistd" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">30.5. IPFILTER (IPF)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="firewalls-ipfw.html">Prev</a> </td><th width="60%" align="center">Chapter 30. Firewalls</th><td width="20%" align="right"> <a accesskey="n" href="firewalls-blacklistd.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="firewalls-ipf"></a>30.5. IPFILTER (IPF)</h2></div></div></div><a id="idp72340216" class="indexterm"></a><p><span class="application">IPFILTER</span>, also known as
      <span class="application">IPF</span>, is a cross-platform, open source
      firewall which has been ported to several operating systems,
      including FreeBSD, NetBSD, OpenBSD, and <span class="trademark">Solaris</span>&#8482;.</p><p><span class="application">IPFILTER</span> is a kernel-side
      firewall and <acronym class="acronym">NAT</acronym> mechanism that can be
      controlled and monitored by userland programs.  Firewall rules
      can be set or deleted using <span class="application">ipf</span>,
      <acronym class="acronym">NAT</acronym> rules can be set or deleted using
      <span class="application">ipnat</span>, run-time statistics for the
      kernel parts of <span class="application">IPFILTER</span> can be
      printed using <span class="application">ipfstat</span>, and
      <span class="application">ipmon</span> can be used to log
      <span class="application">IPFILTER</span> actions to the system log
      files.</p><p><span class="application">IPF</span> was originally written using
      a rule processing logic of <span class="quote">&#8220;<span class="quote">the last matching rule
	wins</span>&#8221;</span> and only used stateless rules.  Since then,
      <span class="application">IPF</span> has been enhanced to include the
      <code class="literal">quick</code> and <code class="literal">keep state</code>
      options.</p><p>The <span class="application">IPF</span> FAQ is at <code class="uri"><a class="uri" href="http://www.phildev.net/ipf/index.html" target="_top">http://www.phildev.net/ipf/index.html</a></code>.
      A searchable archive of the IPFilter mailing list is available
      at <code class="uri"><a class="uri" href="http://marc.info/?l=ipfilter" target="_top">http://marc.info/?l=ipfilter</a></code>.</p><p>This section of the Handbook focuses on
      <span class="application">IPF</span> as it pertains to FreeBSD.  It
      provides examples of rules that contain the
      <code class="literal">quick</code> and <code class="literal">keep state</code>
      options.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72364536"></a>30.5.1. Enabling <span class="application">IPF</span></h3></div></div></div><a id="idp72365432" class="indexterm"></a><p><span class="application">IPF</span> is included in the basic
	FreeBSD install as a kernel loadable module, meaning that a
	custom kernel is not needed in order to enable
	<span class="application">IPF</span>.</p><a id="idp72367736" class="indexterm"></a><a id="idp72369016" class="indexterm"></a><a id="idp72370168" class="indexterm"></a><a id="idp72371320" class="indexterm"></a><p>For users who prefer to statically compile
	<span class="application">IPF</span> support into a custom kernel,
	refer to the instructions in <a class="xref" href="kernelconfig.html" title="Chapter 8. Configuring the FreeBSD Kernel">Chapter 8, <em>Configuring the FreeBSD Kernel</em></a>.
	The following kernel options are available:</p><pre class="programlisting">options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre><p>where <code class="literal">options IPFILTER</code> enables support
	for <span class="application">IPFILTER</span>,
	<code class="literal">options IPFILTER_LOG</code> enables
	<span class="application">IPF</span> logging using the
	<code class="filename">ipl</code> packet logging pseudo-device for
	every rule that has the <code class="literal">log</code> keyword,
	<code class="literal">IPFILTER_LOOKUP</code> enables
	<acronym class="acronym">IP</acronym> pools in order to speed up
	<acronym class="acronym">IP</acronym> lookups, and <code class="literal">options
	  IPFILTER_DEFAULT_BLOCK</code> changes the default
	behavior so that any packet not matching a firewall
	<code class="literal">pass</code> rule gets blocked.</p><p>To configure the system to enable
	<span class="application">IPF</span> at boot time, add the following
	entries to <code class="filename">/etc/rc.conf</code>.  These entries
	will also enable logging and <code class="literal">default pass
	  all</code>.  To change the default policy to
	<code class="literal">block all</code> without  compiling a custom
	kernel, remember to add a <code class="literal">block all</code> rule at
	the end of the ruleset.</p><pre class="programlisting">ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipv6_ipfilter_rules="/etc/ipf6.rules" # loads rules definition text file for IPv6
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre><p>If <acronym class="acronym">NAT</acronym> functionality is needed, also
	add these lines:</p><pre class="programlisting">gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</pre><p>Then, to start <span class="application">IPF</span> now:</p><pre class="programlisting"><code class="prompt">#</code> <strong class="userinput"><code>service ipfilter start</code></strong></pre><p>To load the firewall rules, specify the name of the
	ruleset file using <code class="command">ipf</code>.  The following
	command can be used to replace the currently running firewall
	rules:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipf -Fa -f /etc/ipf.rules</code></strong></pre><p>where <code class="option">-Fa</code> flushes all the internal rules
	tables and <code class="option">-f</code> specifies the file containing
	the rules to load.</p><p>This provides the ability to make changes to a custom
	ruleset and update the running firewall with a fresh copy of
	the rules without having to reboot the system.  This method is
	convenient for testing new rules as the procedure can be
	executed as many times as needed.</p><p>Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(8)</span></a> for details on the other flags
	available with this command.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72396920"></a>30.5.2. <span class="application">IPF</span> Rule Syntax</h3></div></div></div><a id="idp72397816" class="indexterm"></a><p>This section describes the <span class="application">IPF</span>
	rule syntax used to create stateful rules.  When creating
	rules, keep in mind that unless the <code class="literal">quick</code>
	keyword appears in a rule, every rule is read in order, with
	the <span class="emphasis"><em>last  matching rule</em></span> being the one
	that is applied.  This means that even if the first rule to
	match a packet is a <code class="literal">pass</code>, if there is a
	later matching rule that is a <code class="literal">block</code>, the
	packet will be dropped.  Sample rulesets can be found in
	<code class="filename">/usr/share/examples/ipfilter</code>.</p><p>When creating rules, a <code class="literal">#</code> character is
	used to mark the start of a comment and may appear at the end
	of a rule, to explain that rule's function, or on its own
	line.  Any blank lines are ignored.</p><p>The keywords which are used in rules must be written in a
	specific order, from left to right.  Some keywords are
	mandatory while others are optional.  Some keywords have
	sub-options which may be keywords themselves and also include
	more sub-options.  The keyword order is as follows, where the
	words shown in uppercase represent a variable and the words
	shown in lowercase must precede the variable that follows
	it:</p><p><em class="replaceable"><code>ACTION DIRECTION OPTIONS proto PROTO_TYPE
	  from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT
	  TCP_FLAG|ICMP_TYPE keep state STATE</code></em></p><p>This section describes each of these keywords and their
	options.  It is not an exhaustive list of every possible
	option.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a> for a complete description of
	the rule syntax that can be used when creating
	<span class="application">IPF</span> rules and examples for using
	each keyword.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ACTION</span></dt><dd><p>The action keyword indicates what to do with the
	      packet if it matches that rule.  Every rule
	      <span class="emphasis"><em>must</em></span> have an action.  The
	      following actions are recognized:</p><p><code class="literal">block</code>: drops the packet.</p><p><code class="literal">pass</code>: allows the packet.</p><p><code class="literal">log</code>: generates a log
	      record.</p><p><code class="literal">count</code>: counts the number of
	      packets and bytes which can provide an indication of
	      how often a rule is used.</p><p><code class="literal">auth</code>: queues the packet for
	      further processing by another program.</p><p><code class="literal">call</code>: provides access to
	      functions built into <span class="application">IPF</span> that
	      allow more complex actions.</p><p><code class="literal">decapsulate</code>: removes any headers
	      in order to process the contents of the packet.</p></dd><dt><span class="term">DIRECTION</span></dt><dd><p>Next, each rule must explicitly state the direction
	      of traffic using one of these keywords:</p><p><code class="literal">in</code>: the rule is applied against
	      an inbound packet.</p><p><code class="literal">out</code>: the rule is applied against
	      an outbound packet.</p><p><code class="literal">all</code>: the rule applies to either
	      direction.</p><p>If the system has multiple interfaces, the interface
	      can be specified along with the direction.  An example
	      would be <code class="literal">in on fxp0</code>.</p></dd><dt><span class="term">OPTIONS</span></dt><dd><p>Options are optional.  However, if multiple options
	      are specified, they must be used in the order shown
	      here.</p><p><code class="literal">log</code>: when performing the
	      specified ACTION, the contents of the packet's headers
	      will be written to the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipl</span>(4)</span></a> packet log
	      pseudo-device.</p><p><code class="literal">quick</code>: if a packet matches this
	      rule, the ACTION specified by the rule occurs and no
	      further processing of any following rules will occur for
	      this packet.</p><p><code class="literal">on</code>: must be followed by the
	      interface name as displayed by <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>.  The
	      rule will only match if the packet is going through the
	      specified interface in the specified direction.</p><p>When using the
	      <code class="literal">log</code> keyword, the following qualifiers
	      may be used in this order:</p><p><code class="literal">body</code>: indicates that the first
	      128 bytes of the packet contents will be logged after
	      the headers.</p><p><code class="literal">first</code>:  if the
	      <code class="literal">log</code> keyword is being used in
	      conjunction with a <code class="literal">keep state</code> option,
	      this option is recommended so that only the triggering
	      packet is logged and not every packet which matches the
	      stateful connection.</p><p>Additional options are available to specify error
	      return messages.  Refer to  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a> for more
	      details.</p></dd><dt><span class="term">PROTO_TYPE</span></dt><dd><p>The protocol type is optional.  However, it is
	      mandatory if the rule needs to specify a SRC_PORT or
	      a DST_PORT as it defines the type of protocol.  When
	      specifying the type of protocol, use the
	      <code class="literal">proto</code> keyword followed by either a
	      protocol number or name from
	      <code class="filename">/etc/protocols</code>.
	      Example protocol names include <code class="literal">tcp</code>,
	      <code class="literal">udp</code>, or <code class="literal">icmp</code>.  If
	      PROTO_TYPE is specified but no SRC_PORT or DST_PORT is
	      specified, all port numbers for that protocol will match
	      that rule.</p></dd><dt><span class="term">SRC_ADDR</span></dt><dd><p>The <code class="literal">from</code> keyword is mandatory and
	      is followed by a keyword which represents the source of
	      the packet.  The source can be a hostname, an
	      <acronym class="acronym">IP</acronym> address followed by the
	      <acronym class="acronym">CIDR</acronym> mask, an address pool, or the
	      keyword <code class="literal">all</code>.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a>
	      for examples.</p><p>There is no way to match ranges of
	      <acronym class="acronym">IP</acronym> addresses which do not express
	      themselves easily using the dotted numeric form /
	      mask-length notation.  The
	      <a xmlns="" class="package" href="https://www.freebsd.org/cgi/url.cgi?ports/net-mgmt/ipcalc/pkg-descr">net-mgmt/ipcalc</a> package or port may
	      be used to ease the calculation of the
	      <acronym class="acronym">CIDR</acronym> mask.  Additional information is
	      available at the utility's web page: <code class="uri"><a class="uri" href="http://jodies.de/ipcalc" target="_top">http://jodies.de/ipcalc</a></code>.</p></dd><dt><span class="term">SRC_PORT</span></dt><dd><p>The port number of the source is optional.  However,
	      if it is used, it requires PROTO_TYPE to be first
	      defined in the rule.  The port number must also be
	      preceded by the <code class="literal">proto</code> keyword.</p><p>A number of different comparison operators are
	      supported: <code class="literal">=</code> (equal to),
	      <code class="literal">!=</code> (not equal to),
	      <code class="literal">&lt;</code> (less than),
	      <code class="literal">&gt;</code> (greater than),
	      <code class="literal">&lt;=</code> (less than or equal to), and
	      <code class="literal">&gt;=</code> (greater than or equal
	      to).</p><p>To specify port ranges, place the two port numbers
	      between <code class="literal">&lt;&gt;</code> (less than and
	      greater than ), <code class="literal">&gt;&lt;</code> (greater
	      than and less than ), or <code class="literal">:</code> (greater
	      than or equal to and less than or equal to).</p></dd><dt><span class="term">DST_ADDR</span></dt><dd><p>The <code class="literal">to</code> keyword is mandatory and
	      is followed by a keyword which represents the
	      destination of the packet.  Similar to SRC_ADDR, it can
	      be a hostname, an  <acronym class="acronym">IP</acronym> address
	      followed by the <acronym class="acronym">CIDR</acronym> mask, an address
	      pool, or the keyword <code class="literal">all</code>.</p></dd><dt><span class="term">DST_PORT</span></dt><dd><p>Similar to SRC_PORT, the port number of the
	      destination is optional.  However, if it is used, it
	      requires PROTO_TYPE to be first defined in the rule.
	      The port number must also be preceded by the
	      <code class="literal">proto</code> keyword.</p></dd><dt><span class="term">TCP_FLAG|ICMP_TYPE</span></dt><dd><p>If <code class="literal">tcp</code> is specified as the
	      PROTO_TYPE, flags can be specified as letters, where
	      each letter represents one of the possible
	      <acronym class="acronym">TCP</acronym> flags used to determine the state
	      of a connection.  Possible values are:
	      <code class="literal">S</code> (SYN),
	      <code class="literal">A</code> (ACK),
	      <code class="literal">P</code> (PSH),
	      <code class="literal">F</code> (FIN),
	      <code class="literal">U</code> (URG),
	      <code class="literal">R</code> (RST),
	      <code class="literal">C</code> (CWN), and
	      <code class="literal">E</code> (ECN).</p><p>If <code class="literal">icmp</code> is specified as the
	      PROTO_TYPE, the <acronym class="acronym">ICMP</acronym> type to match
	      can be specified.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a> for the
	      allowable types.</p></dd><dt><span class="term">STATE</span></dt><dd><p>If a <code class="literal">pass</code> rule contains
	      <code class="literal">keep state</code>,
	      <span class="application">IPF</span> will add an entry to its
	      dynamic state table and allow subsequent packets that
	      match the connection.
	      <span class="application">IPF</span> can track state for
	      <acronym class="acronym">TCP</acronym>, <acronym class="acronym">UDP</acronym>, and
	      <acronym class="acronym">ICMP</acronym> sessions.  Any packet that
	      <span class="application">IPF</span> can be certain is part of
	      an active session, even if it is a different protocol,
	      will be allowed.</p><p>In <span class="application">IPF</span>, packets destined
	      to go out through the interface connected to the public
	      Internet are first checked against the dynamic state
	      table.  If the packet matches the next expected packet
	      comprising an active session conversation, it exits the
	      firewall and the state of the session conversation flow
	      is updated in the dynamic state table.  Packets that do
	      not belong to an already active session are checked
	      against the outbound ruleset.  Packets coming in from
	      the interface connected to the public Internet are first
	      checked against the dynamic state table.  If the packet
	      matches the next expected packet comprising an active
	      session, it exits the firewall and the state of the
	      session conversation flow is updated in the dynamic
	      state table.  Packets that do not belong to an already
	      active session are checked against the inbound
	      ruleset.</p><p>Several keywords can be added after
	      <code class="literal">keep state</code>.  If used, these keywords
	      set various options that control stateful filtering,
	      such as setting connection limits or connection age.
	      Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a> for the list of available options
	      and their descriptions.</p></dd></dl></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72485624"></a>30.5.3. Example Ruleset</h3></div></div></div><p>This section demonstrates how to create an example ruleset
	which only allows services matching
	<code class="literal">pass</code> rules and blocks all others.</p><p>FreeBSD uses the loopback interface
	(<code class="filename">lo0</code>) and the <acronym class="acronym">IP</acronym>
	address <code class="systemitem">127.0.0.1</code>
	for internal communication.  The firewall ruleset must contain
	rules to allow free movement of these internally used
	packets:</p><pre class="programlisting"># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre><p>The public interface connected to the Internet is used to
	authorize and control access of all outbound and inbound
	connections.  If one or more interfaces are cabled to private
	networks, those internal interfaces may require rules to allow
	packets originating from the <acronym class="acronym">LAN</acronym> to flow
	between the internal networks or to the interface attached to
	the Internet.  The ruleset should be organized into three
	major sections: any trusted internal interfaces, outbound
	connections through the public interface, and inbound
	connections through the public interface.</p><p>These two rules allow all traffic to pass through a
	trusted <acronym class="acronym">LAN</acronym> interface named
	<code class="filename">xl0</code>:</p><pre class="programlisting"># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre><p>The rules for the public interface's outbound and inbound
	sections should have the most frequently matched rules placed
	before less commonly matched rules, with the last rule in the
	section blocking and logging all packets for that interface
	and direction.</p><p>This set of rules defines the outbound section of the
	public interface named <code class="filename">dc0</code>.  These rules
	keep state and identify the specific services that internal
	systems are authorized for public Internet access.  All the
	rules use <code class="literal">quick</code> and specify the
	appropriate port numbers and, where applicable, destination
	addresses.</p><pre class="programlisting"># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP's specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre><p>This example of the rules in the inbound section of the
	public interface blocks all undesirable packets first.  This
	reduces the number of packets that are logged by the last
	rule.</p><pre class="programlisting"># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre><p>Any time there are logged messages on a rule with
	the <code class="literal">log first</code> option, run
	<code class="command">ipfstat -hio</code> to evaluate how many times the
	rule has been matched.  A large number of matches may indicate
	that the system is under attack.</p><p>The rest of the rules in the inbound section define which
	connections are allowed to be initiated from the Internet.
	The last rule denies all connections which were not explicitly
	allowed by previous rules in this section.</p><pre class="programlisting"># Allow traffic in from ISP's DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72520824"></a>30.5.4. Configuring <acronym class="acronym">NAT</acronym></h3></div></div></div><a id="idp72521720" class="indexterm"></a><a id="idp72522232" class="indexterm"></a><a id="idp72531576" class="indexterm"></a><a id="idp72532728" class="indexterm"></a><p>To enable <acronym class="acronym">NAT</acronym>, add these statements
	to <code class="filename">/etc/rc.conf</code> and specify the name of
	the file containing the <acronym class="acronym">NAT</acronym> rules:</p><pre class="programlisting">gateway_enable="YES"
ipnat_enable="YES"
ipnat_rules="/etc/ipnat.rules"</pre><p><acronym class="acronym">NAT</acronym> rules are flexible and can
	accomplish many different things to fit the needs of both
	commercial and home users.  The rule syntax presented here has
	been simplified to demonstrate common usage.  For a complete
	rule syntax description, refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipnat</span>(5)</span></a>.</p><p>The basic syntax for a <acronym class="acronym">NAT</acronym> rule is as
	follows, where <code class="literal">map</code> starts the rule and
	<em class="replaceable"><code>IF</code></em> should be replaced with the
	name of the external interface:</p><pre class="programlisting">map <em class="replaceable"><code>IF</code></em> <em class="replaceable"><code>LAN_IP_RANGE</code></em> -&gt; <em class="replaceable"><code>PUBLIC_ADDRESS</code></em></pre><p>The <em class="replaceable"><code>LAN_IP_RANGE</code></em> is the range
	of <acronym class="acronym">IP</acronym> addresses used by internal clients.
	Usually, it is a private address range such as <code class="systemitem">192.168.1.0/24</code>.  The
	<em class="replaceable"><code>PUBLIC_ADDRESS</code></em> can either be the
	static external <acronym class="acronym">IP</acronym> address or the keyword
	<code class="literal">0/32</code> which represents the
	<acronym class="acronym">IP</acronym> address assigned to
	<em class="replaceable"><code>IF</code></em>.</p><p>In <span class="application">IPF</span>, when a packet arrives
	at the firewall from the <acronym class="acronym">LAN</acronym> with a public
	destination, it first passes through the outbound rules of the
	firewall ruleset.  Then, the packet is passed to the
	<acronym class="acronym">NAT</acronym> ruleset which is read from the top
	down, where the first matching rule wins.
	<span class="application">IPF</span> tests each
	<acronym class="acronym">NAT</acronym> rule against the packet's interface
	name and source <acronym class="acronym">IP</acronym> address.  When a
	packet's interface name matches a <acronym class="acronym">NAT</acronym> rule,
	the packet's source <acronym class="acronym">IP</acronym> address in the
	private <acronym class="acronym">LAN</acronym> is checked to see if it falls
	within the <acronym class="acronym">IP</acronym> address range specified in
	<em class="replaceable"><code>LAN_IP_RANGE</code></em>.  On a match, the
	packet has its source <acronym class="acronym">IP</acronym> address rewritten
	with the public <acronym class="acronym">IP</acronym> address specified by
	<em class="replaceable"><code>PUBLIC_ADDRESS</code></em>.
	<span class="application">IPF</span> posts an entry in its internal
	<acronym class="acronym">NAT</acronym> table so that when the packet returns
	from the Internet, it can be mapped back to its original
	private <acronym class="acronym">IP</acronym> address before being passed to
	the firewall rules for further processing.</p><p>For networks that have large numbers of internal systems
	or multiple subnets, the process of funneling every private
	<acronym class="acronym">IP</acronym> address into a single public
	<acronym class="acronym">IP</acronym> address becomes a resource problem.
	Two methods are available to relieve this issue.</p><p>The first method is to assign a range of ports to use as
	source ports.  By adding the <code class="literal">portmap</code>
	keyword, <acronym class="acronym">NAT</acronym> can be directed to only use
	source ports in the specified range:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre><p>Alternately, use the <code class="literal">auto</code> keyword
	which tells <acronym class="acronym">NAT</acronym> to determine the ports
	that are available for use:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre><p>The second method is to use a pool of public addresses.
	This is useful when there are too many
	<acronym class="acronym">LAN</acronym> addresses to fit into a single public
	address and a block of public <acronym class="acronym">IP</acronym> addresses
	is available.  These public addresses can be used as a pool
	from which <acronym class="acronym">NAT</acronym> selects an
	<acronym class="acronym">IP</acronym> address as a packet's address is
	mapped on its way out.</p><p>The range of public <acronym class="acronym">IP</acronym> addresses can
	be specified using a netmask or <acronym class="acronym">CIDR</acronym>
	notation.  These two rules are equivalent:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre><p>A common practice is to have a publically accessible web
	server or mail server segregated to an internal network
	segment.  The traffic from these servers still has to undergo
	<acronym class="acronym">NAT</acronym>, but port redirection is needed to
	direct inbound traffic to the correct server.  For example, to
	map a web server using the internal address <code class="systemitem">10.0.10.25</code> to its public
	<acronym class="acronym">IP</acronym> address of <code class="systemitem">20.20.20.5</code>, use this
	rule:</p><pre class="programlisting">rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre><p>If it is the only web server, this rule would also work as
	it redirects all external <acronym class="acronym">HTTP</acronym> requests to
	<code class="literal">10.0.10.25</code>:</p><pre class="programlisting">rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre><p><span class="application">IPF</span> has a built in
	<acronym class="acronym">FTP</acronym> proxy which can be used with
	<acronym class="acronym">NAT</acronym>.  It monitors all outbound traffic for
	active or passive <acronym class="acronym">FTP</acronym> connection requests
	and dynamically creates temporary filter rules containing the
	port number used by the <acronym class="acronym">FTP</acronym> data channel.
	This eliminates the need to open large ranges of high order
	ports for <acronym class="acronym">FTP</acronym> connections.</p><p>In this example, the first rule calls the proxy for
	outbound <acronym class="acronym">FTP</acronym> traffic from the internal
	<acronym class="acronym">LAN</acronym>.  The second rule passes the
	<acronym class="acronym">FTP</acronym> traffic from the firewall to the
	Internet, and the third rule handles all
	non-<acronym class="acronym">FTP</acronym> traffic from the internal
	<acronym class="acronym">LAN</acronym>:</p><pre class="programlisting">map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre><p>The <acronym class="acronym">FTP</acronym> <code class="literal">map</code> rules go
	before the <acronym class="acronym">NAT</acronym> rule so that when a packet
	matches an <acronym class="acronym">FTP</acronym> rule, the
	<acronym class="acronym">FTP</acronym> proxy creates temporary filter rules to
	let the <acronym class="acronym">FTP</acronym> session packets pass and
	undergo <acronym class="acronym">NAT</acronym>.  All LAN packets that are not
	<acronym class="acronym">FTP</acronym> will not match the
	<acronym class="acronym">FTP</acronym> rules but will undergo
	<acronym class="acronym">NAT</acronym> if they match the third rule.</p><p>Without the <acronym class="acronym">FTP</acronym> proxy, the following
	firewall rules would instead be needed.  Note that without the
	proxy, all ports above <code class="literal">1024</code> need to be
	allowed:</p><pre class="programlisting"># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre><p>Whenever the file containing the <acronym class="acronym">NAT</acronym>
	rules is edited, run <code class="command">ipnat</code> with
	<code class="option">-CF</code> to delete the current
	<acronym class="acronym">NAT</acronym> rules and flush the contents of the
	dynamic translation table.  Include <code class="option">-f</code> and
	specify the name of the <acronym class="acronym">NAT</acronym> ruleset to
	load:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -CF -f /etc/ipnat.rules</code></strong></pre><p>To display the <acronym class="acronym">NAT</acronym> statistics:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -s</code></strong></pre><p>To list the <acronym class="acronym">NAT</acronym> table's current
	mappings:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -l</code></strong></pre><p>To turn verbose mode on and display information relating
	to rule processing and active rules and table entries:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -v</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72188536"></a>30.5.5. Viewing <span class="application">IPF</span> Statistics</h3></div></div></div><a id="idp72189560" class="indexterm"></a><a id="idp72190200" class="indexterm"></a><p><span class="application">IPF</span> includes <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a>
	which can be used to retrieve
	and display statistics which are gathered
	as packets match rules as they go through the
	firewall.  Statistics are accumulated since the firewall was
	last started or since the last time they
	were reset to zero using <code class="command">ipf
	  -Z</code>.</p><p>The default <code class="command">ipfstat</code> output looks
	like this:</p><pre class="screen">input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP cksum fails(in): 0 (out): 0
 Packet log flags set: (0)</pre><p>Several options are available.  When supplied with either
	<code class="option">-i</code> for inbound or <code class="option">-o</code> for
	outbound, the command will retrieve and display the
	appropriate list of filter rules currently installed and in
	use by the kernel.  To also see the rule numbers, include
	<code class="option">-n</code>.  For example, <code class="command">ipfstat
	  -on</code> displays the outbound rules table with rule
	numbers:</p><pre class="screen">@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</pre><p>Include <code class="option">-h</code> to prefix each rule with a
	count of how many times the rule was matched.  For example,
	<code class="command">ipfstat -oh</code> displays the outbound internal
	rules table, prefixing each rule with its usage count:</p><pre class="screen">2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</pre><p>To display the state table in a format similar to
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>, use <code class="command">ipfstat -t</code>.  When the
	firewall is under attack, this option provides the ability to
	identify and see the attacking packets.  The optional
	sub-flags give the ability to select the destination or source
	<acronym class="acronym">IP</acronym>, port, or protocol to be monitored in
	real time.  Refer to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> for details.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp72631160"></a>30.5.6. <span class="application">IPF</span> Logging</h3></div></div></div><a id="idp72632056" class="indexterm"></a><a id="idp72632696" class="indexterm"></a><p><span class="application">IPF</span> provides
	<code class="command">ipmon</code>, which can be used to write the
	firewall's logging information in a human readable format.  It
	requires that <code class="literal">options IPFILTER_LOG</code> be first
	added to a custom kernel using the instructions in <a class="xref" href="kernelconfig.html" title="Chapter 8. Configuring the FreeBSD Kernel">Chapter 8, <em>Configuring the FreeBSD Kernel</em></a>.</p><p>This command is typically run in daemon mode in order to
	provide a continuous system log file so that logging of past
	events may be reviewed.  Since FreeBSD has a built in
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">syslogd</span>(8)</span></a> facility to automatically rotate system logs,
	the default <code class="filename">rc.conf</code>
	<code class="literal">ipmon_flags</code> statement uses
	<code class="option">-Ds</code>:</p><pre class="programlisting">ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre><p>Logging provides the ability to review, after the fact,
	information such as which packets were dropped, what addresses
	they came from, and where they were going.  This information
	is useful in tracking down attackers.</p><p>Once the logging facility is enabled in
	<code class="filename">rc.conf</code> and started with <code class="command">service
	  ipmon start</code>, <span class="application">IPF</span> will
	only log the rules which contain the <code class="literal">log</code>
	keyword.  The firewall administrator decides which rules in
	the ruleset should be logged and normally only deny rules are
	logged.  It is customary to include the
	<code class="literal">log</code> keyword in the last rule in the
	ruleset.  This makes it possible to see all the packets that
	did not match any of the rules in the ruleset.</p><p>By default, <code class="command">ipmon -Ds</code> mode uses
	<code class="literal">local0</code> as the logging facility.  The
	following logging levels can be used to further segregate the
	logged data:</p><pre class="screen">LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</pre><p>In order to setup <span class="application">IPF</span> to
	log all data to <code class="filename">/var/log/ipfilter.log</code>,
	first create the empty file:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>touch /var/log/ipfilter.log</code></strong></pre><p>Then, to write all logged messages to the specified file,
	add the following statement to
	<code class="filename">/etc/syslog.conf</code>:</p><pre class="programlisting">local0.* /var/log/ipfilter.log</pre><p>To activate the changes and instruct <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">syslogd</span>(8)</span></a>
	to read the modified <code class="filename">/etc/syslog.conf</code>,
	run <code class="command">service syslogd reload</code>.</p><p>Do not forget to edit
	<code class="filename">/etc/newsyslog.conf</code> to rotate the new
	log file.</p><p>Messages generated by <code class="command">ipmon</code> consist
	of data fields separated by white space.  Fields common to
	all messages are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The date of packet receipt.</p></li><li class="listitem"><p>The time of packet receipt.  This is in the form
	    HH:MM:SS.F, for hours, minutes, seconds, and fractions
	    of a second.</p></li><li class="listitem"><p>The name of the interface that processed the
	    packet.</p></li><li class="listitem"><p>The group and rule number of the rule in the format
	    <code class="literal">@0:17</code>.</p></li><li class="listitem"><p>The action: <code class="literal">p</code> for passed,
	    <code class="literal">b</code> for blocked, <code class="literal">S</code> for
	    a short packet, <code class="literal">n</code> did not match any
	    rules, and <code class="literal">L</code> for a log rule.</p></li><li class="listitem"><p>The addresses written as three fields: the source
	    address and port separated by a comma, the -&gt; symbol,
	    and the destination address and port.  For example:
	    <code class="literal">209.53.17.22,80 -&gt;
	      198.73.220.17,1722</code>.</p></li><li class="listitem"><p><code class="literal">PR</code> followed by the protocol name
	    or number: for example, <code class="literal">PR tcp</code>.</p></li><li class="listitem"><p><code class="literal">len</code> followed by the header length
	    and total length of the packet: for example,
	    <code class="literal">len 20 40</code>.</p></li></ol></div><p>If the packet is a <acronym class="acronym">TCP</acronym> packet, there
	will be an additional field starting with a hyphen followed by
	letters corresponding to any flags that were set.  Refer to
	<a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ipf</span>(5)</span></a> for a list of letters and their flags.</p><p>If the packet is an <acronym class="acronym">ICMP</acronym> packet, there
	will be two fields at the end:  the first always being
	<span class="quote">&#8220;<span class="quote">icmp</span>&#8221;</span> and the next being the
	<acronym class="acronym">ICMP</acronym> message and sub-message type,
	separated by a slash.  For example:
	<code class="literal">icmp 3/3</code> for a port unreachable
	message.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="firewalls-ipfw.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="firewalls.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="firewalls-blacklistd.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">30.4. <span class="application">IPFW</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 30.6. Blacklistd</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>