<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>The Design and Implementation of the 4.4BSD Operating System</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="en" class="book" lang="en"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp43985528"></a>The Design and Implementation of the 4.4BSD Operating System</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Marshall</span> <span class="othername">Kirk</span> <span class="surname">McKusick</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Keith</span> <span class="surname">Bostic</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="othername">J.</span> <span class="surname">Karels</span></h3></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="othername">S.</span> <span class="surname">Quarterman</span></h3></div></div></div><div>Revision: <a href="https://svnweb.freebsd.org/changeset/doc/7736da0713"><span class="svnref">7736da0713</span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 1996 Addison-Wesley Longman, Inc</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="legalnotice"></a><p>The second chapter of the book,  <em class="citetitle">The Design and
	  Implementation of the 4.4BSD Operating System</em> is
	excerpted here with the permission of the publisher.  No part of it
	may be further reproduced or distributed without the publisher's
	express written
	<a class="link" href="mailto:peter.gordon@awl.com" target="_top">permission</a>.  The
	rest of
	<a class="link" href="http://cseng.aw.com/catalog/academic/product/0,1144,0201549794,00.html" target="_top">the
	  book</a> explores the concepts introduced in this chapter in
	incredible detail and is an excellent reference for anyone with an
	interest in BSD UNIX.  More information about this book is available
	from the publisher, with whom you can also sign up to receive news
	of <a class="link" href="mailto:curt.johnson@awl.com" target="_top">related titles</a>.
	Information about <a class="link" href="http://www.mckusick.com/courses/" target="_top">BSD
	  courses</a> is available from Kirk McKusick.</p></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">Split HTML</a>
      /
      
	  Single HTML
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="chapter"><a href="#overview">2. Design Overview of 4.4BSD</a></span></dt><dd><dl><dt><span class="sect1"><a href="#overview-facilities">2.1. 4.4BSD Facilities and the Kernel</a></span></dt><dt><span class="sect1"><a href="#overview-kernel-organization">2.2. Kernel Organization</a></span></dt><dt><span class="sect1"><a href="#overview-kernel-service">2.3. Kernel Services</a></span></dt><dt><span class="sect1"><a href="#overview-process-management">2.4. Process Management</a></span></dt><dt><span class="sect1"><a href="#overview-memory-management">2.5. Memory Management</a></span></dt><dt><span class="sect1"><a href="#overview-io-system">2.6. I/O System</a></span></dt><dt><span class="sect1"><a href="#overview-filesystem">2.7. Filesystems</a></span></dt><dt><span class="sect1"><a href="#overview-filestore">2.8. Filestores</a></span></dt><dt><span class="sect1"><a href="#overview-nfs">2.9. Network Filesystem</a></span></dt><dt><span class="sect1"><a href="#overview-terminal">2.10. Terminals</a></span></dt><dt><span class="sect1"><a href="#overview-ipc">2.11. Interprocess Communication</a></span></dt><dt><span class="sect1"><a href="#overview-network-communication">2.12. Network Communication</a></span></dt><dt><span class="sect1"><a href="#overview-network-implementation">2.13. Network Implementation</a></span></dt><dt><span class="sect1"><a href="#overview-operation">2.14. System Operation</a></span></dt><dt><span class="bibliography"><a href="#references">References</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><div class="toc-title">List of Figures</div><dl><dt>2.1. <a href="#fig-process-lifecycle">Process lifecycle</a></dt><dt>2.2. <a href="#fig-small-fs">A small filesystem</a></dt></dl></div><div class="list-of-tables"><div class="toc-title">List of Tables</div><dl><dt>2.1. <a href="#table-mach-indep">Machine-independent software in the 4.4BSD kernel</a></dt><dt>2.2. <a href="#table-mach-dep">Machine-dependent software for the HP300 in the 4.4BSD
	  kernel</a></dt></dl></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="overview"></a>Chapter 2. Design Overview of 4.4BSD</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#overview-facilities">2.1. 4.4BSD Facilities and the Kernel</a></span></dt><dt><span class="sect1"><a href="#overview-kernel-organization">2.2. Kernel Organization</a></span></dt><dt><span class="sect1"><a href="#overview-kernel-service">2.3. Kernel Services</a></span></dt><dt><span class="sect1"><a href="#overview-process-management">2.4. Process Management</a></span></dt><dt><span class="sect1"><a href="#overview-memory-management">2.5. Memory Management</a></span></dt><dt><span class="sect1"><a href="#overview-io-system">2.6. I/O System</a></span></dt><dt><span class="sect1"><a href="#overview-filesystem">2.7. Filesystems</a></span></dt><dt><span class="sect1"><a href="#overview-filestore">2.8. Filestores</a></span></dt><dt><span class="sect1"><a href="#overview-nfs">2.9. Network Filesystem</a></span></dt><dt><span class="sect1"><a href="#overview-terminal">2.10. Terminals</a></span></dt><dt><span class="sect1"><a href="#overview-ipc">2.11. Interprocess Communication</a></span></dt><dt><span class="sect1"><a href="#overview-network-communication">2.12. Network Communication</a></span></dt><dt><span class="sect1"><a href="#overview-network-implementation">2.13. Network Implementation</a></span></dt><dt><span class="sect1"><a href="#overview-operation">2.14. System Operation</a></span></dt><dt><span class="bibliography"><a href="#references">References</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-facilities"></a>2.1. 4.4BSD Facilities and the Kernel</h2></div></div></div><p>The 4.4BSD kernel provides four basic facilities:
	processes,
	a filesystem,
	communications, and
	system startup.
	This section outlines where each of these four basic services
	is described in this book.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Processes constitute a thread of control in an address space.
	    Mechanisms for creating, terminating, and otherwise
	    controlling processes are described in
	    Chapter 4.
	    The system multiplexes separate virtual-address spaces
	    for each process;
	    this memory management is discussed in
	    Chapter 5.</p></li><li class="listitem"><p>The user interface to the filesystem and devices is similar;
	    common aspects are discussed in
	    Chapter 6.
	    The filesystem is a set of named files, organized in a tree-structured
	    hierarchy of directories, and of operations to manipulate them,
	    as presented in
	    Chapter 7.
	    Files reside on physical media such as disks.
	    4.4BSD supports several organizations of data on the disk,
	    as set forth in
	    Chapter 8.
	    Access to files on remote machines is the subject of
	    Chapter 9.
	    Terminals are used to access the system; their operation is
	    the subject of
	    Chapter 10.</p></li><li class="listitem"><p>Communication mechanisms provided by traditional UNIX systems include
	    simplex reliable byte streams between related processes (see pipes,
	    Section 11.1),
	    and notification of exceptional events (see signals,
	    Section 4.7).
	    4.4BSD also has a general interprocess-communication facility.
	    This facility, described in
	    Chapter 11,
	    uses access mechanisms distinct from those of the filesystem,
	    but, once a connection is set up, a process can access it
	    as though it were a pipe.
	    There is a general networking framework,
	    discussed in
	    Chapter 12,
	    that is normally used as a layer underlying the
	    IPC
	    facility.
	    Chapter 13
	    describes a particular networking implementation in detail.</p></li><li class="listitem"><p>Any real operating system has operational issues, such as how to
	    start it running.
	    Startup and operational issues are described in
	    Chapter 14.</p></li></ol></div><p>Sections 2.3 through 2.14 present introductory
	material related to Chapters 3 through 14.
	We shall define terms, mention basic system calls,
	and explore historical developments.
	Finally, we shall give the reasons for many major design decisions.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45071608"></a>2.1.1. The Kernel</h3></div></div></div><p>The
	  <span class="emphasis"><em>kernel</em></span>
	  is the part of the system that runs in protected mode and mediates
	  access by all user programs to the underlying hardware (e.g.,
	  CPU,
	  disks, terminals, network links)
	  and software constructs
	  (e.g., filesystem, network protocols).
	  The kernel provides the basic system facilities;
	  it creates and manages processes,
	  and provides functions to access the filesystem
	  and communication facilities.
	  These functions, called
	  <span class="emphasis"><em>system calls</em></span>
	  appear to user processes as library subroutines.
	  These system calls are the only interface
	  that processes have to these facilities.
	  Details of the system-call mechanism are given in
	  Chapter 3,
	  as are descriptions of several kernel mechanisms that do not execute
	  as the direct result of a process doing a system call.</p><p>A
	  <span class="emphasis"><em>kernel</em></span>
	  in traditional operating-system terminology,
	  is a small nucleus of software that
	  provides only the minimal facilities necessary for implementing
	  additional operating-system services.
	  In contemporary research operating systems -- such as
	  Chorus
	  <a class="xref" href="#biblio-rozier">[<abbr class="abbrev">Rozier et al, 1988</abbr>]</a>,
	  Mach
	  <a class="xref" href="#biblio-accetta">[<abbr class="abbrev">Accetta et al, 1986</abbr>]</a>,
	  Tunis
	  <a class="xref" href="#biblio-ewens">[<abbr class="abbrev">Ewens et al, 1985</abbr>]</a>,
	  and the
	  V Kernel
	  <a class="xref" href="#biblio-cheriton">[<abbr class="abbrev">Cheriton, 1988</abbr>]</a> --
	  this division of functionality is more than just a logical one.
	  Services such as filesystems and networking protocols are
	  implemented as client application processes of the nucleus or kernel.</p><p>The
	  4.4BSD kernel is not partitioned into multiple processes.
	  This basic design decision was made in the earliest versions of UNIX.
	  The first two implementations by
	  Ken Thompson had no memory mapping,
	  and thus made no hardware-enforced distinction
	  between user and kernel space
	  <a class="xref" href="#biblio-ritchie">[<abbr class="abbrev">Ritchie, 1988</abbr>]</a>.
	  A message-passing system could have been implemented as readily
	  as the actually implemented model of kernel and user processes.
	  The monolithic kernel was chosen for simplicity and performance.
	  And the early kernels were small;
	  the inclusion of facilities such as networking
	  into the kernel has increased its size.
	  The current trend in operating-systems research
	  is to reduce the kernel size by placing
	  such services in user space.</p><p>Users ordinarily interact with the system through a command-language
	  interpreter, called a
	  <span class="emphasis"><em>shell</em></span>,
	  and perhaps through additional user application programs.
	  Such programs and the shell are implemented with processes.
	  Details of such programs are beyond the scope of this book,
	  which instead concentrates almost exclusively on the kernel.</p><p>Sections 2.3 and 2.4
	  describe the services provided by the 4.4BSD kernel,
	  and give an overview of the latter's design.
	  Later chapters describe the detailed design and implementation of these
	  services as they appear in 4.4BSD.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-kernel-organization"></a>2.2. Kernel Organization</h2></div></div></div><p>In this section, we view the organization of the 4.4BSD
	kernel in two ways:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>As a static body of software,
	    categorized by the functionality offered by the modules
	    that make up the kernel</p></li><li class="listitem"><p>By its dynamic operation,
	    categorized according to the services provided to users</p></li></ol></div><p>The largest part of the kernel implements
	the system services that applications access through system calls.
	In 4.4BSD, this software has been organized according to the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Basic kernel facilities:
	    timer and system-clock handling,
	    descriptor management, and process management</p></li><li class="listitem"><p>Memory-management support:
	    paging and swapping</p></li><li class="listitem"><p>Generic system interfaces:
	    the I/O,
	    control, and multiplexing operations performed on descriptors</p></li><li class="listitem"><p>The filesystem:
	    files, directories, pathname translation, file locking,
	    and I/O buffer management</p></li><li class="listitem"><p>Terminal-handling support:
	    the terminal-interface driver and terminal
	    line disciplines</p></li><li class="listitem"><p>Interprocess-communication facilities:
	    sockets</p></li><li class="listitem"><p>Support for network communication:
	    communication protocols and
	    generic network facilities, such as routing</p></li></ul></div><div class="table"><a id="table-mach-indep"></a><div class="table-title">Table 2.1. Machine-independent software in the 4.4BSD kernel</div><div class="table-contents"><table class="table" summary="Machine-independent software in the 4.4BSD kernel" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Category</th><th>Lines of code</th><th>Percentage of kernel</th></tr></thead><tfoot><tr><th>total machine independent</th><th>162,617</th><th>80.4</th></tr></tfoot><tbody><tr><td>headers</td><td>9,393</td><td>4.6</td></tr><tr><td>initialization</td><td>1,107</td><td>0.6</td></tr><tr><td>kernel facilities</td><td>8,793</td><td>4.4</td></tr><tr><td>generic interfaces</td><td>4,782</td><td>2.4</td></tr><tr><td>interprocess communication</td><td>4,540</td><td>2.2</td></tr><tr><td>terminal handling</td><td>3,911</td><td>1.9</td></tr><tr><td>virtual memory</td><td>11,813</td><td>5.8</td></tr><tr><td>vnode management</td><td>7,954</td><td>3.9</td></tr><tr><td>filesystem naming</td><td>6,550</td><td>3.2</td></tr><tr><td>fast filestore</td><td>4,365</td><td>2.2</td></tr><tr><td>log-structure filestore</td><td>4,337</td><td>2.1</td></tr><tr><td>memory-based filestore</td><td>645</td><td>0.3</td></tr><tr><td>cd9660 filesystem</td><td>4,177</td><td>2.1</td></tr><tr><td>miscellaneous filesystems (10)</td><td>12,695</td><td>6.3</td></tr><tr><td>network filesystem</td><td>17,199</td><td>8.5</td></tr><tr><td>network communication</td><td>8,630</td><td>4.3</td></tr><tr><td>internet protocols</td><td>11,984</td><td>5.9</td></tr><tr><td>ISO protocols</td><td>23,924</td><td>11.8</td></tr><tr><td>X.25 protocols</td><td>10,626</td><td>5.3</td></tr><tr><td>XNS protocols</td><td>5,192</td><td>2.6</td></tr></tbody></table></div></div><br class="table-break" /><p>Most of the software in these categories is machine independent
	and is portable across different hardware architectures.</p><p>The machine-dependent aspects of the kernel
	are isolated from the mainstream code.
	In particular, none of the machine-independent code contains
	conditional code for specific architecture.
	When an architecture-dependent action is needed,
	the machine-independent code calls an architecture-dependent
	function that is located in the machine-dependent code.
	The software that is machine dependent includes</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Low-level system-startup actions</p></li><li class="listitem"><p>Trap and fault handling</p></li><li class="listitem"><p>Low-level manipulation of the run-time context of a
	    process</p></li><li class="listitem"><p>Configuration and initialization of hardware devices</p></li><li class="listitem"><p>Run-time support for I/O devices</p></li></ul></div><div class="table"><a id="table-mach-dep"></a><div class="table-title">Table 2.2. Machine-dependent software for the HP300 in the 4.4BSD
	  kernel</div><div class="table-contents"><table class="table" summary="Machine-dependent software for the HP300 in the 4.4BSD&#10;&#9;  kernel" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Category</th><th>Lines of code</th><th>Percentage of kernel</th></tr></thead><tfoot><tr><th>total machine dependent</th><th>39,634</th><th>19.6</th></tr></tfoot><tbody><tr><td>machine dependent headers</td><td>1,562</td><td>0.8</td></tr><tr><td>device driver headers</td><td>3,495</td><td>1.7</td></tr><tr><td>device driver source</td><td>17,506</td><td>8.7</td></tr><tr><td>virtual memory</td><td>3,087</td><td>1.5</td></tr><tr><td>other machine dependent</td><td>6,287</td><td>3.1</td></tr><tr><td>routines in assembly language</td><td>3,014</td><td>1.5</td></tr><tr><td>HP/UX compatibility</td><td>4,683</td><td>2.3</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="#table-mach-indep" title="Table 2.1. Machine-independent software in the 4.4BSD kernel">Table 2.1, &#8220;Machine-independent software in the 4.4BSD kernel&#8221;</a> summarizes the machine-independent software that constitutes the
	4.4BSD kernel for the HP300.
	The numbers in column 2 are for lines of C source code,
	header files, and assembly language.
	Virtually all the software in the kernel is written in the C
	programming language;
	less than 2 percent is written in
	assembly language.
	As the statistics in <a class="xref" href="#table-mach-dep" title="Table 2.2. Machine-dependent software for the HP300 in the 4.4BSD kernel">Table 2.2, &#8220;Machine-dependent software for the HP300 in the 4.4BSD
	  kernel&#8221;</a> show,
	the machine-dependent software, excluding
	HP/UX
	and device support,
	accounts for a minuscule 6.9 percent of the kernel.</p><p>Only a small part of the kernel is devoted to
	initializing the system.
	This code is used when the system is
	<span class="emphasis"><em>bootstrapped</em></span>
	into operation and is responsible for setting up the kernel hardware
	and software environment
	(see
	Chapter 14).
	Some operating systems (especially those with limited physical memory)
	discard or
	<span class="emphasis"><em>overlay</em></span>
	the software that performs these functions after that software has
	been executed.
	The 4.4BSD kernel does not reclaim the memory used by the
	startup code because that memory space is barely 0.5 percent
	of the kernel resources used on a typical machine.
	Also, the startup code does not appear in one place in the kernel -- it is
	scattered throughout, and it usually appears
	in places logically associated with what is being initialized.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-kernel-service"></a>2.3. Kernel Services</h2></div></div></div><p>The boundary between the kernel- and user-level code is enforced by
	hardware-protection facilities provided by the underlying hardware.
	The kernel operates in a separate address space that is inaccessible to
	user processes.
	Privileged operations -- such as starting I/O
	and halting the central processing unit
	(CPU) --
	are available to only the kernel.
	Applications request services from the kernel with
	<span class="emphasis"><em>system calls</em></span>.
	System calls are used to cause the kernel to execute complicated
	operations, such as writing data to secondary storage,
	and simple operations, such as returning the current time of day.
	All system calls appear
	<span class="emphasis"><em>synchronous</em></span>
	to applications:
	The application does not run while the kernel does the actions associated
	with a system call.
	The kernel may finish some operations associated with a system call
	after it has returned.
	For example, a
	<span class="emphasis"><em>write</em></span>
	system call will copy the data to be written
	from the user process to a kernel buffer while the process waits,
	but will usually return from the system call
	before the kernel buffer is written to the disk.</p><p>A system call usually is implemented as a hardware trap that changes the
	CPU's
	execution mode and the current address-space mapping.
	Parameters supplied by users in system calls are validated by the kernel
	before being used.
	Such checking ensures the integrity of the system.
	All parameters passed into the kernel are copied into the
	kernel's address space,
	to ensure that validated parameters are not changed
	as a side effect of the system call.
	System-call results are returned by the kernel,
	either in hardware registers or by their values
	being copied to user-specified memory addresses.
	Like parameters passed into the kernel,
	addresses used for
	the return of results must be validated to ensure that they are
	part of an application's address space.
	If the kernel encounters an error while processing a system call,
	it returns an error code to the user.
	For the
	C programming language, this error code
	is stored in the global variable
	<span class="emphasis"><em>errno</em></span>,
	and the function that executed the system call returns the value -1.</p><p>User applications and the kernel operate
	independently of each other.
	4.4BSD does not store I/O control blocks or other
	operating-system-related
	data structures in the application's address space.
	Each user-level application is provided an independent address space in
	which it executes.
	The kernel makes most state changes,
	such as suspending a process while another is running,
	invisible to the processes involved.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-process-management"></a>2.4. Process Management</h2></div></div></div><p>4.4BSD supports a multitasking environment.
	Each task or thread of execution is termed a
	<span class="emphasis"><em>process</em></span>.
	The
	<span class="emphasis"><em>context</em></span>
	of a 4.4BSD process consists of user-level state,
	including the contents of its address space
	and the run-time environment, and kernel-level state,
	which includes
	scheduling parameters,
	resource controls,
	and identification information.
	The context includes everything
	used by the kernel in providing services for the process.
	Users can create processes, control the processes' execution,
	and receive notification when the processes' execution status changes.
	Every process is assigned a unique value, termed a
	<span class="emphasis"><em>process identifier</em></span>
	(PID).
	This value is used by the kernel to identify a process when reporting
	status changes to a user, and by a user when referencing a process
	in a system call.</p><p>The kernel creates a process by duplicating the context of another process.
	The new process is termed a
	<span class="emphasis"><em>child process</em></span>
	of the original
	<span class="emphasis"><em>parent process</em></span>
	The context duplicated in process creation includes
	both the user-level execution state of the process and
	the process's system state managed by the kernel.
	Important components of the kernel state are described in
	Chapter 4.</p><div class="figure"><a id="fig-process-lifecycle"></a><div class="figure-title">Figure 2.1. Process lifecycle</div><div class="figure-contents"><div class="mediaobject"><img src="fig1.png" alt="Process-management system calls" /></div></div></div><br class="figure-break" /><p>The process lifecycle is depicted in <a class="xref" href="#fig-process-lifecycle" title="Figure 2.1. Process lifecycle">Figure 2.1, &#8220;Process lifecycle&#8221;</a>.
	A process may create a new process that is a copy of the original
	by using the
	<span class="emphasis"><em>fork</em></span>
	system call.
	The
	<span class="emphasis"><em>fork</em></span>
	call returns twice: once in the parent process, where
	the return value is the process identifier of the child,
	and once in the child process, where the return value is 0.
	The parent-child relationship induces a hierarchical structure on
	the set of processes in the system.
	The new process shares all its parent's resources, such as
	file descriptors, signal-handling status, and memory layout.</p><p>Although there are occasions when the new process is intended
	to be a copy of the parent,
	the loading and execution of a different program is
	a more useful and typical action.
	A process can overlay itself with the memory image of another program,
	passing to the newly created image a set of parameters,
	using the system call
	<span class="emphasis"><em>execve</em></span>.
	One parameter is the name of a file whose contents are
	in a format recognized by the system -- either a binary-executable file
	or a file that causes
	the execution of a specified interpreter program to process its contents.</p><p>A process may terminate by executing an
	<span class="emphasis"><em>exit</em></span>
	system call, sending 8 bits of
	exit status to its parent.
	If a process wants to communicate more than a single byte of
	information with its parent,
	it must either set up an interprocess-communication channel
	using pipes or sockets,
	or use an intermediate file.
	Interprocess communication is discussed extensively in
	Chapter 11.</p><p>A process can suspend execution until any of its child processes terminate
	using the
	<span class="emphasis"><em>wait</em></span>
	system call, which returns the
	PID
	and
	exit status of the terminated child process.
	A parent process can arrange to be notified by a signal when
	a child process exits or terminates abnormally.
	Using the
	<span class="emphasis"><em>wait4</em></span>
	system call, the parent can retrieve information about
	the event that caused termination of the child process
	and about resources consumed by the process during its lifetime.
	If a process is orphaned because its parent exits before it is finished,
	then the kernel arranges for the child's exit status to be passed back
	to a special system process
	
	<span class="emphasis"><em>init</em></span>:
	see Sections 3.1 and 14.6).</p><p>The details of how the kernel creates and destroys processes are given in
	Chapter 5.</p><p>Processes are scheduled for execution according to a
	<span class="emphasis"><em>process-priority</em></span>
	parameter.
	This priority is managed by a kernel-based scheduling algorithm.
	Users can influence the scheduling of a process by specifying
	a parameter
	(<span class="emphasis"><em>nice</em></span>)
	that weights the overall scheduling priority,
	but are still obligated to share the underlying
	CPU
	resources according to the kernel's scheduling policy.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45407480"></a>2.4.1. Signals</h3></div></div></div><p>The system defines a set of
	  <span class="emphasis"><em>signals</em></span>
	  that may be delivered to a process.
	  Signals in 4.4BSD are modeled after hardware interrupts.
	  A process may specify a user-level subroutine to be a
	  <span class="emphasis"><em>handler</em></span>
	  to which a signal should be delivered.
	  When a signal is generated,
	  it is blocked from further occurrence while it is being
	  <span class="emphasis"><em>caught</em></span>
	  by the handler.
	  Catching a signal involves saving the current process context
	  and building a new one in which to run the handler.
	  The signal is then delivered to the handler, which can either abort
	  the process or return to the executing process
	  (perhaps after setting a global variable).
	  If the handler returns, the signal is unblocked
	  and can be generated (and caught) again.</p><p>Alternatively, a process may specify that a signal is to be
	  <span class="emphasis"><em>ignored</em></span>,
	  or that a default action, as determined by the kernel, is to be taken.
	  The default action of certain signals is to terminate the process.
	  This termination may be accompanied by creation of a
	  <span class="emphasis"><em>core file</em></span>
	  that contains the current memory image of the process for use
	  in postmortem debugging.</p><p>Some signals cannot be caught or ignored.
	  These signals include
	  <span class="emphasis"><em>SIGKILL</em></span>,
	  which kills runaway processes,
	  and the
	  job-control signal
	  <span class="emphasis"><em>SIGSTOP</em></span>.</p><p>A process may choose to have signals delivered on a
	  special stack so that sophisticated software stack manipulations
	  are possible.
	  For example, a language supporting
	  coroutines needs to provide a stack for each coroutine.
	  The language run-time system can allocate these stacks
	  by dividing up the single stack provided by 4.4BSD.
	  If the kernel does not support a separate signal stack,
	  the space allocated for each coroutine must be expanded by the
	  amount of space required to catch a signal.</p><p>All signals have the same <span class="emphasis"><em>priority</em></span>.
	  If multiple signals are pending simultaneously, the order in which
	  signals are delivered to a process is implementation specific.
	  Signal handlers execute with the signal that caused their
	  invocation to be blocked, but other signals may yet occur.
	  Mechanisms are provided so that processes can protect critical sections
	  of code against the occurrence of specified signals.</p><p>The detailed design and implementation of signals is described in
	  Section 4.7.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45428728"></a>2.4.2. Process Groups and Sessions</h3></div></div></div><p>Processes are organized into
	  <span class="emphasis"><em>process groups</em></span>.
	  Process groups are used to control access to terminals
	  and to provide a means of distributing signals to collections of
	  related processes.
	  A process inherits its process group from its parent process.
	  Mechanisms are provided by the kernel to allow a process to
	  alter its process group or the process group of its descendents.
	  Creating a new process group is easy;
	  the value of a new process group is ordinarily the
	  process identifier of the creating process.</p><p>The group of processes in a process group is sometimes
	  referred to as a
	  <span class="emphasis"><em>job</em></span>
	  and is manipulated by high-level system software, such as the shell.
	  A common kind of job created by a shell is a
	  <span class="emphasis"><em>pipeline</em></span>
	  of several processes connected by pipes, such that the output of the first
	  process is the input of the second, the output of the second is the
	  input of the third, and so forth.
	  The shell creates such a job by forking a
	  process for each stage of the pipeline,
	  then putting all those processes into a separate process group.</p><p>A user process can send a signal to each process in
	  a process group, as well as to a single process.
	  A process in a specific process group may receive
	  software interrupts affecting the group, causing the group to
	  suspend or resume execution, or to be interrupted or terminated.</p><p>A terminal has a process-group identifier assigned to it.
	  This identifier is normally set to the identifier of a process group
	  associated with the terminal.
	  A job-control shell may create a number of process groups
	  associated with the same terminal; the terminal is the
	  <span class="emphasis"><em>controlling terminal</em></span>
	  for each process in these groups.
	  A process may read from a descriptor for its controlling terminal
	  only if the terminal's process-group identifier
	  matches that of the process.
	  If the identifiers do not match,
	  the process will be blocked if it attempts to read from the terminal.
	  By changing the process-group identifier of the terminal,
	  a shell can arbitrate a terminal among several different jobs.
	  This arbitration is called
	  <span class="emphasis"><em>job control</em></span>
	  and is described, with process groups, in
	  Section 4.8.</p><p>Just as a set of related processes can be collected into a process group,
	  a set of process groups can be collected into a
	  <span class="emphasis"><em>session</em></span>.
	  The main uses for sessions are to create an isolated environment for a
	  daemon process and its children,
	  and to collect together a user's login shell
	  and the jobs that that shell spawns.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-memory-management"></a>2.5. Memory Management</h2></div></div></div><p>Each process has its own private address space.
	The address space is initially divided into three logical segments:
	<span class="emphasis"><em>text</em></span>,
	<span class="emphasis"><em>data</em></span>,
	and
	<span class="emphasis"><em>stack</em></span>.
	The text segment is read-only and contains the machine
	instructions of a program.
	The data and stack segments are both readable and writable.
	The data segment contains the
	initialized and uninitialized data portions of a program, whereas
	the stack segment holds the application's run-time stack.
	On most machines, the stack segment is extended automatically
	by the kernel as the process executes.
	A process can expand or contract its data segment by making a system call,
	whereas a process can change the size of its text segment
	only when the segment's contents are overlaid with data from the
	filesystem, or when debugging takes place.
	The initial contents of the segments of a child process
	are duplicates of the segments of a parent process.</p><p>The entire contents of a process address space do not need to be resident
	for a process to execute.
	If a process references a part of its address space that is not
	resident in main memory, the system
	<span class="emphasis"><em>pages</em></span>
	the necessary information into memory.
	When system resources are scarce, the system uses a two-level
	approach to maintain available resources.
	If a modest amount of memory is available, the system will take
	memory resources away from processes if these resources have not been
	used recently.
	Should there be a severe resource shortage, the system will resort to
	<span class="emphasis"><em>swapping</em></span>
	the entire context of a process to secondary storage.
	The
	<span class="emphasis"><em>demand paging</em></span>
	and
	<span class="emphasis"><em>swapping</em></span>
	done by the system are effectively transparent to processes.
	A process may, however, advise the system
	about expected future memory utilization as a performance aid.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45463928"></a>2.5.1. BSD Memory-Management Design Decisions</h3></div></div></div><p>The support of large sparse address spaces, mapped files,
	  and shared memory was a requirement for 4.2BSD.
	  An interface was specified, called
	  <span class="emphasis"><em>mmap</em></span>,
	  that allowed unrelated processes to request a shared
	  mapping of a file into their address spaces.
	  If multiple processes mapped the same file into their address spaces,
	  changes to the file's portion of an address space
	  by one process would be reflected
	  in the area mapped by the other processes, as well as in the file itself.
	  Ultimately, 4.2BSD was shipped without the
	  <span class="emphasis"><em>mmap</em></span>
	  interface, because of pressure to make other features, such as
	  networking, available.</p><p>Further development of the
	  <span class="emphasis"><em>mmap</em></span>
	  interface continued during the work on 4.3BSD.
	  Over 40 companies and research groups participated
	  in the discussions leading to the revised architecture
	  that was described in the Berkeley Software Architecture Manual
	  <a class="xref" href="#biblio-mckusick-1">[<abbr class="abbrev">McKusick et al, 1994</abbr>]</a>.
	  Several of the companies have implemented the revised interface
	  <a class="xref" href="#biblio-gingell">[<abbr class="abbrev">Gingell et al, 1987</abbr>]</a>.</p><p>Once again, time pressure prevented 4.3BSD from providing an
	  implementation of the interface.
	  Although the latter could have been built into the existing
	  4.3BSD virtual-memory system,
	  the developers decided not to put it in because
	  that implementation was nearly 10 years old.
	  Furthermore, the original virtual-memory design was based
	  on the assumption that computer
	  memories were small and expensive, whereas disks were
	  locally connected, fast, large, and inexpensive.
	  Thus, the virtual-memory system was designed to be frugal
	  with its use of memory at the expense of generating extra disk traffic.
	  In addition, the
	  4.3BSD implementation was riddled with
	  VAX
	  memory-management hardware dependencies that impeded its portability
	  to other computer architectures.
	  Finally, the virtual-memory system was not designed
	  to support the tightly coupled
	  multiprocessors that are becoming
	  increasingly common and important today.</p><p>Attempts to improve the old implementation incrementally
	  seemed doomed to failure.
	  A completely new design,
	  on the other hand,
	  could take advantage of large memories,
	  conserve disk transfers,
	  and have the potential to run on multiprocessors.
	  Consequently, the virtual-memory system was completely replaced in 4.4BSD.
	  The 4.4BSD virtual-memory system
	  is based on the Mach 2.0 VM system
	  <a class="xref" href="#biblio-tevanian">[<abbr class="abbrev">Tevanian, 1987</abbr>]</a>.
	  with updates from Mach 2.5 and Mach 3.0.
	  It features
	  efficient support for sharing,
	  a clean separation of machine-independent and machine-dependent features,
	  as well as (currently unused) multiprocessor support.
	  Processes can map files anywhere in their address space.
	  They can share parts of their address space by
	  doing a shared mapping of the same file.
	  Changes made by one process are visible in the address space of
	  the other process, and also are written back to the file itself.
	  Processes can also request private mappings of a file, which prevents
	  any changes that they make from being visible to other processes
	  mapping the file or being written back to the file itself.</p><p>Another issue with the virtual-memory system is the way that
	  information is passed into the kernel when a system call is made.
	  4.4BSD always copies data from the process address space
	  into a buffer in the kernel.
	  For read or write operations
	  that are transferring large quantities of data,
	  doing the copy can be time consuming.
	  An alternative to doing the copying is to remap the
	  process memory into the kernel.
	  The 4.4BSD kernel always copies the data for several reasons:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Often, the user data are not page aligned and are not a multiple of
	      the hardware page length.</p></li><li class="listitem"><p>If the page is taken away from the process,
	      it will no longer be able to reference that page.
	      Some programs depend on the data remaining in the
	      buffer even after those data have been written.</p></li><li class="listitem"><p>If the process is allowed to keep a copy of the page
	      (as it is in current 4.4BSD semantics),
	      the page must be made
	      <span class="emphasis"><em>copy-on-write</em></span>.
	      A copy-on-write page is one that is protected against being written
	      by being made read-only.
	      If the process attempts to modify the page,
	      the kernel gets a write fault.
	      The kernel then makes a copy of the page that the process can modify.
	      Unfortunately, the typical process will immediately
	      try to write new data to its output buffer,
	      forcing the data to be copied anyway.</p></li><li class="listitem"><p>When pages are remapped to new virtual-memory addresses,
	      most memory-management hardware requires that the hardware
	      address-translation cache be purged selectively.
	      The cache purges are often slow.
	      The net effect is that remapping is slower than
	      copying for blocks of data less than 4 to 8 Kbyte.</p></li></ul></div><p>The biggest incentives for memory mapping are the needs for
	  accessing big files and for passing large quantities of data
	  between processes.
	  The
	  <span class="emphasis"><em>mmap</em></span>
	  interface provides a way for both of these tasks
	  to be done without copying.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45487480"></a>2.5.2. Memory Management Inside the Kernel</h3></div></div></div><p>The kernel often does allocations of memory that are
	  needed for only the duration of a single system call.
	  In a user process, such short-term
	  memory would be allocated on the run-time stack.
	  Because the kernel has a limited run-time stack,
	  it is not feasible to allocate even moderate-sized blocks of memory on it.
	  Consequently, such memory must be allocated
	  through a more dynamic mechanism.
	  For example,
	  when the system must translate a pathname,
	  it must allocate a 1-Kbyte buffer to hold the name.
	  Other blocks of memory must be more persistent than a single system call,
	  and thus could not be allocated on the stack even if there was space.
	  An example is protocol-control blocks that remain throughout
	  the duration of a network connection.</p><p>Demands for dynamic memory allocation in the kernel have increased
	  as more services have been added.
	  A generalized memory allocator reduces the complexity
	  of writing code inside the kernel.
	  Thus, the 4.4BSD kernel has a single memory allocator that can be
	  used by any part of the system.
	  It has an interface similar to the C library routines
	  <span class="emphasis"><em>malloc</em></span>
	  and
	  <span class="emphasis"><em>free</em></span>
	  that provide memory allocation to application programs
	  <a class="xref" href="#biblio-mckusick-2">[<abbr class="abbrev">McKusick &amp; Karels, 1988</abbr>]</a>.
	  Like the C library interface,
	  the allocation routine takes a parameter specifying the
	  size of memory that is needed.
	  The range of sizes for memory requests is not constrained;
	  however, physical memory is allocated and is not paged.
	  The free routine takes a pointer to the storage being freed,
	  but does not require the size
	  of the piece of memory being freed.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-io-system"></a>2.6. I/O System</h2></div></div></div><p>The basic model of the UNIX
	I/O system is a sequence of bytes
	that can be accessed either randomly or sequentially.
	There are no
	<span class="emphasis"><em>access methods</em></span>
	and no
	<span class="emphasis"><em>control blocks</em></span>
	in a typical UNIX user process.</p><p>Different programs expect various levels of structure,
	but the kernel does not impose structure on I/O.
	For instance, the convention for text files is lines of
	ASCII
	characters separated by a single newline character
	(the
	ASCII
	line-feed character),
	but the kernel knows nothing about this convention.
	For the purposes of most programs,
	the model is further simplified to being a stream of data bytes,
	or an
	<span class="emphasis"><em>I/O stream</em></span>.
	It is this single common data form that makes the
	characteristic UNIX tool-based approach work
	<a class="xref" href="#biblio-kernighan">[<abbr class="abbrev">Kernighan &amp; Pike, 1984</abbr>]</a>.
	An I/O stream from one program can be fed as input
	to almost any other program.
	(This kind of traditional UNIX
	I/O stream should not be confused with the
	Eighth Edition stream I/O system or with the
	System V, Release 3
	STREAMS,
	both of which can be accessed as traditional I/O streams.)</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45512696"></a>2.6.1. Descriptors and I/O</h3></div></div></div><p>UNIX processes use
	  <span class="emphasis"><em>descriptors</em></span>
	  to reference I/O streams.
	  Descriptors are small unsigned integers obtained from the
	  <span class="emphasis"><em>open</em></span>
	  and
	  <span class="emphasis"><em>socket</em></span>
	  system calls.
	  The
	  <span class="emphasis"><em>open</em></span>
	  system call takes as arguments the name of a file and
	  a permission mode to
	  specify whether the file should be open for reading or for writing,
	  or for both.
	  This system call also can be used to create a new, empty file.
	  A
	  <span class="emphasis"><em>read</em></span>
	  or
	  <span class="emphasis"><em>write</em></span>
	  system call can be applied to a descriptor to transfer data.
	  The
	  <span class="emphasis"><em>close</em></span>
	  system call can be used to deallocate any descriptor.</p><p>Descriptors represent underlying objects supported by the kernel,
	  and are created by system calls specific to the type of object.
	  In 4.4BSD, three kinds of objects can be represented by descriptors:
	  files, pipes, and sockets.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A
	      <span class="emphasis"><em>file</em></span>
	      is a linear array of bytes with at least one name.
	      A file exists until all its names are deleted explicitly
	      and no process holds a descriptor for it.
	      A process acquires a descriptor for a file
	      by opening that file's name with the
	      <span class="emphasis"><em>open</em></span>
	      system call.
	      I/O devices are accessed as files.</p></li><li class="listitem"><p>A
	      <span class="emphasis"><em>pipe</em></span>
	      is a linear array of bytes, as is a file, but it is used solely
	      as an I/O stream, and it is unidirectional.
	      It also has no name,
	      and thus cannot be opened with
	      <span class="emphasis"><em>open</em></span>.
	      Instead, it is created by the
	      <span class="emphasis"><em>pipe</em></span>
	      system call, which returns two descriptors,
	      one of which accepts input that is sent to the other descriptor reliably,
	      without duplication, and in order.
	      The system also supports a named pipe or
	      FIFO.
	      A
	      FIFO
	      has properties identical to a pipe, except that it appears
	      in the filesystem;
	      thus, it can be opened using the
	      <span class="emphasis"><em>open</em></span>
	      system call.
	      Two processes that wish to communicate each open the
	      FIFO:
	      One opens it for reading, the other for writing.</p></li><li class="listitem"><p>A
	      <span class="emphasis"><em>socket</em></span>
	      is a transient object that is used for
	      interprocess communication;
	      it exists only as long as some process holds a descriptor
	      referring to it.
	      A socket is created by the
	      <span class="emphasis"><em>socket</em></span>
	      system call, which returns a descriptor for it.
	      There are different kinds of sockets that support various communication
	      semantics, such as reliable delivery of data, preservation of
	      message ordering, and preservation of message boundaries.</p></li></ul></div><p>In systems before 4.2BSD, pipes were implemented using the filesystem;
	  when sockets were introduced in 4.2BSD,
	  pipes were reimplemented as sockets.</p><p>The kernel keeps for each process a
	  <span class="emphasis"><em>descriptor table</em></span>,
	  which is a table that the kernel uses
	  to translate the external representation
	  of a descriptor into an internal representation.
	  (The descriptor is merely an index into this table.)
	  The descriptor table of a process is inherited from that process's parent,
	  and thus access to the objects
	  to which the descriptors refer also is inherited.
	  The main ways that a process can obtain a descriptor are by
	  opening or creation of an object,
	  and by inheritance from the parent process.
	  In addition, socket
	  IPC
	  allows passing of descriptors in messages between unrelated processes
	  on the same machine.</p><p>Every valid descriptor has an associated
	  <span class="emphasis"><em>file offset</em></span>
	  in bytes from the beginning of the object.
	  Read and write operations start at this offset, which is
	  updated after each data transfer.
	  For objects that permit random access,
	  the file offset also may be set with the
	  <span class="emphasis"><em>lseek</em></span>
	  system call.
	  Ordinary files permit random access, and some devices do, as well.
	  Pipes and sockets do not.</p><p>When a process terminates, the kernel
	  reclaims all the descriptors that were in use by that process.
	  If the process was holding the final reference to an object,
	  the object's manager is notified so that it can do any
	  necessary cleanup actions, such as final deletion of a file
	  or deallocation of a socket.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45559160"></a>2.6.2. Descriptor Management</h3></div></div></div><p>Most processes expect three descriptors to be open already
	  when they start running.
	  These descriptors are 0, 1, 2, more commonly known as
	  <span class="emphasis"><em>standard input</em></span>,
	  <span class="emphasis"><em>standard output</em></span>,
	  and
	  <span class="emphasis"><em>standard error</em></span>,
	  respectively.
	  Usually, all three are associated with the user's terminal
	  by the login process
	  (see
	  Section 14.6)
	  and are inherited through
	  <span class="emphasis"><em>fork</em></span>
	  and
	  <span class="emphasis"><em>exec</em></span>
	  by processes run by the user.
	  Thus, a program can read what the user types by reading standard
	  input, and the program can send output to the user's screen by
	  writing to standard output.
	  The standard error descriptor also is open for writing and is
	  used for error output, whereas standard output is used for ordinary output.</p><p>These (and other) descriptors can be mapped to objects other than
	  the terminal;
	  such mapping is called
	  <span class="emphasis"><em>I/O redirection</em></span>,
	  and all the standard shells permit users to do it.
	  The shell can direct the output of a program to a file
	  by closing descriptor 1 (standard output) and opening
	  the desired output file to produce a new descriptor 1.
	  It can similarly redirect standard input to come from a file
	  by closing descriptor 0 and opening the file.</p><p>Pipes allow the output of one program to be input to another program
	  without rewriting or even relinking of either program.
	  Instead of descriptor 1 (standard output)
	  of the source program being set up to write to the terminal,
	  it is set up to be the input descriptor of a pipe.
	  Similarly, descriptor 0 (standard input)
	  of the sink program is set up to reference the output of the pipe,
	  instead of the terminal keyboard.
	  The resulting set of two processes and the connecting pipe is known as a
	  <span class="emphasis"><em>pipeline</em></span>.
	  Pipelines can be arbitrarily long series of processes connected by pipes.</p><p>The
	  <span class="emphasis"><em>open</em></span>,
	  <span class="emphasis"><em>pipe</em></span>,
	  and
	  <span class="emphasis"><em>socket</em></span>
	  system calls produce new descriptors with the lowest unused number
	  usable for a descriptor.
	  For pipelines to work,
	  some mechanism must be provided to map such descriptors into 0 and 1.
	  The
	  <span class="emphasis"><em>dup</em></span>
	  system call creates a copy of a descriptor that
	  points to the same file-table entry.
	  The new descriptor is also the lowest unused one,
	  but if the desired descriptor is closed first,
	  <span class="emphasis"><em>dup</em></span>
	  can be used to do the desired mapping.
	  Care is required, however: If descriptor 1 is desired,
	  and descriptor 0 happens also to have been closed, descriptor 0
	  will be the result.
	  To avoid this problem, the system provides the
	  <span class="emphasis"><em>dup2</em></span>
	  system call;
	  it is like
	  <span class="emphasis"><em>dup</em></span>,
	  but it takes an additional argument specifying
	  the number of the desired descriptor
	  (if the desired descriptor was already open,
	  <span class="emphasis"><em>dup2</em></span>
	  closes it before reusing it).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45578104"></a>2.6.3. Devices</h3></div></div></div><p>Hardware devices have filenames, and may be
	  accessed by the user via the same system calls used for regular files.
	  The kernel can distinguish a
	  <span class="emphasis"><em>device special file</em></span>
	  or
	  <span class="emphasis"><em>special file</em></span>,
	  and can determine to what device it refers,
	  but most processes do not need to make this determination.
	  Terminals, printers, and tape drives are all accessed as though they
	  were streams of bytes, like 4.4BSD disk files.
	  Thus, device dependencies and peculiarities are kept in the kernel
	  as much as possible, and even in the kernel most of them are segregated
	  in the device drivers.</p><p>Hardware devices can be categorized as either
	  <span class="emphasis"><em>structured</em></span>
	  or
	  <span class="emphasis"><em>unstructured</em></span>;
	  they are known as
	  <span class="emphasis"><em>block</em></span>
	  or
	  <span class="emphasis"><em>character</em></span>
	  devices, respectively.
	  Processes typically access devices through
	  <span class="emphasis"><em>special files</em></span>
	  in the filesystem.
	  I/O operations to these files are handled by
	  kernel-resident software modules termed
	  <span class="emphasis"><em>device drivers</em></span>.
	  Most network-communication hardware devices are accessible through only
	  the interprocess-communication facilities,
	  and do not have special files in the filesystem name space,
	  because the
	  <span class="emphasis"><em>raw-socket</em></span>
	  interface provides a more natural interface than does a special file.</p><p>Structured or block devices are typified by disks and magnetic tapes,
	  and include most random-access devices.
	  The kernel supports read-modify-write-type buffering actions
	  on block-oriented structured devices to allow the latter
	  to be read and written in a
	  totally random byte-addressed fashion, like regular files.
	  Filesystems are created on block devices.</p><p>Unstructured devices are those devices that do not support a block
	  structure.
	  Familiar unstructured devices are communication lines, raster
	  plotters, and unbuffered magnetic tapes and disks.
	  Unstructured devices typically support large block I/O transfers.</p><p>Unstructured files are called
	  <span class="emphasis"><em>character devices</em></span>
	  because the first of these to be implemented were terminal device drivers.
	  The kernel interface to the driver for these devices proved convenient
	  for other devices that were not block structured.</p><p>Device special files are created by the
	  <span class="emphasis"><em>mknod</em></span>
	  system call.
	  There is an additional system call,
	  <span class="emphasis"><em>ioctl</em></span>,
	  for manipulating the underlying device parameters of special files.
	  The operations that can be done differ for each device.
	  This system call allows the special characteristics of devices to
	  be accessed, rather than overloading the semantics of other system calls.
	  For example, there is an
	  <span class="emphasis"><em>ioctl</em></span>
	  on a tape drive to write an end-of-tape mark,
	  instead of there being a special or modified version of
	  <span class="emphasis"><em>write</em></span>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45605624"></a>2.6.4. Socket IPC</h3></div></div></div><p>The 4.2BSD kernel introduced an
	  IPC
	  mechanism more flexible than pipes, based on
	  <span class="emphasis"><em>sockets</em></span>.
	  A socket is an endpoint of communication referred to by
	  a descriptor, just like a file or a pipe.
	  Two processes can each create a socket, and then connect those
	  two endpoints to produce a reliable byte stream.
	  Once connected, the descriptors for the sockets can be read or written
	  by processes, just as the latter would do with a pipe.
	  The transparency of sockets allows the kernel to redirect the output
	  of one process to the input of another process residing on another machine.
	  A major difference between pipes and sockets is that
	  pipes require a common parent process to set up the
	  communications channel.
	  A connection between sockets can be set up by two unrelated processes,
	  possibly residing on different machines.</p><p>System V provides local interprocess communication through
	  FIFOs
	  (also known as
	  <span class="emphasis"><em>named pipes</em></span>).
	  FIFOs
	  appear as an object in the filesystem that unrelated
	  processes can open and send data through in the same
	  way as they would communicate through a pipe.
	  Thus,
	  FIFOs
	  do not require a common parent to set them up;
	  they can be connected after a pair of processes are up and running.
	  Unlike sockets,
	  FIFOs
	  can be used on only a local machine;
	  they cannot be used to communicate between processes on different machines.
	  FIFOs
	  are implemented in 4.4BSD only because they are required by the
	  POSIX.1
	  standard.
	  Their functionality is a subset of the socket interface.</p><p>The socket mechanism requires extensions to the traditional UNIX
	  I/O system calls to provide the associated naming and connection semantics.
	  Rather than overloading the existing interface,
	  the developers used the existing interfaces to the extent that
	  the latter worked without being changed,
	  and designed new interfaces to handle the added semantics.
	  The
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  system calls were used for byte-stream type connections,
	  but six new system calls were added
	  to allow sending and receiving addressed messages
	  such as network datagrams.
	  The system calls for writing messages include
	  <span class="emphasis"><em>send</em></span>,
	  <span class="emphasis"><em>sendto</em></span>,
	  and
	  <span class="emphasis"><em>sendmsg</em></span>.
	  The system calls for reading messages include
	  <span class="emphasis"><em>recv</em></span>,
	  <span class="emphasis"><em>recvfrom</em></span>,
	  and
	  <span class="emphasis"><em>recvmsg</em></span>.
	  In retrospect, the first two in each class are special cases of the others;
	  <span class="emphasis"><em>recvfrom</em></span>
	  and
	  <span class="emphasis"><em>sendto</em></span>
	  probably should have been added as library interfaces to
	  <span class="emphasis"><em>recvmsg</em></span>
	  and
	  <span class="emphasis"><em>sendmsg</em></span>,
	  respectively.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45627000"></a>2.6.5. Scatter/Gather I/O</h3></div></div></div><p>In addition to the traditional
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  system calls, 4.2BSD introduced the ability to do scatter/gather I/O.
	  Scatter input uses the
	  <span class="emphasis"><em>readv</em></span>
	  system call to allow a single read
	  to be placed in several different buffers.
	  Conversely, the
	  <span class="emphasis"><em>writev</em></span>
	  system call allows several different buffers
	  to be written in a single atomic write.
	  Instead of passing a single buffer and length parameter, as is done with
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>,
	  the process passes in a pointer to an array of buffers and lengths,
	  along with a count describing the size of the array.</p><p>This facility allows buffers in different parts of a process
	  address space to be written atomically, without the
	  need to copy them to a single contiguous buffer.
	  Atomic writes are necessary in the case where the underlying
	  abstraction is record based, such as tape drives that output a
	  tape block on each write request.
	  It is also convenient to be able to read a single request into
	  several different buffers (such as a record header into one place
	  and the data into another).
	  Although an application can simulate the ability to scatter data
	  by reading the data into a large buffer and then copying the pieces
	  to their intended destinations,
	  the cost of memory-to-memory copying in such cases often
	  would more than double the running time of the affected application.</p><p>Just as
	  <span class="emphasis"><em>send</em></span>
	  and
	  <span class="emphasis"><em>recv</em></span>
	  could have been implemented as library interfaces to
	  <span class="emphasis"><em>sendto</em></span>
	  and
	  <span class="emphasis"><em>recvfrom</em></span>,
	  it also would have been possible to simulate
	  <span class="emphasis"><em>read</em></span>
	  with
	  <span class="emphasis"><em>readv</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  with
	  <span class="emphasis"><em>writev</em></span>.
	  However,
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  are used so much more frequently that the added cost
	  of simulating them would not have been worthwhile.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp45663480"></a>2.6.6. Multiple Filesystem Support</h3></div></div></div><p>With the expansion of network computing,
	  it became desirable to support both local and remote filesystems.
	  To simplify the support of multiple filesystems,
	  the developers added a new virtual node or
	  <span class="emphasis"><em>vnode</em></span>
	  interface to the kernel.
	  The set of operations exported from the vnode interface
	  appear much like the filesystem operations previously supported
	  by the local filesystem.
	  However, they may be supported by a wide range of filesystem types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Local disk-based filesystems</p></li><li class="listitem"><p>Files imported using a variety of remote filesystem protocols</p></li><li class="listitem"><p>Read-only
	      CD-ROM
	      filesystems</p></li><li class="listitem"><p>Filesystems providing special-purpose interfaces -- for example, the
	      <code class="filename">/proc</code>
	      filesystem</p></li></ul></div><p>A few variants of 4.4BSD, such as FreeBSD,
	  allow filesystems to be loaded dynamically
	  when the filesystems are first referenced by the
	  <span class="emphasis"><em>mount</em></span>
	  system call.
	  The vnode interface is described in
	  Section 6.5;
	  its ancillary support routines are described in
	  Section 6.6;
	  several of the special-purpose filesystems are described in
	  Section 6.7.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-filesystem"></a>2.7. Filesystems</h2></div></div></div><p>A regular file is a linear array of bytes,
    and can be read and written starting at any byte in the file.
    The kernel distinguishes no record boundaries in regular files, although
    many programs recognize line-feed characters as distinguishing
    the ends of lines, and other programs may impose other structure.
    No system-related information about a file is kept in the file itself,
    but the filesystem stores a small amount of ownership, protection,
    and usage information with each file.</p><p>A
    <span class="emphasis"><em>filename</em></span>
    component is a string of up to 255 characters.
    These filenames are stored in a type of file called a
    <span class="emphasis"><em>directory</em></span>.
    The information in a directory about a file is called a
    <span class="emphasis"><em>directory entry</em></span>
    and includes, in addition to the filename,
    a pointer to the file itself.
    Directory entries may refer to other directories, as well as to plain files.
    A hierarchy of directories and files is thus formed, and is called a
    <span class="emphasis"><em>filesystem</em></span>;</p><div class="figure"><a id="fig-small-fs"></a><div class="figure-title">Figure 2.2. A small filesystem</div><div class="figure-contents"><div class="mediaobject"><img src="fig2.png" alt="A small filesystem tree" /></div></div></div><br class="figure-break" /><p>a small one is shown in <a class="xref" href="#fig-small-fs" title="Figure 2.2. A small filesystem">Figure 2.2, &#8220;A small filesystem&#8221;</a>.
    Directories may contain subdirectories, and there is no inherent
    limitation to the depth with which directory nesting may occur.
    To protect the consistency of the filesystem, the kernel
    does not permit processes to write directly into directories.
    A filesystem may include not only plain files and directories,
    but also references to other objects, such as devices and sockets.</p><p>The filesystem forms a tree, the beginning of which is the
    <span class="emphasis"><em>root directory</em></span>,
    sometimes referred to by the name
    <span class="emphasis"><em>slash</em></span>,
    spelled with a single solidus character (/).
    The root directory contains files; in our example in Fig 2.2, it contains
    <code class="filename">vmunix</code>,
    a copy of the kernel-executable object file.
    It also contains directories; in this example, it contains the
    <code class="filename">usr</code>
    directory.
    Within the
    <code class="filename">usr</code>
    directory is the
    <code class="filename">bin</code>
    directory, which mostly contains executable object code of programs,
    such as the files
      
    <code class="filename">ls</code>
    and
    <code class="filename">vi</code>.</p><p>A process identifies a file by specifying that file's
    <span class="emphasis"><em>pathname</em></span>,
    which is a string composed of zero or more
    filenames separated by slash (/) characters.
    The kernel associates two directories with each process for use
    in interpreting pathnames.
    A process's
    <span class="emphasis"><em>root directory</em></span>
    is the topmost point in the filesystem that the process can access;
    it is ordinarily set to the root directory of the entire filesystem.
    A pathname beginning with a slash is called an
    <span class="emphasis"><em>absolute pathname</em></span>,
    and is interpreted by the kernel starting with the process's root directory.</p><p>A pathname that does not begin with a slash is called a
    <span class="emphasis"><em>relative pathname</em></span>,
    and is interpreted relative to the
    <span class="emphasis"><em>current working directory</em></span>
    of the process.
    (This directory also is known by the shorter names
    <span class="emphasis"><em>current directory</em></span>
    or
    <span class="emphasis"><em>working directory</em></span>.)
    The current directory itself may be referred to directly by the name
    <span class="emphasis"><em>dot</em></span>,
    spelled with a single period
    (<code class="filename">.</code>).
    The filename
    <span class="emphasis"><em>dot-dot</em></span>
    (<code class="filename">..</code>)
    refers to a directory's parent directory.
    The root directory is its own parent.</p><p>A process may set its root directory with the
    <span class="emphasis"><em>chroot</em></span>
    system call,
    and its current directory with the
    <span class="emphasis"><em>chdir</em></span>
    system call.
    Any process may do
    <span class="emphasis"><em>chdir</em></span>
    at any time, but
    <span class="emphasis"><em>chroot</em></span>
    is permitted only a process with superuser privileges.
    <span class="emphasis"><em>Chroot</em></span>
    is normally used to set up restricted access to the system.</p><p>Using the filesystem shown in Fig. 2.2,
    if a process has the root of the filesystem as its root directory, and has
    <code class="filename">/usr</code>
    as its current directory, it can refer to the file
    <code class="filename">vi</code>
    either from the root with the absolute pathname
    <code class="filename">/usr/bin/vi</code>,
    or from its current directory with the relative pathname
    <code class="filename">bin/vi</code>.</p><p>System utilities and databases are kept in certain well-known directories.
    Part of the well-defined hierarchy includes a directory that contains the
    <span class="emphasis"><em>home directory</em></span>
    for each user -- for example,
    <code class="filename">/usr/staff/mckusick</code>
    and
    <code class="filename">/usr/staff/karels</code>
    in Fig. 2.2.
    When users log in,
    the current working directory of their shell is set to the
    home directory.
    Within their home directories,
    users can create directories as easily as they can regular files.
    Thus, a user can build arbitrarily complex subhierarchies.</p><p>The user usually knows of only one filesystem, but the system may
    know that this one virtual filesystem
    is really composed of several physical
    filesystems, each on a different device.
    A physical filesystem may not span multiple hardware devices.
    Since most physical disk devices are divided into several logical devices,
    there may be more than one filesystem per physical device,
    but there will be no more than one per logical device.
    One filesystem -- the filesystem that
    anchors all absolute pathnames -- is called the
    <span class="emphasis"><em>root filesystem</em></span>,
    and is always available.
    Others may be mounted;
    that is, they may be integrated into the
    directory hierarchy of the root filesystem.
    References to a directory that has a filesystem mounted on it
    are converted transparently by the kernel
    into references to the root directory of the mounted filesystem.</p><p>The
    <span class="emphasis"><em>link</em></span>
    system call takes the name of an existing file and another name
    to create for that file.
    After a successful
    <span class="emphasis"><em>link</em></span>,
    the file can be accessed by either filename.
    A filename can be removed with the
    <span class="emphasis"><em>unlink</em></span>
    system call.
    When the final name for a file is removed (and the final process that
    has the file open closes it), the file is deleted.</p><p>Files are organized hierarchically in
    <span class="emphasis"><em>directories</em></span>.
    A directory is a type of file,
    but, in contrast to regular files,
    a directory has a structure imposed on it by the system.
    A process can read a directory as it would an ordinary file,
    but only the kernel is permitted to modify a directory.
    Directories are created by the
    <span class="emphasis"><em>mkdir</em></span>
    system call and are removed by the
    <span class="emphasis"><em>rmdir</em></span>
    system call.
    Before 4.2BSD, the
    <span class="emphasis"><em>mkdir</em></span>
    and
    <span class="emphasis"><em>rmdir</em></span>
    system calls were implemented by a series of
    <span class="emphasis"><em>link</em></span>
    and
    <span class="emphasis"><em>unlink</em></span>
    system calls being done.
    There were three reasons for adding systems calls
    explicitly to create and delete directories:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The operation could be made atomic.
      If the system crashed,
      the directory would not be left half-constructed,
      as could happen when a series of link operations were used.</p></li><li class="listitem"><p>When a
      networked filesystem is being run,
      the creation and deletion of files and directories need to be
      specified atomically so that they can be serialized.</p></li><li class="listitem"><p>When supporting non-UNIX filesystems, such as an
      MS-DOS
      filesystem, on another partition of the disk,
      the other filesystem may not support link operations.
      Although other filesystems might support the concept of directories,
      they probably would not create and delete the directories with links,
      as the UNIX filesystem does.
      Consequently, they could create and delete directories only
      if explicit directory create and delete requests were presented.</p></li></ol></div><p>The
    <span class="emphasis"><em>chown</em></span>
    system call sets the owner and group of a file, and
    <span class="emphasis"><em>chmod</em></span>
    changes protection attributes.
    <span class="emphasis"><em>Stat</em></span>
    applied to a filename can be used to read back such properties of a file.
    The
    <span class="emphasis"><em>fchown</em></span>,
    <span class="emphasis"><em>fchmod</em></span>,
    and
    <span class="emphasis"><em>fstat</em></span>
    system calls are applied to a descriptor, instead of
    to a filename, to do the same set of operations.
    The
    <span class="emphasis"><em>rename</em></span>
    system call can be used to give a file a new name in the filesystem,
    replacing one of the file's old names.
    Like the directory-creation and directory-deletion operations, the
    <span class="emphasis"><em>rename</em></span>
    system call was added to 4.2BSD
    to provide atomicity to name changes in the local filesystem.
    Later, it proved useful explicitly to
    export renaming operations to foreign filesystems and over the network.</p><p>The
    <span class="emphasis"><em>truncate</em></span>
    system call was added to 4.2BSD to allow files to be shortened
    to an arbitrary offset.
    The call was added primarily in support of the Fortran
    run-time library,
    which has the semantics such that the end of a random-access
    file is set to be wherever the program most recently accessed that file.
    Without the
    <span class="emphasis"><em>truncate</em></span>
    system call, the only way to shorten a file was to
    copy the part that was desired to a new file, to delete the old file,
    then to rename the copy to the original name.
    As well as this algorithm being slow,
    the library could potentially fail on a full filesystem.</p><p>Once the filesystem had the ability to shorten files,
    the kernel took advantage of that ability
    to shorten large empty directories.
    The advantage of shortening empty directories is that it reduces the
    time spent in the kernel searching them
    when names are being created or deleted.</p><p>Newly created files are assigned the user identifier of the process
    that created them and the group identifier of the directory
    in which they were created.
    A three-level access-control mechanism is provided for
    the protection of files.
    These three levels specify the accessibility of a file to</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The user who owns the file</p></li><li class="listitem"><p>The group that owns the file</p></li><li class="listitem"><p>Everyone else</p></li></ol></div><p>Each level of access has separate indicators for read permission,
    write permission, and execute permission.</p><p>Files are created with zero length, and may grow when they are written.
    While a file is open, the system maintains a pointer into
    the file indicating the current location in
    the file associated with the descriptor.
    This pointer can be moved about in the file in a random-access fashion.
    Processes sharing a file descriptor through a
    <span class="emphasis"><em>fork</em></span>
    or
    <span class="emphasis"><em>dup</em></span>
    system call share the current location pointer.
    Descriptors created by separate
    <span class="emphasis"><em>open</em></span>
    system calls have separate current location pointers.
    Files may have
    <span class="emphasis"><em>holes</em></span>
    in them.
    Holes are void areas in the linear extent of the file where data have
    never been written.
    A process can create these holes by positioning
    the pointer past the current end-of-file and writing.
    When read, holes are treated by the system as zero-valued bytes.</p><p>Earlier UNIX systems had a limit of 14 characters per filename component.
    This limitation was often a problem.
    For example,
    in addition to the natural desire of users
    to give files long descriptive names,
    a common way of forming filenames is as
      <code class="filename"><em class="replaceable"><code>basename</code></em>.<em class="replaceable"><code>extension</code></em></code>,
    where the extension (indicating the kind of file, such as
    <code class="literal">.c</code>
    for C source or
    <code class="literal">.o</code>
    for intermediate binary object)
    is one to three characters,
    leaving 10 to 12 characters for the basename.
    Source-code-control systems and editors usually take up another
    two characters, either as a prefix or a suffix, for their purposes,
    leaving eight to 10 characters.
    It is easy to use 10 or 12 characters in a single
    English word as a basename (e.g., ``multiplexer'').</p><p>It is possible to keep within these limits,
    but it is inconvenient or even dangerous, because other UNIX
    systems accept strings longer than the limit when creating files,
    but then
    <span class="emphasis"><em>truncate</em></span>
    to the limit.
    A C language source file named
    <code class="filename">multiplexer.c</code>
    (already 13 characters) might have a source-code-control file
    with
    <code class="literal">s.</code>
    prepended, producing a filename
    <code class="filename">s.multiplexer</code>
    that is indistinguishable from the source-code-control file for
    <code class="filename">multiplexer.ms</code>,
    a file containing
      
    <code class="literal">troff</code>
    source for documentation for the C program.
    The contents of the two original files could easily get confused
    with no warning from the source-code-control system.
    Careful coding can detect this problem, but the
    long filenames
    first introduced in 4.2BSD practically eliminate it.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-filestore"></a>2.8. Filestores</h2></div></div></div><p>The operations defined for local filesystems are divided into two parts.
    Common to all local filesystems are hierarchical naming,
    locking, quotas, attribute management, and protection.
    These features are independent of how the data will be stored.
    4.4BSD has a single implementation to provide these semantics.</p><p>The other part of the local filesystem is the organization
    and management of the data on the storage media.
    Laying out the contents of files on the storage media is
    the responsibility of the filestore.
    4.4BSD supports three different filestore layouts:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The traditional Berkeley Fast Filesystem</p></li><li class="listitem"><p>The log-structured filesystem,
      based on the Sprite operating-system design
      <a class="xref" href="#biblio-rosenblum">[<abbr class="abbrev">Rosenblum &amp; Ousterhout, 1992</abbr>]</a></p></li><li class="listitem"><p>A memory-based filesystem</p></li></ul></div><p>Although the organizations of these filestores are completely different,
    these differences are indistinguishable
    to the processes using the filestores.</p><p>The Fast Filesystem organizes data into cylinder groups.
    Files that are likely to be accessed together,
    based on their locations in the filesystem hierarchy,
    are stored in the same cylinder group.
    Files that are not expected to accessed together are moved into
    different cylinder groups.
    Thus, files written at the same time may be placed far apart on the
    disk.</p><p>The log-structured filesystem organizes data as a log.
    All data being written at any point in time are gathered together,
    and are written at the same disk location.
    Data are never overwritten;
    instead, a new copy of the file is written that replaces the old one.
    The old files are reclaimed by a garbage-collection process that runs
    when the filesystem becomes full and additional free space is needed.</p><p>The memory-based filesystem is designed to store data in virtual memory.
    It is used for filesystems that need to support
    fast but temporary data, such as
    <code class="filename">/tmp</code>.
    The goal of the memory-based filesystem is to keep
    the storage packed as compactly as possible to minimize
    the usage of virtual-memory resources.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-nfs"></a>2.9. Network Filesystem</h2></div></div></div><p>Initially, networking was used
    to transfer data from one machine to another.
    Later, it evolved to allowing users to log in remotely to another machine.
    The next logical step was to bring the data to the user,
    instead of having the user go to the data --
    and network filesystems were born.
    Users working locally
    do not experience the network delays on each keystroke,
    so they have a more responsive environment.</p><p>Bringing the filesystem to a local machine was among the first
    of the major client-server applications.
    The
    <span class="emphasis"><em>server</em></span>
    is the remote machine that exports one or more of its filesystems.
    The
    <span class="emphasis"><em>client</em></span>
    is the local machine that imports those filesystems.
    From the local client's point of view,
    a remotely mounted filesystem appears in the file-tree name space
    just like any other locally mounted filesystem.
    Local clients can change into directories on the remote filesystem,
    and can read, write, and execute binaries within that remote filesystem
    identically to the way that they can do these operations
    on a local filesystem.</p><p>When the local client does an operation on a remote filesystem,
    the request is packaged and is sent to the server.
    The server does the requested operation and
    returns either the requested information or an error
    indicating why the request was denied.
    To get reasonable performance,
    the client must cache frequently accessed data.
    The complexity of remote filesystems lies in maintaining cache
    consistency between the server and its many clients.</p><p>Although many remote-filesystem protocols
    have been developed over the years,
    the most pervasive one in use among UNIX
    systems is the Network Filesystem
    (NFS),
    whose protocol and most widely used implementation were
    done by Sun Microsystems.
    The 4.4BSD kernel supports the
    NFS
    protocol, although the implementation was done independently
    from the protocol specification
    <a class="xref" href="#biblio-macklem">[<abbr class="abbrev">Macklem, 1994</abbr>]</a>.
    The
    NFS
    protocol is described in
    Chapter 9.
    </p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-terminal"></a>2.10. Terminals</h2></div></div></div><p>Terminals support the standard system I/O operations, as well
	as a collection of terminal-specific operations to control input-character
	editing and output delays.
	At the lowest level are the terminal device drivers that control
	the hardware terminal ports.
	Terminal input is handled according to the underlying communication
	characteristics, such as baud rate,
	and according to a set of software-controllable
	parameters, such as parity checking.</p><p>Layered above the terminal device drivers are line disciplines
	that provide various degrees of character processing.
	The default line discipline is selected when a port is being
	used for an interactive login.
	The line discipline is run in
	<span class="emphasis"><em>canonical mode</em></span>;
	input is processed to provide standard line-oriented editing functions,
	and input is presented to a process on a line-by-line basis.</p><p>Screen editors and programs that communicate with other computers
	generally run in
	<span class="emphasis"><em>noncanonical mode</em></span>
	(also commonly referred to as
	<span class="emphasis"><em>raw mode</em></span>
	or
	<span class="emphasis"><em>character-at-a-time mode</em></span>).
	In this mode, input is passed through to the reading process immediately
	and without interpretation.
	All special-character input processing is disabled,
	no erase or other line editing processing is done,
	and all characters are passed to the program
	that is reading from the terminal.</p><p>It is possible to configure the terminal in thousands
	of combinations between these two extremes.
	For example,
	a screen editor that wanted to receive user interrupts asynchronously
	might enable the special characters that
	generate signals and enable output flow control,
	but otherwise run in noncanonical mode;
	all other characters would be passed through to the process uninterpreted.</p><p>On output, the terminal handler provides simple formatting services,
	including</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Converting the line-feed character
	    to the two-character carriage-return-line-feed sequence</p></li><li class="listitem"><p>Inserting delays after certain standard control characters</p></li><li class="listitem"><p>Expanding tabs</p></li><li class="listitem"><p>Displaying echoed nongraphic
	    ASCII
	    characters as a two-character sequence of the
	    form ``^C''
	    (i.e., the
	    ASCII
	    caret character followed by the
	    ASCII
	    character that is the character's value offset from the
	    ASCII
	    ``@'' character).</p></li></ul></div><p>Each of these formatting services can be disabled individually by
	a process through control requests.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-ipc"></a>2.11. Interprocess Communication</h2></div></div></div><p>Interprocess communication in 4.4BSD is organized in
	<span class="emphasis"><em>communication domains</em></span>.
	Domains currently supported include the
	<span class="emphasis"><em>local domain</em></span>,
	for communication between processes executing on the same machine; the
	<span class="emphasis"><em>internet domain</em></span>,
	for communication between processes using the
	TCP/IP
	protocol suite (perhaps within the Internet); the
	ISO/OSI
	protocol family for communication between sites required to run them;
	and the
	<span class="emphasis"><em>XNS domain</em></span>,
	for communication between processes using the
	XEROX
	Network Systems
	(XNS)
	protocols.</p><p>Within a domain, communication takes place between communication
	endpoints known as
	<span class="emphasis"><em>sockets</em></span>.
	As mentioned in
	Section 2.6,
	the
	<span class="emphasis"><em>socket</em></span>
	system call creates a socket and returns a descriptor;
	other
	IPC
	system calls are described in
	Chapter 11.
	Each socket has a type that defines its communications semantics;
	these semantics include properties such as reliability, ordering,
	and prevention of duplication of messages.</p><p>Each socket has associated with it a
	<span class="emphasis"><em>communication protocol</em></span>.
	This protocol provides the semantics required
	by the socket according to the latter's type.
	Applications may request a specific protocol when creating a socket, or
	may allow the system to select a protocol that is appropriate for the type
	of socket being created.</p><p>Sockets may have addresses bound to them.
	The form and meaning of socket addresses are dependent on the
	communication domain in which the socket is created.
	Binding a name to a socket in the
	local domain causes a file to be created in the filesystem.</p><p>Normal data transmitted and received through sockets are untyped.
	Data-representation issues are the responsibility of libraries built
	on top of the interprocess-communication facilities.
	In addition to transporting normal data, communication domains may
	support the transmission and reception of specially typed data, termed
	<span class="emphasis"><em>access rights</em></span>.
	The local domain, for example,
	uses this facility to pass descriptors between processes.</p><p>Networking implementations on UNIX before 4.2BSD
	usually worked by overloading the character-device interfaces.
	One goal of the socket interface was for naive
	programs to be able to work without change on stream-style connections.
	Such programs can work only if the
	<span class="emphasis"><em>read</em></span>
	and
	<span class="emphasis"><em>write</em></span>
	systems calls are unchanged.
	Consequently, the original interfaces were left intact,
	and were made to work on stream-type sockets.
	A new interface was added for more complicated sockets,
	such as those used to send datagrams, with which a destination address
	must be presented with each
	<span class="emphasis"><em>send</em></span>
	call.</p><p>Another benefit is that the new interface is highly portable.
	Shortly after a test release was available from Berkeley,
	the socket interface had been ported to System III
	by a UNIX vendor
	(although AT&amp;T did not support the socket interface
	until the release of System V Release 4,
	deciding instead to use the
	Eighth Edition stream mechanism).
	The socket interface was also ported to run in many
	Ethernet boards by vendors, such as Excelan and Interlan, that were
	selling into the PC market, where the machines were
	too small to run networking in the main processor.
	More recently, the socket interface was used as the basis for
	Microsoft's Winsock networking interface for Windows.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-network-communication"></a>2.12. Network Communication</h2></div></div></div><p>Some of the communication domains supported by the
	<span class="emphasis"><em>socket</em></span>
	IPC
	mechanism provide access to network protocols.
	These protocols are implemented as a separate software
	layer logically below the socket software in the kernel.
	The kernel provides many ancillary services, such as
    buffer management, message routing, standardized interfaces
    to the protocols, and interfaces to the network interface drivers
    for the use of the various network protocols.</p><p>At the time that 4.2BSD was being implemented,
    there were many networking protocols in use or under development,
    each with its own strengths and weaknesses.
    There was no clearly superior protocol or protocol suite.
    By supporting multiple protocols, 4.2BSD
    could provide interoperability and resource sharing
    among the diverse set of machines that was available
    in the Berkeley environment.
    Multiple-protocol support also provides for future changes.
    Today's protocols designed for 10- to 100-Mbit-per-second
    Ethernets are likely to be inadequate for
    tomorrow's 1- to 10-Gbit-per-second fiber-optic networks.
    Consequently, the network-communication layer is
    designed to support multiple protocols.
    New protocols are added to the kernel without
    the support for older protocols being affected.
    Older applications can continue to operate using the old protocol
    over the same physical network as is used by newer applications
    running with a newer network protocol.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-network-implementation"></a>2.13. Network Implementation</h2></div></div></div><p>The first protocol suite implemented in 4.2BSD was
    DARPA's
    Transmission Control Protocol/Internet Protocol
    (TCP/IP).
    The
    CSRG
    chose
    TCP/IP
    as the first network to incorporate into the socket
    IPC
    framework,
    because a 4.1BSD-based implementation was publicly available from a
    DARPA-sponsored
    project at Bolt, Beranek, and Newman
    (BBN).
    That was an influential choice:
    The 4.2BSD implementation
    is the main reason for the extremely widespread use of this protocol suite.
    Later performance and capability improvements to the
    TCP/IP
    implementation have also been widely adopted.
    The
    TCP/IP
    implementation is described in detail in
    Chapter 13.</p><p>The release of 4.3BSD added the Xerox Network Systems
    (XNS)
    protocol suite,
    partly building on work done at the
    University of Maryland and at
    Cornell University.
    This suite was needed to connect
    isolated machines that could not communicate using
    TCP/IP.</p><p>The release of 4.4BSD added the
    ISO
    protocol suite because of the latter's increasing
    visibility both within and outside the United States.
    Because of the somewhat different semantics defined for the
    ISO
    protocols, some minor changes were required in the socket interface
    to accommodate these semantics.
    The changes were made such that they were invisible to clients
    of other existing protocols.
    The
    ISO
    protocols also required extensive addition to the two-level routing
    tables provided by the kernel in 4.3BSD.
    The greatly expanded routing capabilities of 4.4BSD include
    arbitrary levels of routing with variable-length addresses and
    network masks.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-operation"></a>2.14. System Operation</h2></div></div></div><p>Bootstrapping mechanisms are used to start the system running.
    First, the 4.4BSD
    kernel must be loaded into the main memory of the processor.
    Once loaded, it must go through an initialization phase to
    set the hardware into a known state.
    Next, the kernel must do
    autoconfiguration, a process that finds
    and configures the peripherals that are attached to the processor.
    The system begins running in single-user mode while a start-up script does
    disk checks and starts the accounting and quota checking.
    Finally, the start-up script starts the general system services
    and brings up
    the system to full multiuser operation.</p><p>During multiuser operation, processes wait for login requests
    on the terminal lines and network ports that have been configured
    for user access.
    When a login request is detected,
    a login process is spawned and user validation is done.
    When the login validation is successful, a
    login shell is created from which
    the user can run additional processes.</p></div><div class="bibliography"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="references"></a>References</h2></div></div></div><div class="biblioentry"><a id="biblio-accetta"></a><p>[<abbr class="abbrev">Accetta et al, 1986</abbr>] <span class="biblioset">&#8220;Mach: A New Kernel Foundation for UNIX Development"&#8221;. <span class="authorgroup"><span class="firstname">M. </span> <span class="surname">Accetta</span>, <span class="firstname">R.</span> <span class="surname">Baron</span>, <span class="firstname">W.</span> <span class="surname">Bolosky</span>, <span class="firstname">D.</span> <span class="surname">Golub</span>, <span class="firstname">R.</span> <span class="surname">Rashid</span>, <span class="firstname">A.</span> <span class="surname">Tevanian</span>, and <span class="firstname">M.</span> <span class="surname">Young</span>. </span><span class="pagenums">93-113. </span></span><span class="biblioset"><em>USENIX Association Conference Proceedings</em>. <span class="publishername">USENIX Association. </span><span class="pubdate">June 1986. </span></span></p></div><div class="biblioentry"><a id="biblio-cheriton"></a><p>[<abbr class="abbrev">Cheriton, 1988</abbr>] <span class="biblioset">&#8220;The V Distributed System&#8221;. <span class="author"><span class="firstname">D. R.</span> <span class="surname">Cheriton</span>. </span><span class="pagenums">314-333. </span></span><span class="biblioset"><em>Comm ACM, 31, 3</em>. <span class="pubdate">March 1988. </span></span></p></div><div class="biblioentry"><a id="biblio-ewens"></a><p>[<abbr class="abbrev">Ewens et al, 1985</abbr>] <span class="biblioset">&#8220;Tunis: A Distributed Multiprocessor Operating System&#8221;. <span class="authorgroup"><span class="firstname">P.</span> <span class="surname">Ewens</span>, <span class="firstname">D. R.</span> <span class="surname">Blythe</span>, <span class="firstname">M.</span> <span class="surname">Funkenhauser</span>, and <span class="firstname">R. C.</span> <span class="surname">Holt</span>. </span><span class="pagenums">247-254. </span></span><span class="biblioset"><em>USENIX Assocation Conference Proceedings</em>. <span class="publishername">USENIX Association. </span><span class="pubdate">June 1985. </span></span></p></div><div class="biblioentry"><a id="biblio-gingell"></a><p>[<abbr class="abbrev">Gingell et al, 1987</abbr>] <span class="biblioset">&#8220;Virtual Memory Architecture in SunOS&#8221;. <span class="authorgroup"><span class="firstname">R.</span> <span class="surname">Gingell</span>, <span class="firstname">J.</span> <span class="surname">Moran</span>, and <span class="firstname">W.</span> <span class="surname">Shannon</span>. </span><span class="pagenums">81-94. </span></span><span class="biblioset"><em>USENIX Association Conference Proceedings</em>. <span class="publishername">USENIX Association. </span><span class="pubdate">June 1987. </span></span></p></div><div class="biblioentry"><a id="biblio-kernighan"></a><p>[<abbr class="abbrev">Kernighan &amp; Pike, 1984</abbr>] <span class="citetitle"><em class="citetitle">The UNIX Programming Environment</em>. </span><span class="authorgroup"><span class="firstname">B. W.</span> <span class="surname">Kernighan</span> and <span class="firstname">R.</span> <span class="surname">Pike</span>. </span><span class="publisher"><span class="publishername">Prentice-Hall. </span><span class="address">
	  <span class="city">Englewood Cliffs</span>
	  <span class="state">NJ</span>
	. </span></span><span class="pubdate">1984. </span></p></div><div class="biblioentry"><a id="biblio-macklem"></a><p>[<abbr class="abbrev">Macklem, 1994</abbr>] <span class="biblioset"><em>The 4.4BSD NFS Implementation</em>. <span class="author"><span class="firstname">R.</span> <span class="surname">Macklem</span>. </span><span class="pagenums">6:1-14. </span></span><span class="biblioset"><em>4.4BSD System Manager's Manual</em>. <span class="publisher"><span class="publishername">O'Reilly &amp; Associates, Inc.. </span><span class="address">
	    <span class="city">Sebastopol</span>
	    <span class="state">CA</span>
	  . </span></span><span class="pubdate">1994. </span></span></p></div><div class="biblioentry"><a id="biblio-mckusick-2"></a><p>[<abbr class="abbrev">McKusick &amp; Karels, 1988</abbr>] <span class="biblioset">&#8220;Design of a General Purpose Memory Allocator for the 4.3BSD
	  UNIX Kernel&#8221;. <span class="authorgroup"><span class="firstname">M. K.</span> <span class="surname">McKusick</span> and <span class="firstname">M. J.</span> <span class="surname">Karels</span>. </span><span class="pagenums">295-304. </span></span><span class="biblioset"><em>USENIX Assocation Conference Proceedings</em>. <span class="publishername">USENIX Assocation. </span><span class="pubdate">June 1998. </span></span></p></div><div class="biblioentry"><a id="biblio-mckusick-1"></a><p>[<abbr class="abbrev">McKusick et al, 1994</abbr>] <span class="biblioset"><em>Berkeley Software Architecture Manual, 4.4BSD Edition</em>. <span class="authorgroup"><span class="firstname">M. K.</span> <span class="surname">McKusick</span>, <span class="firstname">M. J.</span> <span class="surname">Karels</span>, <span class="firstname">S. J.</span> <span class="surname">Leffler</span>, <span class="firstname">W. N.</span> <span class="surname">Joy</span>, and <span class="firstname">R. S.</span> <span class="surname">Faber</span>. </span><span class="pagenums">5:1-42. </span></span><span class="biblioset"><em>4.4BSD Programmer's Supplementary Documents</em>. <span class="publisher"><span class="publishername">O'Reilly &amp; Associates, Inc.. </span><span class="address">
	    <span class="city">Sebastopol</span>
	    <span class="state">CA</span>
	  . </span></span><span class="pubdate">1994. </span></span></p></div><div class="biblioentry"><a id="biblio-ritchie"></a><p>[<abbr class="abbrev">Ritchie, 1988</abbr>] <span class="citetitle"><em class="citetitle">Early Kernel Design</em>. </span><span class="subtitle">private communication. </span><span class="author"><span class="firstname">D. M.</span> <span class="surname">Ritchie</span>. </span><span class="pubdate">March 1988. </span></p></div><div class="biblioentry"><a id="biblio-rosenblum"></a><p>[<abbr class="abbrev">Rosenblum &amp; Ousterhout, 1992</abbr>] <span class="biblioset">&#8220;The Design and Implementation of a Log-Structured File
	  System&#8221;. <span class="authorgroup"><span class="firstname">M.</span> <span class="surname">Rosenblum</span> and <span class="firstname">K.</span> <span class="surname">Ousterhout</span>. </span><span class="pagenums">26-52. </span></span><span class="biblioset"><em>ACM Transactions on Computer Systems, 10, 1</em>. <span class="publishername">Association for Computing Machinery. </span><span class="pubdate">February 1992. </span></span></p></div><div class="biblioentry"><a id="biblio-rozier"></a><p>[<abbr class="abbrev">Rozier et al, 1988</abbr>] <span class="biblioset">&#8220;Chorus Distributed Operating Systems&#8221;. <span class="authorgroup"><span class="firstname">M.</span> <span class="surname">Rozier</span>, <span class="firstname">V.</span> <span class="surname">Abrossimov</span>, <span class="firstname">F.</span> <span class="surname">Armand</span>, <span class="firstname">I.</span> <span class="surname">Boule</span>, <span class="firstname">M.</span> <span class="surname">Gien</span>, <span class="firstname">M.</span> <span class="surname">Guillemont</span>, <span class="firstname">F.</span> <span class="surname">Herrmann</span>, <span class="firstname">C.</span> <span class="surname">Kaiser</span>, <span class="firstname">S.</span> <span class="surname">Langlois</span>, <span class="firstname">P.</span> <span class="surname">Leonard</span>, and <span class="firstname">W.</span> <span class="surname">Neuhauser</span>. </span><span class="pagenums">305-370. </span></span><span class="biblioset"><em>USENIX Computing Systems, 1, 4</em>. <span class="pubdate">Fall 1988. </span></span></p></div><div class="biblioentry"><a id="biblio-tevanian"></a><p>[<abbr class="abbrev">Tevanian, 1987</abbr>] <span class="citetitle"><em class="citetitle">Architecture-Independent Virtual Memory Management for Parallel
	and Distributed Environments: The Mach Approach</em>. </span><span class="subtitle">Technical Report CMU-CS-88-106,. </span><span class="author"><span class="firstname">A.</span> <span class="surname">Tevanian</span>. </span><span class="publisher"><span class="publishername">Department of Computer Science, Carnegie-Mellon
	  University. </span><span class="address">
	  <span class="city">Pittsburgh</span>
	  <span class="state">PA</span>
	. </span></span><span class="pubdate">December 1987. </span></p></div></div></div></div></body></html>