<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>2.6. I/O System</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="The Design and Implementation of the 4.4BSD Operating System" /><link rel="up" href="overview.html" title="Chapter 2. Design Overview of 4.4BSD" /><link rel="prev" href="overview-memory-management.html" title="2.5. Memory Management" /><link rel="next" href="overview-filesystem.html" title="2.7. Filesystems" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.6. I/O System</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overview-memory-management.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Design Overview of 4.4BSD</th><td width="20%" align="right"> <a accesskey="n" href="overview-filesystem.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-io-system"></a>2.6. I/O System</h2></div></div></div><p>The basic model of the UNIX
	I/O system is a sequence of bytes
	that can be accessed either randomly or sequentially.
	There are no
	<span class="emphasis"><em>access methods</em></span>
	and no
	<span class="emphasis"><em>control blocks</em></span>
	in a typical UNIX user process.</p><p>Different programs expect various levels of structure,
	but the kernel does not impose structure on I/O.
	For instance, the convention for text files is lines of
	ASCII
	characters separated by a single newline character
	(the
	ASCII
	line-feed character),
	but the kernel knows nothing about this convention.
	For the purposes of most programs,
	the model is further simplified to being a stream of data bytes,
	or an
	<span class="emphasis"><em>I/O stream</em></span>.
	It is this single common data form that makes the
	characteristic UNIX tool-based approach work
	<a class="xref" href="overview.html#biblio-kernighan">[<abbr class="abbrev">Kernighan &amp; Pike, 1984</abbr>]</a>.
	An I/O stream from one program can be fed as input
	to almost any other program.
	(This kind of traditional UNIX
	I/O stream should not be confused with the
	Eighth Edition stream I/O system or with the
	System V, Release 3
	STREAMS,
	both of which can be accessed as traditional I/O streams.)</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47382136"></a>2.6.1. Descriptors and I/O</h3></div></div></div><p>UNIX processes use
	  <span class="emphasis"><em>descriptors</em></span>
	  to reference I/O streams.
	  Descriptors are small unsigned integers obtained from the
	  <span class="emphasis"><em>open</em></span>
	  and
	  <span class="emphasis"><em>socket</em></span>
	  system calls.
	  The
	  <span class="emphasis"><em>open</em></span>
	  system call takes as arguments the name of a file and
	  a permission mode to
	  specify whether the file should be open for reading or for writing,
	  or for both.
	  This system call also can be used to create a new, empty file.
	  A
	  <span class="emphasis"><em>read</em></span>
	  or
	  <span class="emphasis"><em>write</em></span>
	  system call can be applied to a descriptor to transfer data.
	  The
	  <span class="emphasis"><em>close</em></span>
	  system call can be used to deallocate any descriptor.</p><p>Descriptors represent underlying objects supported by the kernel,
	  and are created by system calls specific to the type of object.
	  In 4.4BSD, three kinds of objects can be represented by descriptors:
	  files, pipes, and sockets.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A
	      <span class="emphasis"><em>file</em></span>
	      is a linear array of bytes with at least one name.
	      A file exists until all its names are deleted explicitly
	      and no process holds a descriptor for it.
	      A process acquires a descriptor for a file
	      by opening that file's name with the
	      <span class="emphasis"><em>open</em></span>
	      system call.
	      I/O devices are accessed as files.</p></li><li class="listitem"><p>A
	      <span class="emphasis"><em>pipe</em></span>
	      is a linear array of bytes, as is a file, but it is used solely
	      as an I/O stream, and it is unidirectional.
	      It also has no name,
	      and thus cannot be opened with
	      <span class="emphasis"><em>open</em></span>.
	      Instead, it is created by the
	      <span class="emphasis"><em>pipe</em></span>
	      system call, which returns two descriptors,
	      one of which accepts input that is sent to the other descriptor reliably,
	      without duplication, and in order.
	      The system also supports a named pipe or
	      FIFO.
	      A
	      FIFO
	      has properties identical to a pipe, except that it appears
	      in the filesystem;
	      thus, it can be opened using the
	      <span class="emphasis"><em>open</em></span>
	      system call.
	      Two processes that wish to communicate each open the
	      FIFO:
	      One opens it for reading, the other for writing.</p></li><li class="listitem"><p>A
	      <span class="emphasis"><em>socket</em></span>
	      is a transient object that is used for
	      interprocess communication;
	      it exists only as long as some process holds a descriptor
	      referring to it.
	      A socket is created by the
	      <span class="emphasis"><em>socket</em></span>
	      system call, which returns a descriptor for it.
	      There are different kinds of sockets that support various communication
	      semantics, such as reliable delivery of data, preservation of
	      message ordering, and preservation of message boundaries.</p></li></ul></div><p>In systems before 4.2BSD, pipes were implemented using the filesystem;
	  when sockets were introduced in 4.2BSD,
	  pipes were reimplemented as sockets.</p><p>The kernel keeps for each process a
	  <span class="emphasis"><em>descriptor table</em></span>,
	  which is a table that the kernel uses
	  to translate the external representation
	  of a descriptor into an internal representation.
	  (The descriptor is merely an index into this table.)
	  The descriptor table of a process is inherited from that process's parent,
	  and thus access to the objects
	  to which the descriptors refer also is inherited.
	  The main ways that a process can obtain a descriptor are by
	  opening or creation of an object,
	  and by inheritance from the parent process.
	  In addition, socket
	  IPC
	  allows passing of descriptors in messages between unrelated processes
	  on the same machine.</p><p>Every valid descriptor has an associated
	  <span class="emphasis"><em>file offset</em></span>
	  in bytes from the beginning of the object.
	  Read and write operations start at this offset, which is
	  updated after each data transfer.
	  For objects that permit random access,
	  the file offset also may be set with the
	  <span class="emphasis"><em>lseek</em></span>
	  system call.
	  Ordinary files permit random access, and some devices do, as well.
	  Pipes and sockets do not.</p><p>When a process terminates, the kernel
	  reclaims all the descriptors that were in use by that process.
	  If the process was holding the final reference to an object,
	  the object's manager is notified so that it can do any
	  necessary cleanup actions, such as final deletion of a file
	  or deallocation of a socket.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47423352"></a>2.6.2. Descriptor Management</h3></div></div></div><p>Most processes expect three descriptors to be open already
	  when they start running.
	  These descriptors are 0, 1, 2, more commonly known as
	  <span class="emphasis"><em>standard input</em></span>,
	  <span class="emphasis"><em>standard output</em></span>,
	  and
	  <span class="emphasis"><em>standard error</em></span>,
	  respectively.
	  Usually, all three are associated with the user's terminal
	  by the login process
	  (see
	  Section 14.6)
	  and are inherited through
	  <span class="emphasis"><em>fork</em></span>
	  and
	  <span class="emphasis"><em>exec</em></span>
	  by processes run by the user.
	  Thus, a program can read what the user types by reading standard
	  input, and the program can send output to the user's screen by
	  writing to standard output.
	  The standard error descriptor also is open for writing and is
	  used for error output, whereas standard output is used for ordinary output.</p><p>These (and other) descriptors can be mapped to objects other than
	  the terminal;
	  such mapping is called
	  <span class="emphasis"><em>I/O redirection</em></span>,
	  and all the standard shells permit users to do it.
	  The shell can direct the output of a program to a file
	  by closing descriptor 1 (standard output) and opening
	  the desired output file to produce a new descriptor 1.
	  It can similarly redirect standard input to come from a file
	  by closing descriptor 0 and opening the file.</p><p>Pipes allow the output of one program to be input to another program
	  without rewriting or even relinking of either program.
	  Instead of descriptor 1 (standard output)
	  of the source program being set up to write to the terminal,
	  it is set up to be the input descriptor of a pipe.
	  Similarly, descriptor 0 (standard input)
	  of the sink program is set up to reference the output of the pipe,
	  instead of the terminal keyboard.
	  The resulting set of two processes and the connecting pipe is known as a
	  <span class="emphasis"><em>pipeline</em></span>.
	  Pipelines can be arbitrarily long series of processes connected by pipes.</p><p>The
	  <span class="emphasis"><em>open</em></span>,
	  <span class="emphasis"><em>pipe</em></span>,
	  and
	  <span class="emphasis"><em>socket</em></span>
	  system calls produce new descriptors with the lowest unused number
	  usable for a descriptor.
	  For pipelines to work,
	  some mechanism must be provided to map such descriptors into 0 and 1.
	  The
	  <span class="emphasis"><em>dup</em></span>
	  system call creates a copy of a descriptor that
	  points to the same file-table entry.
	  The new descriptor is also the lowest unused one,
	  but if the desired descriptor is closed first,
	  <span class="emphasis"><em>dup</em></span>
	  can be used to do the desired mapping.
	  Care is required, however: If descriptor 1 is desired,
	  and descriptor 0 happens also to have been closed, descriptor 0
	  will be the result.
	  To avoid this problem, the system provides the
	  <span class="emphasis"><em>dup2</em></span>
	  system call;
	  it is like
	  <span class="emphasis"><em>dup</em></span>,
	  but it takes an additional argument specifying
	  the number of the desired descriptor
	  (if the desired descriptor was already open,
	  <span class="emphasis"><em>dup2</em></span>
	  closes it before reusing it).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47443320"></a>2.6.3. Devices</h3></div></div></div><p>Hardware devices have filenames, and may be
	  accessed by the user via the same system calls used for regular files.
	  The kernel can distinguish a
	  <span class="emphasis"><em>device special file</em></span>
	  or
	  <span class="emphasis"><em>special file</em></span>,
	  and can determine to what device it refers,
	  but most processes do not need to make this determination.
	  Terminals, printers, and tape drives are all accessed as though they
	  were streams of bytes, like 4.4BSD disk files.
	  Thus, device dependencies and peculiarities are kept in the kernel
	  as much as possible, and even in the kernel most of them are segregated
	  in the device drivers.</p><p>Hardware devices can be categorized as either
	  <span class="emphasis"><em>structured</em></span>
	  or
	  <span class="emphasis"><em>unstructured</em></span>;
	  they are known as
	  <span class="emphasis"><em>block</em></span>
	  or
	  <span class="emphasis"><em>character</em></span>
	  devices, respectively.
	  Processes typically access devices through
	  <span class="emphasis"><em>special files</em></span>
	  in the filesystem.
	  I/O operations to these files are handled by
	  kernel-resident software modules termed
	  <span class="emphasis"><em>device drivers</em></span>.
	  Most network-communication hardware devices are accessible through only
	  the interprocess-communication facilities,
	  and do not have special files in the filesystem name space,
	  because the
	  <span class="emphasis"><em>raw-socket</em></span>
	  interface provides a more natural interface than does a special file.</p><p>Structured or block devices are typified by disks and magnetic tapes,
	  and include most random-access devices.
	  The kernel supports read-modify-write-type buffering actions
	  on block-oriented structured devices to allow the latter
	  to be read and written in a
	  totally random byte-addressed fashion, like regular files.
	  Filesystems are created on block devices.</p><p>Unstructured devices are those devices that do not support a block
	  structure.
	  Familiar unstructured devices are communication lines, raster
	  plotters, and unbuffered magnetic tapes and disks.
	  Unstructured devices typically support large block I/O transfers.</p><p>Unstructured files are called
	  <span class="emphasis"><em>character devices</em></span>
	  because the first of these to be implemented were terminal device drivers.
	  The kernel interface to the driver for these devices proved convenient
	  for other devices that were not block structured.</p><p>Device special files are created by the
	  <span class="emphasis"><em>mknod</em></span>
	  system call.
	  There is an additional system call,
	  <span class="emphasis"><em>ioctl</em></span>,
	  for manipulating the underlying device parameters of special files.
	  The operations that can be done differ for each device.
	  This system call allows the special characteristics of devices to
	  be accessed, rather than overloading the semantics of other system calls.
	  For example, there is an
	  <span class="emphasis"><em>ioctl</em></span>
	  on a tape drive to write an end-of-tape mark,
	  instead of there being a special or modified version of
	  <span class="emphasis"><em>write</em></span>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47483000"></a>2.6.4. Socket IPC</h3></div></div></div><p>The 4.2BSD kernel introduced an
	  IPC
	  mechanism more flexible than pipes, based on
	  <span class="emphasis"><em>sockets</em></span>.
	  A socket is an endpoint of communication referred to by
	  a descriptor, just like a file or a pipe.
	  Two processes can each create a socket, and then connect those
	  two endpoints to produce a reliable byte stream.
	  Once connected, the descriptors for the sockets can be read or written
	  by processes, just as the latter would do with a pipe.
	  The transparency of sockets allows the kernel to redirect the output
	  of one process to the input of another process residing on another machine.
	  A major difference between pipes and sockets is that
	  pipes require a common parent process to set up the
	  communications channel.
	  A connection between sockets can be set up by two unrelated processes,
	  possibly residing on different machines.</p><p>System V provides local interprocess communication through
	  FIFOs
	  (also known as
	  <span class="emphasis"><em>named pipes</em></span>).
	  FIFOs
	  appear as an object in the filesystem that unrelated
	  processes can open and send data through in the same
	  way as they would communicate through a pipe.
	  Thus,
	  FIFOs
	  do not require a common parent to set them up;
	  they can be connected after a pair of processes are up and running.
	  Unlike sockets,
	  FIFOs
	  can be used on only a local machine;
	  they cannot be used to communicate between processes on different machines.
	  FIFOs
	  are implemented in 4.4BSD only because they are required by the
	  POSIX.1
	  standard.
	  Their functionality is a subset of the socket interface.</p><p>The socket mechanism requires extensions to the traditional UNIX
	  I/O system calls to provide the associated naming and connection semantics.
	  Rather than overloading the existing interface,
	  the developers used the existing interfaces to the extent that
	  the latter worked without being changed,
	  and designed new interfaces to handle the added semantics.
	  The
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  system calls were used for byte-stream type connections,
	  but six new system calls were added
	  to allow sending and receiving addressed messages
	  such as network datagrams.
	  The system calls for writing messages include
	  <span class="emphasis"><em>send</em></span>,
	  <span class="emphasis"><em>sendto</em></span>,
	  and
	  <span class="emphasis"><em>sendmsg</em></span>.
	  The system calls for reading messages include
	  <span class="emphasis"><em>recv</em></span>,
	  <span class="emphasis"><em>recvfrom</em></span>,
	  and
	  <span class="emphasis"><em>recvmsg</em></span>.
	  In retrospect, the first two in each class are special cases of the others;
	  <span class="emphasis"><em>recvfrom</em></span>
	  and
	  <span class="emphasis"><em>sendto</em></span>
	  probably should have been added as library interfaces to
	  <span class="emphasis"><em>recvmsg</em></span>
	  and
	  <span class="emphasis"><em>sendmsg</em></span>,
	  respectively.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47503224"></a>2.6.5. Scatter/Gather I/O</h3></div></div></div><p>In addition to the traditional
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  system calls, 4.2BSD introduced the ability to do scatter/gather I/O.
	  Scatter input uses the
	  <span class="emphasis"><em>readv</em></span>
	  system call to allow a single read
	  to be placed in several different buffers.
	  Conversely, the
	  <span class="emphasis"><em>writev</em></span>
	  system call allows several different buffers
	  to be written in a single atomic write.
	  Instead of passing a single buffer and length parameter, as is done with
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>,
	  the process passes in a pointer to an array of buffers and lengths,
	  along with a count describing the size of the array.</p><p>This facility allows buffers in different parts of a process
	  address space to be written atomically, without the
	  need to copy them to a single contiguous buffer.
	  Atomic writes are necessary in the case where the underlying
	  abstraction is record based, such as tape drives that output a
	  tape block on each write request.
	  It is also convenient to be able to read a single request into
	  several different buffers (such as a record header into one place
	  and the data into another).
	  Although an application can simulate the ability to scatter data
	  by reading the data into a large buffer and then copying the pieces
	  to their intended destinations,
	  the cost of memory-to-memory copying in such cases often
	  would more than double the running time of the affected application.</p><p>Just as
	  <span class="emphasis"><em>send</em></span>
	  and
	  <span class="emphasis"><em>recv</em></span>
	  could have been implemented as library interfaces to
	  <span class="emphasis"><em>sendto</em></span>
	  and
	  <span class="emphasis"><em>recvfrom</em></span>,
	  it also would have been possible to simulate
	  <span class="emphasis"><em>read</em></span>
	  with
	  <span class="emphasis"><em>readv</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  with
	  <span class="emphasis"><em>writev</em></span>.
	  However,
	  <span class="emphasis"><em>read</em></span>
	  and
	  <span class="emphasis"><em>write</em></span>
	  are used so much more frequently that the added cost
	  of simulating them would not have been worthwhile.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp47534584"></a>2.6.6. Multiple Filesystem Support</h3></div></div></div><p>With the expansion of network computing,
	  it became desirable to support both local and remote filesystems.
	  To simplify the support of multiple filesystems,
	  the developers added a new virtual node or
	  <span class="emphasis"><em>vnode</em></span>
	  interface to the kernel.
	  The set of operations exported from the vnode interface
	  appear much like the filesystem operations previously supported
	  by the local filesystem.
	  However, they may be supported by a wide range of filesystem types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Local disk-based filesystems</p></li><li class="listitem"><p>Files imported using a variety of remote filesystem protocols</p></li><li class="listitem"><p>Read-only
	      CD-ROM
	      filesystems</p></li><li class="listitem"><p>Filesystems providing special-purpose interfaces -- for example, the
	      <code class="filename">/proc</code>
	      filesystem</p></li></ul></div><p>A few variants of 4.4BSD, such as FreeBSD,
	  allow filesystems to be loaded dynamically
	  when the filesystems are first referenced by the
	  <span class="emphasis"><em>mount</em></span>
	  system call.
	  The vnode interface is described in
	  Section 6.5;
	  its ancillary support routines are described in
	  Section 6.6;
	  several of the special-purpose filesystems are described in
	  Section 6.7.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview-memory-management.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="overview-filesystem.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.5. Memory Management </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2.7. Filesystems</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>