<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>2.7. Filesystems</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="The Design and Implementation of the 4.4BSD Operating System" /><link rel="up" href="overview.html" title="Chapter 2. Design Overview of 4.4BSD" /><link rel="prev" href="overview-io-system.html" title="2.6. I/O System" /><link rel="next" href="overview-filestore.html" title="2.8. Filestores" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.7. Filesystems</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overview-io-system.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Design Overview of 4.4BSD</th><td width="20%" align="right"> <a accesskey="n" href="overview-filestore.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="overview-filesystem"></a>2.7. Filesystems</h2></div></div></div><p>A regular file is a linear array of bytes,
    and can be read and written starting at any byte in the file.
    The kernel distinguishes no record boundaries in regular files, although
    many programs recognize line-feed characters as distinguishing
    the ends of lines, and other programs may impose other structure.
    No system-related information about a file is kept in the file itself,
    but the filesystem stores a small amount of ownership, protection,
    and usage information with each file.</p><p>A
    <span class="emphasis"><em>filename</em></span>
    component is a string of up to 255 characters.
    These filenames are stored in a type of file called a
    <span class="emphasis"><em>directory</em></span>.
    The information in a directory about a file is called a
    <span class="emphasis"><em>directory entry</em></span>
    and includes, in addition to the filename,
    a pointer to the file itself.
    Directory entries may refer to other directories, as well as to plain files.
    A hierarchy of directories and files is thus formed, and is called a
    <span class="emphasis"><em>filesystem</em></span>;</p><div class="figure"><a id="fig-small-fs"></a><div class="figure-title">Figure 2.2. A small filesystem</div><div class="figure-contents"><div class="mediaobject"><img src="fig2.png" alt="A small filesystem tree" /></div></div></div><br class="figure-break" /><p>a small one is shown in <a class="xref" href="overview-filesystem.html#fig-small-fs" title="Figure 2.2. A small filesystem">Figure 2.2, &#8220;A small filesystem&#8221;</a>.
    Directories may contain subdirectories, and there is no inherent
    limitation to the depth with which directory nesting may occur.
    To protect the consistency of the filesystem, the kernel
    does not permit processes to write directly into directories.
    A filesystem may include not only plain files and directories,
    but also references to other objects, such as devices and sockets.</p><p>The filesystem forms a tree, the beginning of which is the
    <span class="emphasis"><em>root directory</em></span>,
    sometimes referred to by the name
    <span class="emphasis"><em>slash</em></span>,
    spelled with a single solidus character (/).
    The root directory contains files; in our example in Fig 2.2, it contains
    <code class="filename">vmunix</code>,
    a copy of the kernel-executable object file.
    It also contains directories; in this example, it contains the
    <code class="filename">usr</code>
    directory.
    Within the
    <code class="filename">usr</code>
    directory is the
    <code class="filename">bin</code>
    directory, which mostly contains executable object code of programs,
    such as the files
      
    <code class="filename">ls</code>
    and
    <code class="filename">vi</code>.</p><p>A process identifies a file by specifying that file's
    <span class="emphasis"><em>pathname</em></span>,
    which is a string composed of zero or more
    filenames separated by slash (/) characters.
    The kernel associates two directories with each process for use
    in interpreting pathnames.
    A process's
    <span class="emphasis"><em>root directory</em></span>
    is the topmost point in the filesystem that the process can access;
    it is ordinarily set to the root directory of the entire filesystem.
    A pathname beginning with a slash is called an
    <span class="emphasis"><em>absolute pathname</em></span>,
    and is interpreted by the kernel starting with the process's root directory.</p><p>A pathname that does not begin with a slash is called a
    <span class="emphasis"><em>relative pathname</em></span>,
    and is interpreted relative to the
    <span class="emphasis"><em>current working directory</em></span>
    of the process.
    (This directory also is known by the shorter names
    <span class="emphasis"><em>current directory</em></span>
    or
    <span class="emphasis"><em>working directory</em></span>.)
    The current directory itself may be referred to directly by the name
    <span class="emphasis"><em>dot</em></span>,
    spelled with a single period
    (<code class="filename">.</code>).
    The filename
    <span class="emphasis"><em>dot-dot</em></span>
    (<code class="filename">..</code>)
    refers to a directory's parent directory.
    The root directory is its own parent.</p><p>A process may set its root directory with the
    <span class="emphasis"><em>chroot</em></span>
    system call,
    and its current directory with the
    <span class="emphasis"><em>chdir</em></span>
    system call.
    Any process may do
    <span class="emphasis"><em>chdir</em></span>
    at any time, but
    <span class="emphasis"><em>chroot</em></span>
    is permitted only a process with superuser privileges.
    <span class="emphasis"><em>Chroot</em></span>
    is normally used to set up restricted access to the system.</p><p>Using the filesystem shown in Fig. 2.2,
    if a process has the root of the filesystem as its root directory, and has
    <code class="filename">/usr</code>
    as its current directory, it can refer to the file
    <code class="filename">vi</code>
    either from the root with the absolute pathname
    <code class="filename">/usr/bin/vi</code>,
    or from its current directory with the relative pathname
    <code class="filename">bin/vi</code>.</p><p>System utilities and databases are kept in certain well-known directories.
    Part of the well-defined hierarchy includes a directory that contains the
    <span class="emphasis"><em>home directory</em></span>
    for each user -- for example,
    <code class="filename">/usr/staff/mckusick</code>
    and
    <code class="filename">/usr/staff/karels</code>
    in Fig. 2.2.
    When users log in,
    the current working directory of their shell is set to the
    home directory.
    Within their home directories,
    users can create directories as easily as they can regular files.
    Thus, a user can build arbitrarily complex subhierarchies.</p><p>The user usually knows of only one filesystem, but the system may
    know that this one virtual filesystem
    is really composed of several physical
    filesystems, each on a different device.
    A physical filesystem may not span multiple hardware devices.
    Since most physical disk devices are divided into several logical devices,
    there may be more than one filesystem per physical device,
    but there will be no more than one per logical device.
    One filesystem -- the filesystem that
    anchors all absolute pathnames -- is called the
    <span class="emphasis"><em>root filesystem</em></span>,
    and is always available.
    Others may be mounted;
    that is, they may be integrated into the
    directory hierarchy of the root filesystem.
    References to a directory that has a filesystem mounted on it
    are converted transparently by the kernel
    into references to the root directory of the mounted filesystem.</p><p>The
    <span class="emphasis"><em>link</em></span>
    system call takes the name of an existing file and another name
    to create for that file.
    After a successful
    <span class="emphasis"><em>link</em></span>,
    the file can be accessed by either filename.
    A filename can be removed with the
    <span class="emphasis"><em>unlink</em></span>
    system call.
    When the final name for a file is removed (and the final process that
    has the file open closes it), the file is deleted.</p><p>Files are organized hierarchically in
    <span class="emphasis"><em>directories</em></span>.
    A directory is a type of file,
    but, in contrast to regular files,
    a directory has a structure imposed on it by the system.
    A process can read a directory as it would an ordinary file,
    but only the kernel is permitted to modify a directory.
    Directories are created by the
    <span class="emphasis"><em>mkdir</em></span>
    system call and are removed by the
    <span class="emphasis"><em>rmdir</em></span>
    system call.
    Before 4.2BSD, the
    <span class="emphasis"><em>mkdir</em></span>
    and
    <span class="emphasis"><em>rmdir</em></span>
    system calls were implemented by a series of
    <span class="emphasis"><em>link</em></span>
    and
    <span class="emphasis"><em>unlink</em></span>
    system calls being done.
    There were three reasons for adding systems calls
    explicitly to create and delete directories:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The operation could be made atomic.
      If the system crashed,
      the directory would not be left half-constructed,
      as could happen when a series of link operations were used.</p></li><li class="listitem"><p>When a
      networked filesystem is being run,
      the creation and deletion of files and directories need to be
      specified atomically so that they can be serialized.</p></li><li class="listitem"><p>When supporting non-UNIX filesystems, such as an
      MS-DOS
      filesystem, on another partition of the disk,
      the other filesystem may not support link operations.
      Although other filesystems might support the concept of directories,
      they probably would not create and delete the directories with links,
      as the UNIX filesystem does.
      Consequently, they could create and delete directories only
      if explicit directory create and delete requests were presented.</p></li></ol></div><p>The
    <span class="emphasis"><em>chown</em></span>
    system call sets the owner and group of a file, and
    <span class="emphasis"><em>chmod</em></span>
    changes protection attributes.
    <span class="emphasis"><em>Stat</em></span>
    applied to a filename can be used to read back such properties of a file.
    The
    <span class="emphasis"><em>fchown</em></span>,
    <span class="emphasis"><em>fchmod</em></span>,
    and
    <span class="emphasis"><em>fstat</em></span>
    system calls are applied to a descriptor, instead of
    to a filename, to do the same set of operations.
    The
    <span class="emphasis"><em>rename</em></span>
    system call can be used to give a file a new name in the filesystem,
    replacing one of the file's old names.
    Like the directory-creation and directory-deletion operations, the
    <span class="emphasis"><em>rename</em></span>
    system call was added to 4.2BSD
    to provide atomicity to name changes in the local filesystem.
    Later, it proved useful explicitly to
    export renaming operations to foreign filesystems and over the network.</p><p>The
    <span class="emphasis"><em>truncate</em></span>
    system call was added to 4.2BSD to allow files to be shortened
    to an arbitrary offset.
    The call was added primarily in support of the Fortran
    run-time library,
    which has the semantics such that the end of a random-access
    file is set to be wherever the program most recently accessed that file.
    Without the
    <span class="emphasis"><em>truncate</em></span>
    system call, the only way to shorten a file was to
    copy the part that was desired to a new file, to delete the old file,
    then to rename the copy to the original name.
    As well as this algorithm being slow,
    the library could potentially fail on a full filesystem.</p><p>Once the filesystem had the ability to shorten files,
    the kernel took advantage of that ability
    to shorten large empty directories.
    The advantage of shortening empty directories is that it reduces the
    time spent in the kernel searching them
    when names are being created or deleted.</p><p>Newly created files are assigned the user identifier of the process
    that created them and the group identifier of the directory
    in which they were created.
    A three-level access-control mechanism is provided for
    the protection of files.
    These three levels specify the accessibility of a file to</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The user who owns the file</p></li><li class="listitem"><p>The group that owns the file</p></li><li class="listitem"><p>Everyone else</p></li></ol></div><p>Each level of access has separate indicators for read permission,
    write permission, and execute permission.</p><p>Files are created with zero length, and may grow when they are written.
    While a file is open, the system maintains a pointer into
    the file indicating the current location in
    the file associated with the descriptor.
    This pointer can be moved about in the file in a random-access fashion.
    Processes sharing a file descriptor through a
    <span class="emphasis"><em>fork</em></span>
    or
    <span class="emphasis"><em>dup</em></span>
    system call share the current location pointer.
    Descriptors created by separate
    <span class="emphasis"><em>open</em></span>
    system calls have separate current location pointers.
    Files may have
    <span class="emphasis"><em>holes</em></span>
    in them.
    Holes are void areas in the linear extent of the file where data have
    never been written.
    A process can create these holes by positioning
    the pointer past the current end-of-file and writing.
    When read, holes are treated by the system as zero-valued bytes.</p><p>Earlier UNIX systems had a limit of 14 characters per filename component.
    This limitation was often a problem.
    For example,
    in addition to the natural desire of users
    to give files long descriptive names,
    a common way of forming filenames is as
      <code class="filename"><em class="replaceable"><code>basename</code></em>.<em class="replaceable"><code>extension</code></em></code>,
    where the extension (indicating the kind of file, such as
    <code class="literal">.c</code>
    for C source or
    <code class="literal">.o</code>
    for intermediate binary object)
    is one to three characters,
    leaving 10 to 12 characters for the basename.
    Source-code-control systems and editors usually take up another
    two characters, either as a prefix or a suffix, for their purposes,
    leaving eight to 10 characters.
    It is easy to use 10 or 12 characters in a single
    English word as a basename (e.g., ``multiplexer'').</p><p>It is possible to keep within these limits,
    but it is inconvenient or even dangerous, because other UNIX
    systems accept strings longer than the limit when creating files,
    but then
    <span class="emphasis"><em>truncate</em></span>
    to the limit.
    A C language source file named
    <code class="filename">multiplexer.c</code>
    (already 13 characters) might have a source-code-control file
    with
    <code class="literal">s.</code>
    prepended, producing a filename
    <code class="filename">s.multiplexer</code>
    that is indistinguishable from the source-code-control file for
    <code class="filename">multiplexer.ms</code>,
    a file containing
      
    <code class="literal">troff</code>
    source for documentation for the C program.
    The contents of the two original files could easily get confused
    with no warning from the source-code-control system.
    Careful coding can detect this problem, but the
    long filenames
    first introduced in 4.2BSD practically eliminate it.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview-io-system.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="overview-filestore.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.6. I/O System </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2.8. Filestores</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>