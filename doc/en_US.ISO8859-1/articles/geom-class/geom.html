<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>4. On GEOM Programming</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Writing a GEOM Class" /><link rel="up" href="index.html" title="Writing a GEOM Class" /><link rel="prev" href="kernelprog.html" title="3. On FreeBSD Kernel Programming" /><link rel="copyright" href="trademarks.html" title="Legal Notice" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. On GEOM Programming</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kernelprog.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="geom"></a>4. On GEOM Programming</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-ggate"></a>4.1. Ggate</h3></div></div></div><p>If maximum performance is not needed, a much simpler way
	of making a data transformation is to implement it in userland
	via the ggate (GEOM gate) facility.  Unfortunately, there is
	no easy way to convert between, or even share code between the
	two approaches.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-class"></a>4.2. GEOM Class</h3></div></div></div><p>GEOM classes are transformations on the data.  These
	transformations can be combined in a tree-like fashion.
	Instances of GEOM classes are called
	<span class="emphasis"><em>geoms</em></span>.</p><p>Each GEOM class has several <span class="quote">&#8220;<span class="quote">class methods</span>&#8221;</span>
	that get called when there is no geom instance available (or
	they are simply not bound to a single instance):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">.init</code> is called when GEOM becomes
	    aware of a GEOM class (when the kernel module gets
	    loaded.)</p></li><li class="listitem"><p><code class="function">.fini</code> gets called when GEOM
	    abandons the class (when the module gets
	    unloaded)</p></li><li class="listitem"><p><code class="function">.taste</code> is called next, once for
	    each provider the system has available.  If applicable,
	    this function will usually create and start a geom
	    instance.</p></li><li class="listitem"><p><code class="function">.destroy_geom</code> is called when the
	    geom should be disbanded</p></li><li class="listitem"><p><code class="function">.ctlconf</code> is called when user
	    requests reconfiguration of existing
	    geom</p></li></ul></div><p>Also defined are the GEOM event functions, which will get
	copied to the geom instance.</p><p>Field <code class="function">.geom</code> in the <code class="varname">g_class</code> structure is a LIST of
	geoms instantiated from the class.</p><p>These functions are called from the g_event kernel
	thread.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-softc"></a>4.3. Softc</h3></div></div></div><p>The name <span class="quote">&#8220;<span class="quote">softc</span>&#8221;</span> is a legacy term for
	<span class="quote">&#8220;<span class="quote">driver private data</span>&#8221;</span>.  The name most probably
	comes from the archaic term <span class="quote">&#8220;<span class="quote">software control
	  block</span>&#8221;</span>.  In GEOM, it is a structure (more precise:
	pointer to a structure) that can be attached to a geom
	instance to hold whatever data is private to the geom
	instance.  Most GEOM classes have the following
	members:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">struct g_provider *provider</code> : The
	    <span class="quote">&#8220;<span class="quote">provider</span>&#8221;</span> this geom
	    instantiates</p></li><li class="listitem"><p><code class="varname">uint16_t n_disks</code> : Number of
	    consumer this geom consumes</p></li><li class="listitem"><p><code class="varname">struct g_consumer **disks</code> : Array
	    of <code class="varname">struct g_consumer*</code>.  (It is not
	    possible to use just single indirection because struct
	    g_consumer* are created on our behalf by
	    GEOM).</p></li></ul></div><p>The <code class="varname">softc</code> structure
	contains all the state of geom instance.  Every geom instance
	has its own softc.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-metadata"></a>4.4. Metadata</h3></div></div></div><p>Format of metadata is more-or-less class-dependent, but
	MUST start with:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>16 byte buffer for null-terminated signature (usually
	    the class name)</p></li><li class="listitem"><p>uint32 version ID</p></li></ul></div><p>It is assumed that geom classes know how to handle
	metadata with version ID's lower than theirs.</p><p>Metadata is located in the last sector of the provider
	(and thus must fit in it).</p><p>(All this is implementation-dependent but all existing
	code works like that, and it is supported by
	libraries.)</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-creating"></a>4.5. Labeling/creating a GEOM</h3></div></div></div><p>The sequence of events is:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>user calls <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">geom</span>(8)</span></a> utility (or one of its
	    hardlinked friends)</p></li><li class="listitem"><p>the utility figures out which geom class it is
	    supposed to handle and searches for
	    <code class="filename">geom_<em class="replaceable"><code>CLASSNAME</code></em>.so</code>
	    library (usually in
	    <code class="filename">/lib/geom</code>).</p></li><li class="listitem"><p>it <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=dlopen&amp;sektion=3&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">dlopen</span>(3)</span></a>-s the library, extracts the
	    definitions of command-line parameters and helper
	    functions.</p></li></ul></div><p>In the case of creating/labeling a new geom, this is what
	happens:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">geom</span>(8)</span></a> looks in the command-line argument for
	    the command (usually <code class="option">label</code>), and calls a
	    helper function.</p></li><li class="listitem"><p>The helper function checks parameters and gathers
	    metadata, which it proceeds to write to all concerned
	    providers.</p></li><li class="listitem"><p>This <span class="quote">&#8220;<span class="quote">spoils</span>&#8221;</span> existing geoms (if any) and
	    initializes a new round of <span class="quote">&#8220;<span class="quote">tasting</span>&#8221;</span> of the
	    providers.  The intended geom class recognizes the
	    metadata and brings the geom up.</p></li></ul></div><p>(The above sequence of events is implementation-dependent
	but all existing code works like that, and it is supported by
	libraries.)</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-command"></a>4.6. GEOM Command Structure</h3></div></div></div><p>The helper <code class="filename">geom_CLASSNAME.so</code> library
	exports <code class="varname">class_commands</code>
	structure, which is an array of <code class="varname">struct g_command</code> elements.
	Commands are of uniform format and look like:</p><pre class="programlisting">  verb [-options] geomname [other]</pre><p>Common verbs are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>label &#8212; to write metadata to devices so they can
	    be recognized at tasting and brought up in
	    geoms</p></li><li class="listitem"><p>destroy &#8212; to destroy metadata, so the geoms get
	    destroyed</p></li></ul></div><p>Common options are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">-v</code> : be verbose</p></li><li class="listitem"><p><code class="literal">-f</code> : force</p></li></ul></div><p>Many actions, such as labeling and destroying metadata can
	be performed in userland.  For this, <code class="varname">struct g_command</code> provides field
	<code class="varname">gc_func</code> that can be set to a function (in
	the same <code class="filename">.so</code>) that will be called to
	process a verb.  If <code class="varname">gc_func</code> is NULL, the
	command will be passed to kernel module, to
	<code class="function">.ctlreq</code> function of the geom
	class.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-geoms"></a>4.7. Geoms</h3></div></div></div><p>Geoms are instances of GEOM classes.  They have internal
	data (a softc structure) and some functions with which they
	respond to external events.</p><p>The event functions are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">.access</code> : calculates permissions
	    (read/write/exclusive)</p></li><li class="listitem"><p><code class="function">.dumpconf</code> : returns XML-formatted
	    information about the geom</p></li><li class="listitem"><p><code class="function">.orphan</code> : called when some
	    underlying provider gets disconnected</p></li><li class="listitem"><p><code class="function">.spoiled</code> : called when some
	    underlying provider gets written to</p></li><li class="listitem"><p><code class="function">.start</code> : handles I/O</p></li></ul></div><p>These functions are called from the
	<code class="function">g_down</code> kernel thread and there can be no
	sleeping in this context, (see definition of sleeping
	elsewhere) which limits what can be done quite a bit, but
	forces the handling to be fast.</p><p>Of these, the most important function for doing actual
	useful work is the <code class="function">.start</code>() function,
	which is called when a BIO request arrives for a provider
	managed by a instance of geom class.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-threads"></a>4.8. GEOM Threads</h3></div></div></div><p>There are three kernel threads created and run by the GEOM
	framework:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">g_down</code> : Handles requests coming
	    from high-level entities (such as a userland request) on
	    the way to physical devices</p></li><li class="listitem"><p><code class="literal">g_up</code> : Handles responses from
	    device drivers to requests made by higher-level
	    entities</p></li><li class="listitem"><p><code class="literal">g_event</code> : Handles all other cases:
	    creation of geom instances, access counting,
	    <span class="quote">&#8220;<span class="quote">spoil</span>&#8221;</span> events, etc.</p></li></ul></div><p>When a user process issues <span class="quote">&#8220;<span class="quote">read data X at offset Y
	  of a file</span>&#8221;</span> request, this is what happens:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The filesystem converts the request into a struct bio
	    instance and passes it to the GEOM subsystem.  It knows
	    what geom instance should handle it because filesystems
	    are hosted directly on a geom instance.</p></li><li class="listitem"><p>The request ends up as a call to the
	    <code class="function">.start</code>() function made on the g_down
	    thread and reaches the top-level geom
	    instance.</p></li><li class="listitem"><p>This top-level geom instance (for example the
	    partition slicer) determines that the request should be
	    routed to a lower-level instance (for example the disk
	    driver).  It makes a copy of the bio request (bio requests
	    <span class="emphasis"><em>ALWAYS</em></span> need to be copied between
	    instances, with <code class="function">g_clone_bio</code>()!),
	    modifies the data offset and target provider fields and
	    executes the copy with
	    <code class="function">g_io_request</code>()</p></li><li class="listitem"><p>The disk driver gets the bio request also as a call to
	    <code class="function">.start</code>() on the
	    <code class="literal">g_down</code> thread.  It talks to hardware,
	    gets the data back, and calls
	    <code class="function">g_io_deliver</code>() on the
	    bio.</p></li><li class="listitem"><p>Now, the notification of bio completion <span class="quote">&#8220;<span class="quote">bubbles
	      up</span>&#8221;</span> in the <code class="literal">g_up</code> thread.  First
	    the partition slicer gets <code class="function">.done</code>()
	    called in the <code class="literal">g_up</code> thread, it uses
	    information stored in the bio to free the cloned <code class="varname">bio</code> structure (with
	    <code class="function">g_destroy_bio</code>()) and calls
	    <code class="function">g_io_deliver</code>() on the original
	    request.</p></li><li class="listitem"><p>The filesystem gets the data and transfers it to
	    userland.</p></li></ul></div><p>See <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">g_bio</span>(9)</span></a> man page for information how the data is
	passed back and forth in the <code class="varname">bio</code> structure (note in
	particular the <code class="varname">bio_parent</code> and
	<code class="varname">bio_children</code> fields and how they are
	handled).</p><p>One important feature is: <span class="emphasis"><em>THERE CAN BE NO
	  SLEEPING IN G_UP AND G_DOWN THREADS</em></span>.  This means
	that none of the following things can be done in those threads
	(the list is of course not complete, but only
	informative):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Calls to <code class="function">msleep</code>() and
	    <code class="function">tsleep</code>(),
	    obviously.</p></li><li class="listitem"><p>Calls to <code class="function">g_write_data</code>() and
	    <code class="function">g_read_data</code>(), because these sleep
	    between passing the data to consumers and
	    returning.</p></li><li class="listitem"><p>Waiting for I/O.</p></li><li class="listitem"><p>Calls to <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">malloc</span>(9)</span></a> and
	    <code class="function">uma_zalloc</code>() with
	    <code class="varname">M_WAITOK</code> flag set</p></li><li class="listitem"><p>sx and other sleepable locks</p></li></ul></div><p>This restriction is here to stop GEOM code clogging the
	I/O request path, since sleeping is usually not time-bound and
	there can be no guarantees on how long will it take (there are
	some other, more technical reasons also).  It also means that
	there is not much that can be done in those threads; for
	example, almost any complex thing requires memory allocation.
	Fortunately, there is a way out: creating additional kernel
	threads.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="geom-kernelthreads"></a>4.9. Kernel Threads for Use in GEOM Code</h3></div></div></div><p>Kernel threads are created with <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=kthread_create&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">kthread_create</span>(9)</span></a>
	function, and they are sort of similar to userland threads in
	behavior, only they cannot return to caller to signify
	termination, but must call <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=kthread_exit&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">kthread_exit</span>(9)</span></a>.</p><p>In GEOM code, the usual use of threads is to offload
	processing of requests from <code class="literal">g_down</code> thread
	(the <code class="function">.start</code>() function).  These threads
	look like <span class="quote">&#8220;<span class="quote">event handlers</span>&#8221;</span>: they have a linked
	list of event associated with them (on which events can be
	posted by various functions in various threads so it must be
	protected by a mutex), take the events from the list one by
	one and process them in a big <code class="literal">switch</code>()
	statement.</p><p>The main benefit of using a thread to handle I/O requests
	is that it can sleep when needed.  Now, this sounds good, but
	should be carefully thought out.  Sleeping is well and very
	convenient but can very effectively destroy performance of the
	geom transformation.  Extremely performance-sensitive classes
	probably should do all the work in
	<code class="function">.start</code>() function call, taking great care
	to handle out-of-memory and similar errors.</p><p>The other benefit of having a event-handler thread like
	that is to serialize all the requests and responses coming
	from different geom threads into one thread.  This is also
	very convenient but can be slow.  In most cases, handling of
	<code class="function">.done</code>() requests can be left to the
	<code class="literal">g_up</code> thread.</p><p>Mutexes in FreeBSD kernel (see <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">mutex</span>(9)</span></a>) have one
	distinction from their more common userland cousins &#8212;
	the code cannot sleep while holding a mutex).  If the code
	needs to sleep a lot, <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">sx</span>(9)</span></a> locks may be more
	appropriate.  On the other hand, if you do almost everything
	in a single thread, you may get away with no mutexes at
	all.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kernelprog.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">3. On FreeBSD Kernel Programming </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>