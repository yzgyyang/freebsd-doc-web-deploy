<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Independent Verification of IPsec Functionality in FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><meta name="description" content="You installed IPsec and it seems to be working. How do you know? I describe a method for experimentally verifying that IPsec is working." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="en" class="article" lang="en"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp43962616"></a>Independent Verification of IPsec Functionality in FreeBSD</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Honig</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:honig@sprynet.com">honig@sprynet.com</a>&gt;</code></p></div></div></div></div><div>Revision: <a href="https://svnweb.freebsd.org/changeset/doc/b2dc7db00d"><span class="svnref">b2dc7db00d</span></a></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD is a registered trademark of
  the FreeBSD Foundation.</p><p>Motif, OSF/1, and UNIX are
  registered trademarks and IT DialTone and The Open Group are
  trademarks of The Open Group in the United States and other
  countries.</p><p>Many of the designations used by
  manufacturers and sellers to distinguish their products are claimed
  as trademarks.  Where those designations appear in this document,
  and the FreeBSD Project was aware of the trademark claim, the
  designations have been followed by the <span class="quote">&#8220;<span class="quote">&#8482;</span>&#8221;</span> or the
  <span class="quote">&#8220;<span class="quote">®</span>&#8221;</span> symbol.</p></div></div><div>Last modified on 2018-09-06 01:30:47 +0000 by ebrandi.</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Abstract</div><p>You installed IPsec and it seems to be working. How do you
        know?  I describe a method for experimentally verifying that IPsec is
        working.</p></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">Split HTML</a>
      /
      
	  Single HTML
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="#problem">1. The Problem</a></span></dt><dt><span class="sect1"><a href="#solution">2. The Solution</a></span></dt><dt><span class="sect1"><a href="#experiment">3. The Experiment</a></span></dt><dt><span class="sect1"><a href="#caveat">4. Caveat</a></span></dt><dt><span class="sect1"><a href="#IPsec">5. IPsec---Definition</a></span></dt><dt><span class="sect1"><a href="#ipsec-install">6. Installing IPsec</a></span></dt><dt><span class="sect1"><a href="#kernel">7. src/sys/i386/conf/KERNELNAME</a></span></dt><dt><span class="sect1"><a href="#code">8. Maurer's Universal Statistical Test (for block size=8
        bits)</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="problem"></a>1. The Problem</h2></div></div></div><p>First, lets assume you have <a class="link" href="#ipsec-install" title="6. Installing IPsec">
      installed <span class="emphasis"><em>IPsec</em></span></a>.  How do you know
      it is <a class="link" href="#caveat" title="4. Caveat">working</a>?  Sure, your
      connection will not work if it is misconfigured, and it will work
      when you finally get it right.  <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> will list it.
      But can you independently confirm it?</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="solution"></a>2. The Solution</h2></div></div></div><p>First, some crypto-relevant info theory:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Encrypted data is uniformly distributed, i.e., has maximal
	  entropy per symbol;</p></li><li class="listitem"><p>Raw, uncompressed data is typically redundant, i.e., has
	  sub-maximal entropy.</p></li></ol></div><p>Suppose you could measure the entropy of the data to- and
      from- your network interface.  Then you could see the difference
      between unencrypted data and encrypted data.  This would be true
      even if some of the data in <span class="quote">&#8220;<span class="quote">encrypted mode</span>&#8221;</span> was
      not encrypted---as the outermost IP header must be if the
      packet is to be routable.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="MUST"></a>2.1. MUST</h3></div></div></div><p>Ueli Maurer's <span class="quote">&#8220;<span class="quote">Universal Statistical Test for Random
	Bit Generators</span>&#8221;</span>(<a class="link" href="https://web.archive.org/web/20011115002319/http://www.geocities.com/SiliconValley/Code/4704/universal.pdf" target="_top">
	<acronym class="acronym">MUST</acronym></a>) quickly measures the entropy
	of a sample.  It uses a compression-like algorithm.  <a class="link" href="#code" title="8. Maurer's Universal Statistical Test (for block size=8 bits)">The code is given below</a> for a variant
	which measures successive (~quarter megabyte) chunks of a
	file.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="tcpdump"></a>2.2. Tcpdump</h3></div></div></div><p>We also need a way to capture the raw network data.  A
	program called <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a> lets you do this, if you have
	enabled the <span class="emphasis"><em>Berkeley Packet Filter</em></span>
	interface in your <a class="link" href="#kernel" title="7. src/sys/i386/conf/KERNELNAME">kernel's config
	file</a>.</p><p>The command:</p><pre class="screen"><strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w <em class="replaceable"><code>dumpfile.bin</code></em></code></strong></pre><p>will capture 4000 raw packets to
      <em class="replaceable"><code>dumpfile.bin</code></em>.  Up to 10,000 bytes per
      packet will be captured in this example.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="experiment"></a>3. The Experiment</h2></div></div></div><p>Here is the experiment:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Open a window to an IPsec host and another window to an
	  insecure host.</p></li><li class="step"><p>Now start <a class="link" href="#tcpdump" title="2.2. Tcpdump">capturing
	  packets</a>.</p></li><li class="step"><p>In the <span class="quote">&#8220;<span class="quote">secure</span>&#8221;</span> window, run the <span class="trademark">UNIX</span>®
	  command <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=yes&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">yes</span>(1)</span></a>, which will stream the <code class="literal">y</code>
	  character.  After a while, stop this.  Switch to the
	  insecure window, and repeat.  After a while, stop.</p></li><li class="step"><p>Now run <a class="link" href="#code" title="8. Maurer's Universal Statistical Test (for block size=8 bits)">MUST</a> on the
	  captured packets.  You should see something like the
	  following.  The important thing to note is that the secure
	  connection has 93% (6.7) of the expected value (7.18), and
	  the <span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> connection has 29% (2.1) of the
	  expected value.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w <em class="replaceable"><code>ipsecdemo.bin</code></em></code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>uliscan <em class="replaceable"><code>ipsecdemo.bin</code></em></code></strong>

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre></li></ol></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="caveat"></a>4. Caveat</h2></div></div></div><p>This experiment shows that IPsec <span class="emphasis"><em>does</em></span>
      seem to be distributing the payload data
      <span class="emphasis"><em>uniformly</em></span>, as encryption should.  However,
      the experiment described here <span class="emphasis"><em>cannot</em></span>
      detect many possible flaws in a system (none of which do I have
      any evidence for).  These include poor key generation or
      exchange, data or keys being visible to others, use of weak
      algorithms, kernel subversion, etc.  Study the source; know the
      code.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="IPsec"></a>5. IPsec---Definition</h2></div></div></div><p>Internet Protocol security extensions to IPv4; required for
      IPv6.  A protocol for negotiating encryption and authentication
      at the IP (host-to-host) level.  SSL secures only one application
      socket; <span class="application">SSH</span> secures only a login;
      <span class="application">PGP</span> secures only a specified file or
      message.  IPsec encrypts everything between two hosts.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ipsec-install"></a>6. Installing IPsec</h2></div></div></div><p>Most of the modern versions of FreeBSD have IPsec support
      in their base source.  So you will need to include the
      <code class="option">IPSEC</code> option in your kernel config and, after
      kernel rebuild and reinstall, configure IPsec connections using
      <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">setkey</span>(8)</span></a> command.</p><p>A comprehensive guide on running IPsec on FreeBSD is
      provided in <a class="link" href="../../../../doc/en_US.ISO8859-1/books/handbook/ipsec.html" target="_top">FreeBSD
      Handbook</a>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel"></a>7. src/sys/i386/conf/KERNELNAME</h2></div></div></div><p>This needs to be present in the kernel config file in order
      to capture network data with <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Be sure
      to run <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=config&amp;sektion=8&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">config</span>(8)</span></a> after adding this, and rebuild and
      reinstall.</p><pre class="programlisting">device	bpf</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="code"></a>8. Maurer's Universal Statistical Test (for block size=8
        bits)</h2></div></div></div><p>You can find the same code at <a class="link" href="https://web.archive.org/web/20031204230654/http://www.geocities.com:80/SiliconValley/Code/4704/uliscanc.txt" target="_top">
          this link</a>.</p><pre class="programlisting">/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1&lt;&lt;L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc &lt; 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i &lt; V; i++) {
    table[i] = 0;
  }

  for (i = 0; i &lt; Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run &amp;&amp; i &lt; Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b &lt; 0)
          run = 0;

        if (run) {
          if (table[b] &gt; j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i &lt; (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i &lt; Q; i++) {
        b = fgetc(fptr);
        if (b &lt; 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}</pre></div></div></body></html>