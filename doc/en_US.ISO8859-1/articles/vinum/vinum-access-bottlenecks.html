<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>2. Access Bottlenecks</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="The vinum Volume Manager" /><link rel="up" href="index.html" title="The vinum Volume Manager" /><link rel="prev" href="index.html" title="The vinum Volume Manager" /><link rel="next" href="vinum-data-integrity.html" title="3. Data Integrity" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Access Bottlenecks</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="vinum-data-integrity.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vinum-access-bottlenecks"></a>2. Access Bottlenecks</h2></div></div></div><p>Modern systems frequently need to access data in a highly
      concurrent manner.  For example, large FTP or HTTP servers can
      maintain thousands of concurrent sessions and have multiple
      100 Mbit/s connections to the outside world, well beyond
      the sustained transfer rate of most disks.</p><p>Current disk drives can transfer data sequentially at up to
      70 MB/s, but this value is of little importance in an
      environment where many independent processes access a drive, and
      where they may achieve only a fraction of these values.  In such
      cases, it is more interesting to view the problem from the
      viewpoint of the disk subsystem.  The important parameter is the
      load that a transfer places on the subsystem, or the time for
      which a transfer occupies the drives involved in the
      transfer.</p><p>In any disk transfer, the drive must first position the
      heads, wait for the first sector to pass under the read head,
      and then perform the transfer.  These actions can be considered
      to be atomic as it does not make any sense to interrupt
      them.</p><p><a id="vinum-latency"></a> Consider a typical transfer of
      about 10 kB: the current generation of high-performance
      disks can position the heads in an average of 3.5 ms.  The
      fastest drives spin at 15,000 rpm, so the average
      rotational latency (half a revolution) is 2 ms.  At
      70 MB/s, the transfer itself takes about 150 &#956;s,
      almost nothing compared to the positioning time.  In such a
      case, the effective transfer rate drops to a little over
      1 MB/s and is clearly highly dependent on the transfer
      size.</p><p>The traditional and obvious solution to this bottleneck is
      <span class="quote">&#8220;<span class="quote">more spindles</span>&#8221;</span>:  rather than using one large disk,
      use several smaller disks with the same aggregate storage
      space.  Each disk is capable of positioning and transferring
      independently, so the effective throughput increases by a factor
      close to the number of disks used.</p><p>The actual throughput improvement is smaller than the
      number of disks involved.  Although each drive is capable of
      transferring in parallel, there is no way to ensure that the
      requests are evenly distributed across the drives.  Inevitably
      the load on one drive will be higher than on another.</p><a id="idp46890232" class="indexterm"></a><a id="idp46892408" class="indexterm"></a><p>The evenness of the load on the disks is strongly dependent
      on the way the data is shared across the drives.  In the
      following discussion, it is convenient to think of the disk
      storage as a large number of data sectors which are addressable
      by number, rather like the pages in a book.  The most obvious
      method is to divide the virtual disk into groups of consecutive
      sectors the size of the individual physical disks and store them
      in this manner, rather like taking a large book and tearing it
      into smaller sections.  This method is called
      <span class="emphasis"><em>concatenation</em></span> and has the advantage that
      the disks are not required to have any specific size
      relationships.  It works well when the access to the virtual
      disk is spread evenly about its address space.  When access is
      concentrated on a smaller area, the improvement is less marked.
      <a class="xref" href="vinum-access-bottlenecks.html#vinum-concat" title="Figure 1. Concatenated Organization">Figure 1, &#8220;Concatenated Organization&#8221;</a> illustrates the sequence in
      which storage units are allocated in a concatenated
      organization.</p><p>
      </p><div class="figure"><a id="vinum-concat"></a><div class="figure-title">Figure 1. Concatenated Organization</div><div class="figure-contents"><div class="mediaobject"><img src="vinum-concat.png" alt="Concatenated Organization" /></div></div></div><p><br class="figure-break" /></p><a id="idp46916216" class="indexterm"></a><a id="idp46917880" class="indexterm"></a><a id="idp46920184" class="indexterm"></a><p>An alternative mapping is to divide the address space into
      smaller, equal-sized components and store them sequentially on
      different devices.  For example, the first 256 sectors may be
      stored on the first disk, the next 256 sectors on the next disk
      and so on.  After filling the last disk, the process repeats
      until the disks are full.  This mapping is called
      <span class="emphasis"><em>striping</em></span> or
      <acronym class="acronym">RAID-0</acronym>.</p><p><acronym class="acronym">RAID</acronym> offers various forms of fault
      tolerance, though <acronym class="acronym">RAID-0</acronym> is somewhat
      misleading as it provides no redundancy.  Striping requires
      somewhat more effort to locate the data, and it can cause
      additional I/O load where a transfer is spread over multiple
      disks, but it can also provide a more constant load across the
      disks.  <a class="xref" href="vinum-access-bottlenecks.html#vinum-striped" title="Figure 2. Striped Organization">Figure 2, &#8220;Striped Organization&#8221;</a> illustrates the
      sequence in which storage units are allocated in a striped
      organization.</p><p>
      </p><div class="figure"><a id="vinum-striped"></a><div class="figure-title">Figure 2. Striped Organization</div><div class="figure-contents"><div class="mediaobject"><img src="vinum-striped.png" alt="Striped Organization" /></div></div></div><p><br class="figure-break" /></p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="vinum-data-integrity.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The <code class="filename">vinum</code> Volume Manager </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Data Integrity</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>