<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>5. Pre-Faulting and Zeroing Optimizations</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Design elements of the FreeBSD VM system" /><link rel="up" href="index.html" title="Design elements of the FreeBSD VM system" /><link rel="prev" href="freeing-pages.html" title="4. When to free a page" /><link rel="next" href="page-table-optimizations.html" title="6. Page Table Optimizations" /><link rel="copyright" href="trademarks.html" title="Legal Notice" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Pre-Faulting and Zeroing Optimizations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="freeing-pages.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="page-table-optimizations.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="prefault-optimizations"></a>5. Pre-Faulting and Zeroing Optimizations</h2></div></div></div><p>Taking a VM fault is not expensive if the underlying page is already
      in core and can simply be mapped into the process, but it can become
      expensive if you take a whole lot of them on a regular basis.  A good
      example of this is running a program such as <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> or <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a>
      over and over again.  If the program binary is mapped into memory but
      not mapped into the page table, then all the pages that will be accessed
      by the program will have to be faulted in every time the program is run.
      This is unnecessary when the pages in question are already in the VM
      Cache, so FreeBSD will attempt to pre-populate a process's page tables
      with those pages that are already in the VM Cache.  One thing that
      FreeBSD does not yet do is pre-copy-on-write certain pages on exec.  For
      example, if you run the <a class="citerefentry" href="https://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;manpath=freebsd-release-ports"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> program while running <code class="command">vmstat
	1</code> you will notice that it always takes a certain number of
      page faults, even when you run it over and over again.  These are
      zero-fill faults, not program code faults (which were pre-faulted in
      already).  Pre-copying pages on exec or fork is an area that could use
      more study.</p><p>A large percentage of page faults that occur are zero-fill faults.
      You can usually see this by observing the <code class="command">vmstat -s</code>
      output.  These occur when a process accesses pages in its BSS area.  The
      BSS area is expected to be initially zero but the VM system does not
      bother to allocate any memory at all until the process actually accesses
      it.  When a fault occurs the VM system must not only allocate a new page,
      it must zero it as well.  To optimize the zeroing operation the VM system
      has the ability to pre-zero pages and mark them as such, and to request
      pre-zeroed pages when zero-fill faults occur.  The pre-zeroing occurs
      whenever the CPU is idle but the number of pages the system pre-zeros is
      limited in order to avoid blowing away the memory caches.  This is an
      excellent example of adding complexity to the VM system in order to
      optimize the critical path.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="freeing-pages.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="page-table-optimizations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. When to free a page </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. Page Table Optimizations</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>