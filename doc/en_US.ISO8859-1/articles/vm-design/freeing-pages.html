<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>4. When to free a page</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Design elements of the FreeBSD VM system" /><link rel="up" href="index.html" title="Design elements of the FreeBSD VM system" /><link rel="prev" href="swap-layers.html" title="3. SWAP Layers" /><link rel="next" href="prefault-optimizations.html" title="5. Pre-Faulting and Zeroing Optimizations" /><link rel="copyright" href="trademarks.html" title="Legal Notice" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. When to free a page</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="swap-layers.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="prefault-optimizations.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="freeing-pages"></a>4. When to free a page</h2></div></div></div><p>Since the VM system uses all available memory for disk caching,
      there are usually very few truly-free pages.  The VM system depends on
      being able to properly choose pages which are not in use to reuse for
      new allocations.  Selecting the optimal pages to free is possibly the
      single-most important function any VM system can perform because if it
      makes a poor selection, the VM system may be forced to unnecessarily
      retrieve pages from disk, seriously degrading system performance.</p><p>How much overhead are we willing to suffer in the critical path to
      avoid freeing the wrong page?  Each wrong choice we make will cost us
      hundreds of thousands of CPU cycles and a noticeable stall of the
      affected processes, so we are willing to endure a significant amount of
      overhead in order to be sure that the right page is chosen.  This is why
      FreeBSD tends to outperform other systems when memory resources become
      stressed.</p><p>The free page determination algorithm is built upon a history of the
      use of memory pages.  To acquire this history, the system takes advantage
      of a page-used bit feature that most hardware page tables have.</p><p>In any case, the page-used bit is cleared and at some later point
      the VM system comes across the page again and sees that the page-used
      bit has been set.  This indicates that the page is still being actively
      used.  If the bit is still clear it is an indication that the page is not
      being actively used.  By testing this bit periodically, a use history (in
      the form of a counter) for the physical page is developed.  When the VM
      system later needs to free up some pages, checking this history becomes
      the cornerstone of determining the best candidate page to reuse.</p><div class="sidebar"><div xmlns="" class="titlepage"><div><div><div xmlns="http://www.w3.org/1999/xhtml" class="-title"></div></div></div></div><p>For those platforms that do not have this feature, the system
	actually emulates a page-used bit.  It unmaps or protects a page,
	forcing a page fault if the page is accessed again.  When the page
	fault is taken, the system simply marks the page as having been used
	and unprotects the page so that it may be used.  While taking such page
	faults just to determine if a page is being used appears to be an
	expensive proposition, it is much less expensive than reusing the page
	for some other purpose only to find that a process needs it back and
	then have to go to disk.</p></div><p>FreeBSD makes use of several page queues to further refine the
      selection of pages to reuse as well as to determine when dirty pages
      must be flushed to their backing store.  Since page tables are dynamic
      entities under FreeBSD, it costs virtually nothing to unmap a page from
      the address space of any processes using it.  When a page candidate has
      been chosen based on the page-use counter, this is precisely what is
      done.  The system must make a distinction between clean pages which can
      theoretically be freed up at any time, and dirty pages which must first
      be written to their backing store before being reusable.  When a page
      candidate has been found it is moved to the inactive queue if it is
      dirty, or the cache queue if it is clean.  A separate algorithm based on
      the dirty-to-clean page ratio determines when dirty pages in the
      inactive queue must be flushed to disk.  Once this is accomplished, the
      flushed pages are moved from the inactive queue to the cache queue.  At
      this point, pages in the cache queue can still be reactivated by a VM
      fault at relatively low cost.  However, pages in the cache queue are
      considered to be <span class="quote">&#8220;<span class="quote">immediately freeable</span>&#8221;</span> and will be reused
      in an LRU (least-recently used) fashion when the system needs to
      allocate new memory.</p><p>It is important to note that the FreeBSD VM system attempts to
      separate clean and dirty pages for the express reason of avoiding
      unnecessary flushes of dirty pages (which eats I/O bandwidth), nor does
      it move pages between the various page queues gratuitously when the
      memory subsystem is not being stressed.  This is why you will see some
      systems with very low cache queue counts and high active queue counts
      when doing a <code class="command">systat -vm</code> command.  As the VM system
      becomes more stressed, it makes a greater effort to maintain the various
      page queues at the levels determined to be the most effective.</p><p>An urban
      myth has circulated for years that Linux did a better job avoiding
      swapouts than FreeBSD, but this in fact is not true.  What was actually
      occurring was that FreeBSD was proactively paging out unused pages in
      order to make room for more disk cache while Linux was keeping unused
      pages in core and leaving less memory available for cache and process
      pages.  I do not know whether this is still true today.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="swap-layers.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="prefault-optimizations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3. SWAP Layers </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5. Pre-Faulting and Zeroing Optimizations</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="https://download.freebsd.org/ftp/doc/">https://download.freebsd.org/ftp/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="https://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>